(window["webpackJsonp"] = window["webpackJsonp"] || []).push([["default~app~beta~example"],{

/***/ "./node_modules/anatomogram/lib/img sync recursive ^\\.\\/.*selected\\.png$":
/*!*********************************************************************!*\
  !*** ./node_modules/anatomogram/lib/img sync ^\.\/.*selected\.png$ ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var map = {
	"./brain.selected.png": "./node_modules/anatomogram/lib/img/brain.selected.png",
	"./brain.unselected.png": "./node_modules/anatomogram/lib/img/brain.unselected.png",
	"./female.selected.png": "./node_modules/anatomogram/lib/img/female.selected.png",
	"./female.unselected.png": "./node_modules/anatomogram/lib/img/female.unselected.png",
	"./flower_parts.selected.png": "./node_modules/anatomogram/lib/img/flower_parts.selected.png",
	"./flower_parts.unselected.png": "./node_modules/anatomogram/lib/img/flower_parts.unselected.png",
	"./male.selected.png": "./node_modules/anatomogram/lib/img/male.selected.png",
	"./male.unselected.png": "./node_modules/anatomogram/lib/img/male.unselected.png",
	"./whole_plant.selected.png": "./node_modules/anatomogram/lib/img/whole_plant.selected.png",
	"./whole_plant.unselected.png": "./node_modules/anatomogram/lib/img/whole_plant.unselected.png"
};


function webpackContext(req) {
	var id = webpackContextResolve(req);
	return __webpack_require__(id);
}
function webpackContextResolve(req) {
	var id = map[req];
	if(!(id + 1)) { // check for number or string
		var e = new Error("Cannot find module '" + req + "'");
		e.code = 'MODULE_NOT_FOUND';
		throw e;
	}
	return id;
}
webpackContext.keys = function webpackContextKeys() {
	return Object.keys(map);
};
webpackContext.resolve = webpackContextResolve;
module.exports = webpackContext;
webpackContext.id = "./node_modules/anatomogram/lib/img sync recursive ^\\.\\/.*selected\\.png$";

/***/ }),

/***/ "./node_modules/anatomogram/lib/svg sync recursive ^\\.\\/.*\\.svg$":
/*!*************************************************************!*\
  !*** ./node_modules/anatomogram/lib/svg sync ^\.\/.*\.svg$ ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var map = {
	"./anolis_carolinensis.svg": "./node_modules/anatomogram/lib/svg/anolis_carolinensis.svg",
	"./arabidopsis_thaliana.svg": "./node_modules/anatomogram/lib/svg/arabidopsis_thaliana.svg",
	"./bos_taurus.svg": "./node_modules/anatomogram/lib/svg/bos_taurus.svg",
	"./brachypodium_distachyon.flower_parts.svg": "./node_modules/anatomogram/lib/svg/brachypodium_distachyon.flower_parts.svg",
	"./brachypodium_distachyon.whole_plant.svg": "./node_modules/anatomogram/lib/svg/brachypodium_distachyon.whole_plant.svg",
	"./gallus_gallus.svg": "./node_modules/anatomogram/lib/svg/gallus_gallus.svg",
	"./homo_sapiens.brain.svg": "./node_modules/anatomogram/lib/svg/homo_sapiens.brain.svg",
	"./homo_sapiens.female.svg": "./node_modules/anatomogram/lib/svg/homo_sapiens.female.svg",
	"./homo_sapiens.male.svg": "./node_modules/anatomogram/lib/svg/homo_sapiens.male.svg",
	"./hordeum_vulgare.flower_parts.svg": "./node_modules/anatomogram/lib/svg/hordeum_vulgare.flower_parts.svg",
	"./hordeum_vulgare.whole_plant.svg": "./node_modules/anatomogram/lib/svg/hordeum_vulgare.whole_plant.svg",
	"./macaca_mulatta.svg": "./node_modules/anatomogram/lib/svg/macaca_mulatta.svg",
	"./monodelphis_domestica.svg": "./node_modules/anatomogram/lib/svg/monodelphis_domestica.svg",
	"./mus_musculus.brain.svg": "./node_modules/anatomogram/lib/svg/mus_musculus.brain.svg",
	"./mus_musculus.female.svg": "./node_modules/anatomogram/lib/svg/mus_musculus.female.svg",
	"./mus_musculus.male.svg": "./node_modules/anatomogram/lib/svg/mus_musculus.male.svg",
	"./oryza_sativa.flower_parts.svg": "./node_modules/anatomogram/lib/svg/oryza_sativa.flower_parts.svg",
	"./oryza_sativa.whole_plant.svg": "./node_modules/anatomogram/lib/svg/oryza_sativa.whole_plant.svg",
	"./papio_anubis.svg": "./node_modules/anatomogram/lib/svg/papio_anubis.svg",
	"./rattus_norvegicus.svg": "./node_modules/anatomogram/lib/svg/rattus_norvegicus.svg",
	"./solanum_lycopersicum.flower_parts.svg": "./node_modules/anatomogram/lib/svg/solanum_lycopersicum.flower_parts.svg",
	"./solanum_lycopersicum.whole_plant.svg": "./node_modules/anatomogram/lib/svg/solanum_lycopersicum.whole_plant.svg",
	"./solanum_tuberosum.svg": "./node_modules/anatomogram/lib/svg/solanum_tuberosum.svg",
	"./sorghum_bicolor.flower_parts.svg": "./node_modules/anatomogram/lib/svg/sorghum_bicolor.flower_parts.svg",
	"./sorghum_bicolor.whole_plant.svg": "./node_modules/anatomogram/lib/svg/sorghum_bicolor.whole_plant.svg",
	"./tetraodon_nigroviridis.svg": "./node_modules/anatomogram/lib/svg/tetraodon_nigroviridis.svg",
	"./triticum_aestivum.flower_parts.svg": "./node_modules/anatomogram/lib/svg/triticum_aestivum.flower_parts.svg",
	"./triticum_aestivum.whole_plant.svg": "./node_modules/anatomogram/lib/svg/triticum_aestivum.whole_plant.svg",
	"./xenopus_tropicalis.svg": "./node_modules/anatomogram/lib/svg/xenopus_tropicalis.svg",
	"./zea_mays.flower_parts.svg": "./node_modules/anatomogram/lib/svg/zea_mays.flower_parts.svg",
	"./zea_mays.whole_plant.svg": "./node_modules/anatomogram/lib/svg/zea_mays.whole_plant.svg"
};


function webpackContext(req) {
	var id = webpackContextResolve(req);
	return __webpack_require__(id);
}
function webpackContextResolve(req) {
	var id = map[req];
	if(!(id + 1)) { // check for number or string
		var e = new Error("Cannot find module '" + req + "'");
		e.code = 'MODULE_NOT_FOUND';
		throw e;
	}
	return id;
}
webpackContext.keys = function webpackContextKeys() {
	return Object.keys(map);
};
webpackContext.resolve = webpackContextResolve;
module.exports = webpackContext;
webpackContext.id = "./node_modules/anatomogram/lib/svg sync recursive ^\\.\\/.*\\.svg$";

/***/ }),

/***/ "./src/ChellVizApp.tsx":
/*!*****************************!*\
  !*** ./src/ChellVizApp.tsx ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
var React = __webpack_require__(/*! react */ "./node_modules/react/index.js");
var react_router_dom_1 = __webpack_require__(/*! react-router-dom */ "./node_modules/react-router-dom/es/index.js");
var semantic_ui_react_1 = __webpack_require__(/*! semantic-ui-react */ "./node_modules/semantic-ui-react/dist/es/index.js");
var container_1 = __webpack_require__(/*! ~chell-viz~/container */ "./src/container/index.ts");
var context_1 = __webpack_require__(/*! ~chell-viz~/context */ "./src/context/index.ts");
var page_1 = __webpack_require__(/*! ~chell-viz~/page */ "./src/page/index.ts");
var ChellVizApp = /** @class */ (function (_super) {
    __extends(ChellVizApp, _super);
    function ChellVizApp(props) {
        var _this = _super.call(this, props) || this;
        _this.renderComponents = function (props) { return (React.createElement(context_1.ChellContextProvider, __assign({}, props),
            React.createElement(semantic_ui_react_1.Container, { id: 'ChellVizApp', fluid: true },
                React.createElement(container_1.SiteHeader, __assign({}, props)),
                React.createElement(react_router_dom_1.Route, { exact: true, strict: true, path: '/visualizations', render: _this.renderVisualizationsPage }),
                React.createElement(react_router_dom_1.Route, { exact: true, strict: true, path: '/visualizations/', render: _this.renderOverviewPage }),
                React.createElement(react_router_dom_1.Route, { path: '/dataset', render: _this.renderDatasetPage }),
                React.createElement(react_router_dom_1.Route, { path: '/stories', render: _this.renderStoriesPage }),
                React.createElement(react_router_dom_1.Route, { exact: true, path: '/', render: _this.renderLandingPage })))); };
        _this.renderVisualizationsPage = function (props) {
            return React.createElement(page_1.VisualizationsPage, __assign({}, props));
        };
        _this.renderDatasetPage = function (props) {
            return React.createElement(page_1.DatasetPage, __assign({}, props));
        };
        _this.renderLandingPage = function (props) {
            return React.createElement(page_1.LandingPage, __assign({}, props));
        };
        _this.renderOverviewPage = function (props) {
            return React.createElement(page_1.VizOverviewPage, __assign({}, props));
        };
        _this.renderStoriesPage = function (props) {
            return React.createElement(page_1.StoriesPage, __assign({}, props));
        };
        _this.state = {
            activeVisualizations: 0,
        };
        return _this;
    }
    ChellVizApp.prototype.componentDidMount = function () {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                this.setState({
                    activeVisualizations: 2,
                });
                return [2 /*return*/];
            });
        });
    };
    ChellVizApp.prototype.render = function () {
        return (React.createElement(react_router_dom_1.HashRouter, null,
            React.createElement(react_router_dom_1.Route, { render: this.renderComponents })));
    };
    return ChellVizApp;
}(React.Component));
exports.ChellVizApp = ChellVizApp;


/***/ }),

/***/ "./src/component/ContactMap.tsx":
/*!**************************************!*\
  !*** ./src/component/ContactMap.tsx ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spread = (this && this.__spread) || function () {
    for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));
    return ar;
};
var __values = (this && this.__values) || function (o) {
    var m = typeof Symbol === "function" && o[Symbol.iterator], i = 0;
    if (m) return m.call(o);
    return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
};
Object.defineProperty(exports, "__esModule", { value: true });
var React = __webpack_require__(/*! react */ "./node_modules/react/index.js");
var semantic_ui_react_1 = __webpack_require__(/*! semantic-ui-react */ "./node_modules/semantic-ui-react/dist/es/index.js");
var component_1 = __webpack_require__(/*! ~chell-viz~/component */ "./src/component/index.ts");
var context_1 = __webpack_require__(/*! ~chell-viz~/context */ "./src/context/index.ts");
var data_1 = __webpack_require__(/*! ~chell-viz~/data */ "./src/data/index.ts");
exports.initialContactMapState = {
    pointsToPlot: new Array(),
};
var ContactMapClass = /** @class */ (function (_super) {
    __extends(ContactMapClass, _super);
    function ContactMapClass(props) {
        var _this = _super.call(this, props) || this;
        _this.state = exports.initialContactMapState;
        _this.onNodeSizeChange = function (index) { return function (value) {
            var pointsToPlot = _this.state.pointsToPlot;
            _this.setState({
                pointsToPlot: __spread(pointsToPlot.slice(0, index), [
                    __assign({}, pointsToPlot[index], { nodeSize: value })
                ], pointsToPlot.slice(index + 1)),
            });
        }; };
        _this.generateNodeSizeSliderConfigs = function (entries) {
            return entries.map(function (entry, index) {
                return {
                    id: "node-size-slider-" + index,
                    name: "Node size for " + entry.name,
                    onChange: _this.onNodeSizeChange(index),
                    type: data_1.CONFIGURATION_COMPONENT_TYPE.SLIDER,
                    values: {
                        current: entry.nodeSize,
                        max: 20,
                        min: 1,
                    },
                };
            });
        };
        _this.onMouseEnter = function (cb) { return function (e) {
            var e_1, _a, e_2, _b;
            if (e.isAxis()) {
                var _c = _this.props, secondaryStructureContext = _c.secondaryStructureContext, data = _c.data;
                try {
                    for (var _d = __values(data.secondaryStructures), _e = _d.next(); !_e.done; _e = _d.next()) {
                        var secondaryStructure = _e.value;
                        try {
                            for (var secondaryStructure_1 = __values(secondaryStructure), secondaryStructure_1_1 = secondaryStructure_1.next(); !secondaryStructure_1_1.done; secondaryStructure_1_1 = secondaryStructure_1.next()) {
                                var section = secondaryStructure_1_1.value;
                                if (section.contains.apply(section, __spread(e.selectedPoints))) {
                                    secondaryStructureContext.addHoveredSecondaryStructure(section);
                                }
                            }
                        }
                        catch (e_2_1) { e_2 = { error: e_2_1 }; }
                        finally {
                            try {
                                if (secondaryStructure_1_1 && !secondaryStructure_1_1.done && (_b = secondaryStructure_1.return)) _b.call(secondaryStructure_1);
                            }
                            finally { if (e_2) throw e_2.error; }
                        }
                    }
                }
                catch (e_1_1) { e_1 = { error: e_1_1 }; }
                finally {
                    try {
                        if (_e && !_e.done && (_a = _d.return)) _a.call(_d);
                    }
                    finally { if (e_1) throw e_1.error; }
                }
            }
            else {
                cb(e.selectedPoints);
            }
        }; };
        _this.onMouseLeave = function (cb) { return function (e) {
            var e_3, _a, e_4, _b;
            if (e.isAxis()) {
                var _c = _this.props, data = _c.data, secondaryStructureContext = _c.secondaryStructureContext;
                try {
                    for (var _d = __values(data.secondaryStructures), _e = _d.next(); !_e.done; _e = _d.next()) {
                        var secondaryStructure = _e.value;
                        try {
                            for (var secondaryStructure_2 = __values(secondaryStructure), secondaryStructure_2_1 = secondaryStructure_2.next(); !secondaryStructure_2_1.done; secondaryStructure_2_1 = secondaryStructure_2.next()) {
                                var section = secondaryStructure_2_1.value;
                                if (section.contains.apply(section, __spread(e.selectedPoints))) {
                                    secondaryStructureContext.removeHoveredSecondaryStructure(section);
                                }
                            }
                        }
                        catch (e_4_1) { e_4 = { error: e_4_1 }; }
                        finally {
                            try {
                                if (secondaryStructure_2_1 && !secondaryStructure_2_1.done && (_b = secondaryStructure_2.return)) _b.call(secondaryStructure_2);
                            }
                            finally { if (e_4) throw e_4.error; }
                        }
                    }
                }
                catch (e_3_1) { e_3 = { error: e_3_1 }; }
                finally {
                    try {
                        if (_e && !_e.done && (_a = _d.return)) _a.call(_d);
                    }
                    finally { if (e_3) throw e_3.error; }
                }
            }
            else if (cb) {
                cb(e.selectedPoints);
            }
        }; };
        _this.onMouseClick = function (cb) { return function (e) {
            var e_5, _a, e_6, _b;
            if (e.isAxis()) {
                var _c = _this.props, data = _c.data, secondaryStructureContext = _c.secondaryStructureContext;
                try {
                    for (var _d = __values(data.secondaryStructures), _e = _d.next(); !_e.done; _e = _d.next()) {
                        var secondaryStructure = _e.value;
                        try {
                            for (var secondaryStructure_3 = __values(secondaryStructure), secondaryStructure_3_1 = secondaryStructure_3.next(); !secondaryStructure_3_1.done; secondaryStructure_3_1 = secondaryStructure_3.next()) {
                                var section = secondaryStructure_3_1.value;
                                if (section.contains.apply(section, __spread(e.selectedPoints))) {
                                    if (secondaryStructureContext.selectedSecondaryStructures.includes(section)) {
                                        secondaryStructureContext.removeSecondaryStructure(section);
                                    }
                                    else {
                                        secondaryStructureContext.addSelectedSecondaryStructure(section);
                                    }
                                }
                            }
                        }
                        catch (e_6_1) { e_6 = { error: e_6_1 }; }
                        finally {
                            try {
                                if (secondaryStructure_3_1 && !secondaryStructure_3_1.done && (_b = secondaryStructure_3.return)) _b.call(secondaryStructure_3);
                            }
                            finally { if (e_6) throw e_6.error; }
                        }
                    }
                }
                catch (e_5_1) { e_5 = { error: e_5_1 }; }
                finally {
                    try {
                        if (_e && !_e.done && (_a = _d.return)) _a.call(_d);
                    }
                    finally { if (e_5) throw e_5.error; }
                }
            }
            else {
                cb(e.selectedPoints);
            }
        }; };
        _this.onMouseSelect = function (cb) { return function (e) {
            if (cb) {
                // For the contact map, all the x/y values are mirrored and correspond directly with i/j values.
                // Thus, all the residue numbers can be obtained by getting either all x or values from ths selected points.
                cb(e.selectedPoints.map(function (point) { return point; }));
            }
        }; };
        return _this;
    }
    ContactMapClass.prototype.componentDidMount = function () {
        this.setupPointsToPlot(this.props.data.couplingScores);
    };
    ContactMapClass.prototype.componentDidUpdate = function (prevProps) {
        var _a = this.props, data = _a.data, residueContext = _a.residueContext;
        if (data !== prevProps.data || residueContext.lockedResiduePairs !== prevProps.residueContext.lockedResiduePairs) {
            this.setupPointsToPlot(data.couplingScores);
        }
    };
    ContactMapClass.prototype.render = function () {
        var _a = this.props, configurations = _a.configurations, isDataLoading = _a.isDataLoading, residueContext = _a.residueContext, style = _a.style;
        var pointsToPlot = this.state.pointsToPlot;
        return (React.createElement("div", { className: "ContactMapComponent", style: __assign({}, style) },
            React.createElement(semantic_ui_react_1.Dimmer.Dimmable, { dimmed: true },
                React.createElement(semantic_ui_react_1.Dimmer, { active: isDataLoading },
                    React.createElement(semantic_ui_react_1.Loader, null)),
                this.renderContactMapChart(pointsToPlot, __spread([
                    {
                        name: 'Clear Selections',
                        onClick: residueContext.removeAllLockedResiduePairs,
                        type: data_1.CONFIGURATION_COMPONENT_TYPE.BUTTON,
                    }
                ], configurations, this.generateNodeSizeSliderConfigs(pointsToPlot))))));
    };
    ContactMapClass.prototype.setupPointsToPlot = function (couplingContainer) {
        var _a = this.props, formattedPoints = _a.formattedPoints, observedColor = _a.observedColor, highlightColor = _a.highlightColor, residueContext = _a.residueContext;
        var pointsToPlot = this.state.pointsToPlot;
        var chartNames = {
            known: 'Known Structure Contact',
            selected: 'Selected Residue Pairs',
        };
        var knownPointsIndex = pointsToPlot.findIndex(function (entry) { return entry.name === chartNames.known; });
        var selectedPointIndex = pointsToPlot.findIndex(function (entry) { return entry.name === chartNames.selected; });
        var observedContactPoints = couplingContainer.getObservedContacts();
        var result = new (Array.bind.apply(Array, __spread([void 0, component_1.generateChartDataEntry('text', { start: observedColor, end: 'rgb(100,177,200)' }, chartNames.known, '(from PDB structure)', knownPointsIndex >= 0 ? pointsToPlot[knownPointsIndex].nodeSize : 4, observedContactPoints, {
                text: observedContactPoints.map(function (point) {
                    var score = couplingContainer.getCouplingScore(point.i, point.j);
                    return score && score.A_i && score.A_j
                        ? "(" + point.i + score.A_i + ", " + point.j + score.A_j + ")"
                        : "(" + point.i + ", " + point.j + ")";
                }),
            })], formattedPoints)))();
        var lockedResiduePairs = residueContext.lockedResiduePairs, hoveredResidues = residueContext.hoveredResidues;
        var chartPoints = new Array();
        if (hoveredResidues.length >= 1) {
            chartPoints.push({
                i: hoveredResidues[0],
                j: hoveredResidues.length === 1 ? hoveredResidues[0] : hoveredResidues[1],
            });
        }
        if (lockedResiduePairs.size >= 1) {
            chartPoints.push.apply(chartPoints, __spread(Array.from(lockedResiduePairs.keys()).reduce(function (reduceResult, key) {
                var keyPair = lockedResiduePairs.get(key);
                if (keyPair && keyPair.length === 2) {
                    reduceResult.push({ i: keyPair[0], j: keyPair[1], dist: 0 });
                }
                return reduceResult;
            }, new Array())));
        }
        result.push(component_1.generateChartDataEntry('none', highlightColor, chartNames.selected, '', selectedPointIndex >= 0 ? pointsToPlot[selectedPointIndex].nodeSize : 6, chartPoints, {
            marker: {
                color: new Array(chartPoints.length * 2).fill(highlightColor),
                line: {
                    color: highlightColor,
                    width: 3,
                },
                symbol: 'circle-open',
            },
        }));
        this.setState(__assign({}, this.state, { pointsToPlot: __spread(result) }));
    };
    ContactMapClass.prototype.renderContactMapChart = function (pointsToPlot, configurations) {
        var _a = this.props, data = _a.data, height = _a.height, onBoxSelection = _a.onBoxSelection, residueContext = _a.residueContext, showConfigurations = _a.showConfigurations, secondaryStructureContext = _a.secondaryStructureContext, width = _a.width;
        return (React.createElement(component_1.ContactMapChart, { candidateResidues: residueContext.candidateResidues, configurations: configurations, contactData: pointsToPlot, height: height, onClickCallback: this.onMouseClick(residueContext.toggleLockedResiduePair), onHoverCallback: this.onMouseEnter(residueContext.addHoveredResidues), onSelectedCallback: this.onMouseSelect(onBoxSelection), onUnHoverCallback: this.onMouseLeave(residueContext.removeHoveredResidues), range: data.couplingScores.residueIndexRange.max + 20, secondaryStructures: data.pdbData ? data.pdbData.secondaryStructureSections : [], showConfigurations: showConfigurations, selectedSecondaryStructures: [secondaryStructureContext.selectedSecondaryStructures], width: width }));
    };
    ContactMapClass.defaultProps = {
        configurations: new Array(),
        data: {
            couplingScores: new data_1.CouplingContainer(),
            secondaryStructures: new Array(),
        },
        enableSliders: true,
        formattedPoints: new Array(),
        height: '100%',
        highlightColor: '#ff8800',
        isDataLoading: false,
        observedColor: '#0000ff',
        residueContext: __assign({}, context_1.initialResidueContext),
        secondaryStructureContext: __assign({}, context_1.initialSecondaryStructureContext),
        showConfigurations: true,
        width: '100%',
    };
    return ContactMapClass;
}(React.Component));
exports.ContactMapClass = ContactMapClass;
var ContactMap = function (props) { return (React.createElement(context_1.ResidueContextConsumer, null, function (residueContext) { return (React.createElement(context_1.SecondaryStructureContextConsumer, null, function (secondaryStructureContext) { return (React.createElement(ContactMapClass, __assign({ residueContext: residueContext, secondaryStructureContext: secondaryStructureContext }, props))); })); })); };
exports.ContactMap = ContactMap;


/***/ }),

/***/ "./src/component/FeatureViewer.tsx":
/*!*****************************************!*\
  !*** ./src/component/FeatureViewer.tsx ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __values = (this && this.__values) || function (o) {
    var m = typeof Symbol === "function" && o[Symbol.iterator], i = 0;
    if (m) return m.call(o);
    return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spread = (this && this.__spread) || function () {
    for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));
    return ar;
};
Object.defineProperty(exports, "__esModule", { value: true });
var React = __webpack_require__(/*! react */ "./node_modules/react/index.js");
var immutable_1 = __webpack_require__(/*! immutable */ "./node_modules/immutable/dist/immutable.js");
var component_1 = __webpack_require__(/*! ~chell-viz~/component */ "./src/component/index.ts");
var data_1 = __webpack_require__(/*! ~chell-viz~/data */ "./src/data/index.ts");
var FeatureViewer = /** @class */ (function (_super) {
    __extends(FeatureViewer, _super);
    function FeatureViewer(props) {
        var _this = _super.call(this, props) || this;
        _this.onFeatureHover = function (event) {
            var e_1, _a;
            var _b = _this.props, data = _b.data, getTextForHover = _b.getTextForHover;
            var hoveredFeatureIndex = -1;
            // TODO Handle vertical viewer, better selection logic.
            var xCoords = [event.selectedPoints[0], event.selectedPoints[2]];
            for (var i = 0; i < data.length; ++i) {
                try {
                    for (var xCoords_1 = __values(xCoords), xCoords_1_1 = xCoords_1.next(); !xCoords_1_1.done; xCoords_1_1 = xCoords_1.next()) {
                        var xCoord = xCoords_1_1.value;
                        if (data[i].contains(xCoord)) {
                            hoveredFeatureIndex = i;
                        }
                    }
                }
                catch (e_1_1) { e_1 = { error: e_1_1 }; }
                finally {
                    try {
                        if (xCoords_1_1 && !xCoords_1_1.done && (_a = xCoords_1.return)) _a.call(xCoords_1);
                    }
                    finally { if (e_1) throw e_1.error; }
                }
            }
            _this.setState({
                hoverAnnotationText: getTextForHover && hoveredFeatureIndex >= 0
                    ? getTextForHover(data[hoveredFeatureIndex].label, hoveredFeatureIndex)
                    : '',
                hoveredFeatureIndex: hoveredFeatureIndex,
            });
        };
        _this.onFeatureClick = function (event) {
            var _a = _this.props, data = _a.data, onClickCallback = _a.onClickCallback;
            var selectedFeatureIndices = _this.deriveFeatureIndices(data, event.selectedPoints);
            if (onClickCallback) {
                onClickCallback(_this.deriveSelectedFeatures(data, selectedFeatureIndices.toArray()));
            }
            _this.setState({
                selectedFeatureIndices: selectedFeatureIndices,
                selectedRange: new data_1.Chell1DSection('selection', -1, -1),
            });
        };
        _this.onFeatureSelect = function (event) {
            var _a = _this.props, data = _a.data, onSelectCallback = _a.onSelectCallback;
            var selectedFeatureIndices = _this.deriveFeatureIndices(data, event.selectedPoints);
            var plotlyEvent = event.plotlyEvent;
            var selectedRange = _this.state.selectedRange;
            if (plotlyEvent.range) {
                selectedRange = new data_1.Chell1DSection('selection', Math.floor(plotlyEvent.range.x[0]), Math.ceil(plotlyEvent.range.x[1]));
                var selection = {
                    end: selectedRange.end,
                    featuresSelected: _this.deriveSelectedFeatures(data, selectedFeatureIndices.toArray()),
                    length: selectedRange.length,
                    start: selectedRange.start,
                };
                if (onSelectCallback) {
                    onSelectCallback(selection);
                }
            }
            _this.setState({
                selectedFeatureIndices: selectedFeatureIndices,
                selectedRange: selectedRange,
            });
        };
        /**
         * Derive the indices of the Features from the points the user selected.
         */
        _this.deriveFeatureIndices = function (data, userSelectedPoints) {
            var featureIndices = immutable_1.Set();
            var _loop_1 = function (i) {
                var xCoord = userSelectedPoints[i];
                data
                    .reduce(function (result, datum, index) { return (datum.contains(xCoord) ? __spread(result, [index]) : result); }, new Array())
                    .forEach(function (indexToAdd) {
                    featureIndices = featureIndices.add(indexToAdd);
                });
            };
            // Points come to us as [x0, y0, x1, y1, ..., xn, yn], so we skip every other point.
            for (var i = 0; i < userSelectedPoints.length; i += 2) {
                _loop_1(i);
            }
            return featureIndices;
        };
        /**
         * Shorthand to get the raw section data for a set of Features given some indices.
         */
        _this.deriveSelectedFeatures = function (data, selectedFeatureIndices) {
            return selectedFeatureIndices.map(function (index) { return new data_1.Chell1DSection(data[index].label, data[index].start, data[index].end); });
        };
        _this.state = {
            hoverAnnotationText: '',
            hoveredFeatureIndex: -1,
            plotlyConfig: {
                showAxisDragHandles: false,
                showAxisRangeEntryBoxes: false,
            },
            plotlyData: [],
            plotlyLayout: {},
            selectedFeatureIndices: immutable_1.Set(),
            selectedRange: new data_1.Chell1DSection('selection', -1, -1),
        };
        return _this;
    }
    FeatureViewer.getDerivedStateFromProps = function (nextProps, nextState) {
        var data = nextProps.data, height = nextProps.height, maxLength = nextProps.maxLength, showGrouped = nextProps.showGrouped, title = nextProps.title, width = nextProps.width;
        var hoverAnnotationText = nextState.hoverAnnotationText, hoveredFeatureIndex = nextState.hoveredFeatureIndex, selectedRange = nextState.selectedRange;
        var plotlyData = data.map(function (datum, index) {
            var yIndex = showGrouped
                ? index
                : data.findIndex(function (candidateDatum) { return datum.label.localeCompare(candidateDatum.label) === 0; });
            return FeatureViewer.getPlotlyDataObject(datum, showGrouped, yIndex);
        });
        plotlyData.push({
            hoverinfo: 'none',
            line: {
                color: 'orange',
                width: 10,
            },
            mode: 'lines',
            showlegend: false,
            x: [selectedRange.start, selectedRange.end],
            y: [-0.25, -0.25],
        });
        var hoveredDatum = plotlyData[hoveredFeatureIndex];
        return {
            plotlyData: plotlyData,
            plotlyLayout: {
                annotations: hoveredFeatureIndex >= 0 && hoveredDatum.x && hoveredDatum.y
                    ? [
                        {
                            align: 'left',
                            arrowhead: 0,
                            arrowsize: 1,
                            arrowwidth: 1,
                            ax: 0,
                            ay: -25,
                            bgcolor: '#ffffff',
                            bordercolor: '#000000',
                            borderpad: 5,
                            showarrow: true,
                            text: hoverAnnotationText,
                            x: hoveredDatum.x[0],
                            xref: 'x',
                            y: hoveredDatum.y[hoveredDatum.y.length - 3],
                            yref: 'y',
                        },
                    ]
                    : [],
                dragmode: 'select',
                height: height,
                hovermode: 'closest',
                margin: {
                    b: 30,
                    t: 60,
                },
                showlegend: false,
                title: title,
                width: width,
                xaxis: data.length > 0
                    ? {
                        autorange: false,
                        fixedrange: true,
                        range: [0, maxLength ? maxLength : data.reduce(function (prev, cur) { return Math.max(prev, cur.end); }, -1) + 200],
                        showgrid: false,
                        tick0: 0,
                        tickmode: 'auto',
                        ticks: 'outside',
                    }
                    : { visible: false },
                yaxis: {
                    autorange: false,
                    fixedrange: true,
                    range: [-0.25, showGrouped ? 2 : data.length],
                    visible: false,
                },
            },
        };
    };
    FeatureViewer.getBoxForChellSection = function (datum) {
        return [
            datum.end - (datum.end - datum.start) / 2,
            null,
            datum.start,
            datum.start,
            datum.end,
            datum.end,
            datum.start,
        ];
    };
    FeatureViewer.prototype.render = function () {
        var _a = this.props, width = _a.width, height = _a.height;
        var _b = this.state, plotlyConfig = _b.plotlyConfig, plotlyData = _b.plotlyData, plotlyLayout = _b.plotlyLayout;
        return (React.createElement("div", { style: { height: height, width: width } },
            React.createElement(component_1.PlotlyChart, { config: plotlyConfig, data: plotlyData, layout: plotlyLayout, onClickCallback: this.onFeatureClick, onHoverCallback: this.onFeatureHover, onSelectedCallback: this.onFeatureSelect, showLoader: false })));
    };
    FeatureViewer.defaultProps = {
        data: [],
        height: 200,
        showGrouped: false,
        title: '',
        width: 600,
    };
    FeatureViewer.getPlotlyDataObject = function (datum, showGrouped, yIndex) { return ({
        fill: 'toself',
        fillcolor: datum.color.toString(),
        hoverinfo: 'none',
        hoveron: 'fills',
        line: {
            width: 0,
        },
        mode: 'text+lines',
        name: "" + datum.label,
        text: [datum.label],
        textfont: { color: ['#FFFFFF'] },
        type: 'scatter',
        // Creates a 'box' so we can fill it and hover over it and add a point to the middle for the label.
        x: FeatureViewer.getBoxForChellSection(datum),
        y: showGrouped
            ? [0.5, null, 0, 1, 1, 0, 0]
            : [yIndex + 0.5, null, yIndex + 1, yIndex, yIndex, yIndex + 1, yIndex + 1],
    }); };
    return FeatureViewer;
}(React.Component));
exports.FeatureViewer = FeatureViewer;


/***/ }),

/***/ "./src/component/InfoPanel.tsx":
/*!*************************************!*\
  !*** ./src/component/InfoPanel.tsx ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __values = (this && this.__values) || function (o) {
    var m = typeof Symbol === "function" && o[Symbol.iterator], i = 0;
    if (m) return m.call(o);
    return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
};
Object.defineProperty(exports, "__esModule", { value: true });
var React = __webpack_require__(/*! react */ "./node_modules/react/index.js");
var semantic_ui_react_1 = __webpack_require__(/*! semantic-ui-react */ "./node_modules/semantic-ui-react/dist/es/index.js");
var context_1 = __webpack_require__(/*! ~chell-viz~/context */ "./src/context/index.ts");
var data_1 = __webpack_require__(/*! ~chell-viz~/data */ "./src/data/index.ts");
var InfoPanelClass = /** @class */ (function (_super) {
    __extends(InfoPanelClass, _super);
    function InfoPanelClass(props) {
        return _super.call(this, props) || this;
    }
    InfoPanelClass.prototype.render = function () {
        var _this = this;
        var _a = this.props, data = _a.data, height = _a.height, residueContext = _a.residueContext, width = _a.width, secondaryStructureContext = _a.secondaryStructureContext;
        var unassignedResidues = data.pdbData
            ? this.renderUnassignedResidues(data.pdbData)
            : [React.createElement(semantic_ui_react_1.Label, { key: 'unassigned-residues-none' })];
        return (React.createElement("div", { className: "InfoPanel", style: { height: height, width: width } },
            React.createElement(semantic_ui_react_1.Accordion, { exclusive: false, panels: [
                    data.pdbData &&
                        data.pdbData.secondaryStructureSections.map(function (secondaryStructure) { return ({
                            content: _this.renderSecondaryStructures(secondaryStructure),
                            key: 'all-secondary-structures',
                            title: "All Secondary Structures (" + (data.pdbData ? data.pdbData.secondaryStructureSections.length : 0) + "):",
                        }); }),
                    {
                        content: unassignedResidues,
                        key: 'unassigned-residues',
                        title: "Unassigned Residues (" + unassignedResidues.length + "):",
                    },
                    {
                        content: this.renderSecondaryStructures(secondaryStructureContext.selectedSecondaryStructures),
                        key: 'selected-secondary-structures',
                        title: "Selected Secondary Structures (" + secondaryStructureContext.selectedSecondaryStructures.length + "):",
                    },
                    {
                        content: this.renderLockedResiduePairs(residueContext.lockedResiduePairs),
                        key: 'selected-residue-pairs',
                        title: "Selected Residue Pairs (" + residueContext.lockedResiduePairs.size + "):",
                    },
                ] })));
    };
    InfoPanelClass.prototype.renderLockedResiduePairs = function (lockedResiduePairs) {
        return lockedResiduePairs.size === 0
            ? [React.createElement(semantic_ui_react_1.Label, { key: 'locked-residue-pair-none' }, "None")]
            : Array.from(lockedResiduePairs.values()).map(function (pair, index) { return (React.createElement(semantic_ui_react_1.Label, { key: "locked-residue-pair-" + index }, pair.join(', '))); });
    };
    InfoPanelClass.prototype.renderSecondaryStructures = function (selectedSecondaryStructures) {
        return selectedSecondaryStructures.length === 0
            ? [React.createElement(semantic_ui_react_1.Label, { key: 'sec-struct-none' }, "None")]
            : selectedSecondaryStructures.map(function (section, index) { return (React.createElement(semantic_ui_react_1.Label, { key: "sec-struct-" + index }, "[" + section.start + "-" + section.end + "]: " + section.label + " - " + data_1.SECONDARY_STRUCTURE_CODES[section.label])); });
    };
    InfoPanelClass.prototype.renderUnassignedResidues = function (pdbData) {
        var result = new Array();
        pdbData.eachResidue(function (residue) {
            var e_1, _a, e_2, _b;
            if (residue.isProtein()) {
                var isUnassigned = true;
                try {
                    for (var _c = __values(pdbData.secondaryStructureSections), _d = _c.next(); !_d.done; _d = _c.next()) {
                        var secondaryStructure = _d.value;
                        try {
                            for (var secondaryStructure_1 = __values(secondaryStructure), secondaryStructure_1_1 = secondaryStructure_1.next(); !secondaryStructure_1_1.done; secondaryStructure_1_1 = secondaryStructure_1.next()) {
                                var section = secondaryStructure_1_1.value;
                                if (section.contains(residue.resno)) {
                                    isUnassigned = false;
                                    break;
                                }
                            }
                        }
                        catch (e_2_1) { e_2 = { error: e_2_1 }; }
                        finally {
                            try {
                                if (secondaryStructure_1_1 && !secondaryStructure_1_1.done && (_b = secondaryStructure_1.return)) _b.call(secondaryStructure_1);
                            }
                            finally { if (e_2) throw e_2.error; }
                        }
                    }
                }
                catch (e_1_1) { e_1 = { error: e_1_1 }; }
                finally {
                    try {
                        if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
                    }
                    finally { if (e_1) throw e_1.error; }
                }
                if (isUnassigned) {
                    result.push(React.createElement(semantic_ui_react_1.Label, { key: "unassigned-residue-" + residue.resno }, "[" + residue.resno + ": isCg? " + residue.isCg() + ",               isDna? " + residue.isDna() + ",               isHelix? " + residue.isHelix() + ",               isNucleic? " + residue.isNucleic() + ",               isProtein? " + residue.isProtein() + ",               isPolymer? " + residue.isPolymer() + ",               isSaccharide? " + residue.isSaccharide() + ",               isSheet? " + residue.isSheet() + ",              isTurn? " + residue.isTurn(),
                        "}"));
                }
            }
        });
        return result;
    };
    InfoPanelClass.defaultProps = {
        data: {
            couplingScores: new data_1.CouplingContainer(),
            secondaryStructures: new Array(),
        },
        height: 400,
        residueContext: __assign({}, context_1.initialResidueContext),
        secondaryStructureContext: __assign({}, context_1.initialSecondaryStructureContext),
        width: 400,
    };
    return InfoPanelClass;
}(React.Component));
exports.InfoPanelClass = InfoPanelClass;
var InfoPanel = function (props) { return (React.createElement(context_1.SecondaryStructureContext.Consumer, null, function (secStructContext) { return (React.createElement(context_1.ResidueContext.Consumer, null, function (residueContext) { return React.createElement(InfoPanel, __assign({}, props, residueContext, secStructContext)); })); })); };
exports.InfoPanel = InfoPanel;


/***/ }),

/***/ "./src/component/NGLComponent.tsx":
/*!****************************************!*\
  !*** ./src/component/NGLComponent.tsx ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spread = (this && this.__spread) || function () {
    for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));
    return ar;
};
var __values = (this && this.__values) || function (o) {
    var m = typeof Symbol === "function" && o[Symbol.iterator], i = 0;
    if (m) return m.call(o);
    return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
};
Object.defineProperty(exports, "__esModule", { value: true });
var lodash_1 = __webpack_require__(/*! lodash */ "./node_modules/lodash/lodash.js");
var NGL = __webpack_require__(/*! ngl */ "./node_modules/ngl/dist/ngl.esm.js");
var React = __webpack_require__(/*! react */ "./node_modules/react/index.js");
var semantic_ui_react_1 = __webpack_require__(/*! semantic-ui-react */ "./node_modules/semantic-ui-react/dist/es/index.js");
var component_1 = __webpack_require__(/*! ~chell-viz~/component */ "./src/component/index.ts");
var context_1 = __webpack_require__(/*! ~chell-viz~/context */ "./src/context/index.ts");
var data_1 = __webpack_require__(/*! ~chell-viz~/data */ "./src/data/index.ts");
var helper_1 = __webpack_require__(/*! ~chell-viz~/helper */ "./src/helper/index.ts");
exports.initialNGLState = {
    activeRepresentations: new Array(),
    pdbData: undefined,
    stage: undefined,
    structureComponent: undefined,
};
var NGLComponentClass = /** @class */ (function (_super) {
    __extends(NGLComponentClass, _super);
    function NGLComponentClass(props) {
        var _this = _super.call(this, props) || this;
        _this.state = exports.initialNGLState;
        _this.canvas = null;
        _this.getConfigurations = function () {
            var residueContext = _this.props.residueContext;
            return [
                {
                    name: 'Clear Selections',
                    onClick: residueContext.removeAllLockedResiduePairs,
                    type: data_1.CONFIGURATION_COMPONENT_TYPE.BUTTON,
                },
                {
                    current: data_1.CONTACT_DISTANCE_PROXIMITY.CLOSEST,
                    name: 'Measuring Proximity',
                    onChange: _this.measuredProximityHandler,
                    options: Object.values(data_1.CONTACT_DISTANCE_PROXIMITY).map(helper_1.capitalizeFirstLetter),
                    type: data_1.CONFIGURATION_COMPONENT_TYPE.RADIO,
                },
                {
                    current: 'default',
                    name: 'Structure Representation Type',
                    onChange: function (value) {
                        var _a = _this.state, stage = _a.stage, structureComponent = _a.structureComponent;
                        var reps = ['default', 'spacefill', 'backbone', 'cartoon', 'surface', 'tube'];
                        if (stage && structureComponent) {
                            structureComponent.removeAllRepresentations();
                            if (value === 0) {
                                stage.defaultFileRepresentation(structureComponent);
                            }
                            else {
                                structureComponent.addRepresentation(reps[value]);
                            }
                            _this.setState({
                                activeRepresentations: _this.deriveActiveRepresentations(structureComponent, _this.state.pdbData),
                            });
                            stage.viewer.requestRender();
                        }
                    },
                    options: Object.values(['Default', 'Spacefill', 'Backbone', 'Cartoon', 'Surface', 'Tube']),
                    type: data_1.CONFIGURATION_COMPONENT_TYPE.RADIO,
                },
            ];
        };
        _this.onClick = function (pickingProxy) {
            var residueContext = _this.props.residueContext;
            var structureComponent = _this.state.structureComponent;
            if (_this.canvas && structureComponent) {
                if (pickingProxy) {
                    var isDistancePicker = pickingProxy.picker && pickingProxy.picker.type === 'distance';
                    if (isDistancePicker) {
                        var residues = [pickingProxy.distance.atom1.resno, pickingProxy.distance.atom2.resno];
                        residueContext.removeLockedResiduePair(residues);
                    }
                    else if (pickingProxy.atom || pickingProxy.closestBondAtom) {
                        var atom = pickingProxy.atom || pickingProxy.closestBondAtom;
                        if (residueContext.candidateResidues.length >= 1) {
                            residueContext.addLockedResiduePair(__spread(residueContext.candidateResidues, [atom.resno]));
                            residueContext.removeCandidateResidues();
                        }
                        else {
                            residueContext.addCandidateResidues([atom.resno]);
                        }
                    }
                }
                else if (residueContext.candidateResidues.length >= 1 && residueContext.hoveredResidues.length >= 1) {
                    residueContext.hoveredResidues.forEach(function (residueIndex) {
                        var getMinDist = function (residueStore, target) {
                            var minDist = Number.MAX_SAFE_INTEGER;
                            var atomOffset = residueStore.atomOffset[residueIndex];
                            var atomCount = residueStore.atomCount[residueIndex];
                            for (var i = 0; i < atomCount; ++i) {
                                var atomProxy = structureComponent.structure.getAtomProxy(atomOffset + i);
                                var atomPosition = structureComponent.stage.viewerControls.getPositionOnCanvas(atomProxy.positionToVector3());
                                minDist = Math.min(minDist, target.distanceTo(atomPosition));
                            }
                            return minDist;
                        };
                        // ! IMPORTANT !
                        // This is a rather brute force approach to see if the mouse is close to a residue.
                        // The main problem is __reliably__ getting the (x,y) of where the user clicked and the "residue" they were closest to.
                        var _a = structureComponent.stage.mouseObserver, down = _a.down, canvasPosition = _a.canvasPosition, position = _a.position, prevClickCP = _a.prevClickCP, prevPosition = _a.prevPosition;
                        var minDistances = [down, canvasPosition, prevClickCP, prevPosition, position].map(function (pos) {
                            return getMinDist(structureComponent.structure.residueStore, pos);
                        });
                        // Shorthand to make it clearer that this method is just checking if any distance is within 100.
                        var isWithinSnappingDistance = function (distances, limit) {
                            if (limit === void 0) { limit = 100; }
                            return distances.filter(function (dist) { return dist < limit; }).length >= 1;
                        };
                        if (isWithinSnappingDistance(minDistances)) {
                            residueContext.addLockedResiduePair(__spread(residueContext.candidateResidues, [residueIndex]));
                            residueContext.removeCandidateResidues();
                        }
                        else {
                            residueContext.removeNonLockedResidues();
                        }
                    });
                }
                else {
                    // User clicked off-structure, so clear non-locked residue state.
                    residueContext.removeNonLockedResidues();
                }
            }
        };
        _this.measuredProximityHandler = function (value) {
            var onMeasuredProximityChange = _this.props.onMeasuredProximityChange;
            if (onMeasuredProximityChange) {
                onMeasuredProximityChange(value);
            }
        };
        _this.onCanvasLeave = function () {
            var residueContext = _this.props.residueContext;
            residueContext.removeNonLockedResidues();
        };
        _this.onResizeHandler = function (event) {
            var onResize = _this.props.onResize;
            var stage = _this.state.stage;
            if (stage) {
                stage.handleResize();
            }
            if (onResize) {
                onResize(event);
            }
        };
        _this.onKeyDown = function (e) {
            e.preventDefault();
            var ESC_KEY_CODE = 27;
            if (e.which === ESC_KEY_CODE || e.keyCode === ESC_KEY_CODE) {
                var residueContext = _this.props.residueContext;
                residueContext.removeNonLockedResidues();
            }
        };
        _this.generateStage = function (canvas, params) {
            var stage = new NGL.Stage(canvas, params);
            // !IMPORTANT! This is needed to prevent the canvas shifting when the user clicks the canvas.
            // It's unclear why the focus does this, but it's undesirable.
            stage.keyBehavior.domElement.focus = function () {
                return;
            };
            return stage;
        };
        return _this;
    }
    NGLComponentClass.prototype.componentDidMount = function (_a) {
        var backgroundColor = (_a === void 0 ? this.props : _a).backgroundColor;
        if (this.canvas) {
            var stage = this.generateStage(this.canvas, { backgroundColor: backgroundColor });
            var data = this.props.data;
            this.initData(stage, data);
            this.setState({
                stage: stage,
            });
        }
        window.addEventListener('resize', this.onResizeHandler, false);
    };
    NGLComponentClass.prototype.componentWillUnmount = function () {
        var stage = this.state.stage;
        if (stage) {
            stage.viewer.renderer.forceContextLoss();
            stage.dispose();
            this.setState({
                activeRepresentations: [],
                stage: undefined,
            });
        }
        window.removeEventListener('resize', this.onResizeHandler);
    };
    NGLComponentClass.prototype.componentDidUpdate = function (prevProps, prevState) {
        var e_1, _a;
        var _b = this.props, data = _b.data, measuredProximity = _b.measuredProximity;
        var _c = this.state, stage = _c.stage, structureComponent = _c.structureComponent;
        if (stage && data !== prevProps.data) {
            this.initData(stage, data);
        }
        if (stage && data && structureComponent) {
            var _d = this.props, residueContext = _d.residueContext, secondaryStructureContext = _d.secondaryStructureContext;
            var isHighlightUpdateNeeded = residueContext !== prevProps.residueContext ||
                secondaryStructureContext !== prevProps.secondaryStructureContext ||
                measuredProximity !== prevProps.measuredProximity;
            if (isHighlightUpdateNeeded) {
                try {
                    for (var _e = __values(this.state.activeRepresentations), _f = _e.next(); !_f.done; _f = _e.next()) {
                        var rep = _f.value;
                        structureComponent.removeRepresentation(rep);
                    }
                }
                catch (e_1_1) { e_1 = { error: e_1_1 }; }
                finally {
                    try {
                        if (_f && !_f.done && (_a = _e.return)) _a.call(_e);
                    }
                    finally { if (e_1) throw e_1.error; }
                }
                this.setState({
                    activeRepresentations: this.deriveActiveRepresentations(structureComponent, this.state.pdbData),
                });
            }
            stage.viewer.requestRender();
        }
    };
    /**
     * Renders the NGL canvas.
     *
     * Because we are working with WebGL via the canvas, updating this visualization happens through the canvas reference.
     *
     * @returns The NGL Component
     */
    NGLComponentClass.prototype.render = function () {
        var _this = this;
        var _a = this.props, height = _a.height, isDataLoading = _a.isDataLoading, showConfigurations = _a.showConfigurations, style = _a.style, width = _a.width;
        return (React.createElement(semantic_ui_react_1.Dimmer.Dimmable, { dimmed: true },
            React.createElement(semantic_ui_react_1.Dimmer, { active: isDataLoading },
                React.createElement(semantic_ui_react_1.Loader, null)),
            React.createElement(component_1.SettingsPanel, { configurations: this.getConfigurations(), showConfigurations: showConfigurations },
                React.createElement("div", { className: "NGLComponent", style: __assign({}, style, { height: height, width: width }) },
                    React.createElement("div", { className: "NGLCanvas", onKeyDown: this.onKeyDown, onMouseLeave: this.onCanvasLeave, ref: function (el) { return (_this.canvas = el); }, role: 'img', style: { height: '100%', width: '100%' } })))));
    };
    NGLComponentClass.prototype.initData = function (stage, structure) {
        stage.removeAllComponents();
        if (structure) {
            // !IMPORTANT! We need to deeply clone the NGL data!
            // If we have multiple NGL components displaying the same data, removing the component will affect
            // the others because they (internally) delete keys/references.
            this.addStructureToStage(lodash_1.cloneDeep(structure), stage);
        }
        else {
            this.setState({
                pdbData: undefined,
                structureComponent: undefined,
            });
        }
    };
    NGLComponentClass.prototype.deriveActiveRepresentations = function (structureComponent, pdbData) {
        var _a = this.props, residueContext = _a.residueContext, secondaryStructureContext = _a.secondaryStructureContext;
        return __spread(this.highlightCandidateResidues(structureComponent, __spread(residueContext.candidateResidues, residueContext.hoveredResidues).filter(function (value, index, array) { return array.indexOf(value) === index; })
            .sort(), pdbData), this.highlightLockedDistancePairs(structureComponent, residueContext.lockedResiduePairs, pdbData), this.highlightSecondaryStructures(structureComponent, __spread(secondaryStructureContext.hoveredSecondaryStructures, secondaryStructureContext.selectedSecondaryStructures)));
    };
    /**
     * Adds a NGL structure to the stage.
     *
     * @param structure A NGL Structure.
     * @param stage A NGL Stage.
     */
    NGLComponentClass.prototype.addStructureToStage = function (structure, stage) {
        var _this = this;
        var structureComponent = stage.addComponentFromObject(structure);
        structureComponent.stage.mouseControls.add("hoverPick" /* HOVER_PICK */, function (aStage, pickingProxy) {
            _this.onHover(aStage, pickingProxy);
        });
        stage.defaultFileRepresentation(structureComponent);
        stage.signals.clicked.add(this.onClick);
        var pdbData = data_1.ChellPDB.createPDBFromNGLData(structure);
        var activeRepresentations = this.deriveActiveRepresentations(structureComponent, pdbData);
        this.setState({
            activeRepresentations: activeRepresentations,
            pdbData: pdbData,
            structureComponent: structureComponent,
        });
        stage.viewer.requestRender();
    };
    NGLComponentClass.prototype.onHover = function (aStage, pickingProxy) {
        var residueContext = this.props.residueContext;
        var _a = this.state, structureComponent = _a.structureComponent, stage = _a.stage;
        if (stage && structureComponent) {
            if (pickingProxy && (pickingProxy.atom || pickingProxy.closestBondAtom)) {
                var atom = pickingProxy.atom || pickingProxy.closestBondAtom;
                var resname = data_1.AMINO_ACIDS_BY_THREE_LETTER_CODE[atom.resname]
                    ? data_1.AMINO_ACIDS_BY_THREE_LETTER_CODE[atom.resname].singleLetterCode
                    : atom.resname;
                stage.tooltip.textContent = "" + atom.resno + resname;
                residueContext.addHoveredResidues([atom.resno]);
            }
            else if (residueContext.candidateResidues.length === 0 && residueContext.hoveredResidues.length !== 0) {
                residueContext.removeHoveredResidues();
            }
        }
    };
    NGLComponentClass.prototype.getDistanceRepForResidues = function (structureComponent, residues, pdbData) {
        var measuredProximity = this.props.measuredProximity;
        if (measuredProximity === data_1.CONTACT_DISTANCE_PROXIMITY.C_ALPHA) {
            return helper_1.createDistanceRepresentation(structureComponent, residues.join('.CA, ') + ".CA");
        }
        else {
            var _a = pdbData.getMinDistBetweenResidues(residues[0], residues[1]), atomIndexI = _a.atomIndexI, atomIndexJ = _a.atomIndexJ;
            return helper_1.createDistanceRepresentation(structureComponent, [atomIndexI, atomIndexJ]);
        }
    };
    NGLComponentClass.prototype.highlightCandidateResidues = function (structureComponent, residues, pdbData) {
        var reps = new Array();
        if (residues.length >= 1) {
            reps.push(helper_1.createBallStickRepresentation(structureComponent, residues));
            if (residues.length >= 2 && pdbData) {
                reps.push(this.getDistanceRepForResidues(structureComponent, residues, pdbData));
            }
        }
        return reps;
    };
    NGLComponentClass.prototype.highlightLockedDistancePairs = function (structureComponent, lockedResidues, pdbData) {
        var _this = this;
        var reps = new Array();
        lockedResidues.forEach(function (residues) {
            reps.push(helper_1.createBallStickRepresentation(structureComponent, residues));
            if (residues.length >= 2 && pdbData) {
                reps.push(_this.getDistanceRepForResidues(structureComponent, residues, pdbData));
            }
        });
        return reps;
    };
    NGLComponentClass.prototype.highlightSecondaryStructures = function (structureComponent, secondaryStructures) {
        var e_2, _a;
        var reps = new Array();
        try {
            for (var secondaryStructures_1 = __values(secondaryStructures), secondaryStructures_1_1 = secondaryStructures_1.next(); !secondaryStructures_1_1.done; secondaryStructures_1_1 = secondaryStructures_1.next()) {
                var structure = secondaryStructures_1_1.value;
                reps.push(helper_1.createSecStructRepresentation(structureComponent, structure));
            }
        }
        catch (e_2_1) { e_2 = { error: e_2_1 }; }
        finally {
            try {
                if (secondaryStructures_1_1 && !secondaryStructures_1_1.done && (_a = secondaryStructures_1.return)) _a.call(secondaryStructures_1);
            }
            finally { if (e_2) throw e_2.error; }
        }
        return reps;
    };
    NGLComponentClass.defaultProps = {
        backgroundColor: '#ffffff',
        couplingContext: __assign({}, context_1.initialCouplingContext),
        data: undefined,
        height: '100%',
        isDataLoading: false,
        measuredProximity: data_1.CONTACT_DISTANCE_PROXIMITY.C_ALPHA,
        residueContext: __assign({}, context_1.initialResidueContext),
        secondaryStructureContext: __assign({}, context_1.initialSecondaryStructureContext),
        showConfigurations: true,
        width: '100%',
    };
    return NGLComponentClass;
}(React.Component));
exports.NGLComponentClass = NGLComponentClass;
var NGLComponent = function (props) { return (React.createElement(context_1.ResidueContextConsumer, null, function (residueContext) { return (React.createElement(context_1.SecondaryStructureContextConsumer, null, function (secondaryStructureContext) { return (React.createElement(NGLComponentClass, __assign({ residueContext: residueContext, secondaryStructureContext: secondaryStructureContext }, props))); })); })); };
exports.NGLComponent = NGLComponent;


/***/ }),

/***/ "./src/component/PredictedContactMap.tsx":
/*!***********************************************!*\
  !*** ./src/component/PredictedContactMap.tsx ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)
            t[p[i]] = s[p[i]];
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
var React = __webpack_require__(/*! react */ "./node_modules/react/index.js");
var component_1 = __webpack_require__(/*! ~chell-viz~/component */ "./src/component/index.ts");
var data_1 = __webpack_require__(/*! ~chell-viz~/data */ "./src/data/index.ts");
exports.initialPredictedContactMapState = {
    linearDistFilter: 5,
    numPredictionsToShow: -1,
    pointsToPlot: [],
};
var PredictedContactMap = /** @class */ (function (_super) {
    __extends(PredictedContactMap, _super);
    function PredictedContactMap(props) {
        var _this = _super.call(this, props) || this;
        _this.state = exports.initialPredictedContactMapState;
        _this.onLinearDistFilterChange = function () { return function (value) {
            _this.setState({
                linearDistFilter: value,
            });
        }; };
        _this.onNumPredictionsToShowChange = function () { return function (value) {
            _this.setState({
                numPredictionsToShow: value,
            });
        }; };
        _this.getContactMapConfigs = function () { return [
            {
                name: 'Linear Distance Filter (|i - j|)',
                onChange: _this.onLinearDistFilterChange(),
                type: data_1.CONFIGURATION_COMPONENT_TYPE.SLIDER,
                values: {
                    current: _this.state.linearDistFilter,
                    max: 10,
                    min: 1,
                },
            },
            {
                name: 'Top N Predictions to Show',
                onChange: _this.onNumPredictionsToShowChange(),
                type: data_1.CONFIGURATION_COMPONENT_TYPE.SLIDER,
                values: {
                    current: _this.state.numPredictionsToShow,
                    max: _this.props.data.couplingScores.chainLength,
                    min: 1,
                },
            },
        ]; };
        return _this;
    }
    PredictedContactMap.prototype.componentDidMount = function () {
        this.setupData(true);
    };
    PredictedContactMap.prototype.componentDidUpdate = function (prevProps, prevState) {
        var data = this.props.data;
        var _a = this.state, linearDistFilter = _a.linearDistFilter, numPredictionsToShow = _a.numPredictionsToShow;
        var isRecomputeNeeded = data.couplingScores !== prevProps.data.couplingScores ||
            linearDistFilter !== prevState.linearDistFilter ||
            numPredictionsToShow !== prevState.numPredictionsToShow;
        if (isRecomputeNeeded) {
            this.setupData(data.couplingScores !== prevProps.data.couplingScores);
        }
    };
    PredictedContactMap.prototype.render = function () {
        var _a = this.props, data = _a.data, style = _a.style, passThroughProps = __rest(_a, ["data", "style"]);
        var pointsToPlot = this.state.pointsToPlot;
        return (React.createElement("div", { className: "PredictedContactMapComponent", style: style },
            React.createElement(component_1.ContactMap, __assign({ configurations: this.getContactMapConfigs(), data: {
                    couplingScores: data.couplingScores,
                    pdbData: data.pdbData,
                    secondaryStructures: data.pdbData ? data.pdbData.secondaryStructureSections : [],
                }, formattedPoints: pointsToPlot }, passThroughProps))));
    };
    /**
     * Setups up the prediction values for the data.
     *
     * @param isNewData Is this an entirely new dataset?
     */
    PredictedContactMap.prototype.setupData = function (isNewData) {
        var _a = this.props, correctColor = _a.correctColor, data = _a.data, incorrectColor = _a.incorrectColor;
        var _b = this.state, linearDistFilter = _b.linearDistFilter, numPredictionsToShow = _b.numPredictionsToShow;
        var couplingScores = data.pdbData
            ? data.pdbData.contactInformation
            : new data_1.CouplingContainer(data.couplingScores.rankedContacts);
        var chainLength = couplingScores.chainLength;
        var allPredictions = couplingScores.getPredictedContacts(numPredictionsToShow, linearDistFilter);
        var correctPredictionPercent = ((allPredictions.correct.length / allPredictions.predicted.length) * 100).toFixed(1);
        var newPoints = [
            component_1.generateChartDataEntry('text', incorrectColor, 'Predicted Contact', "(N=" + numPredictionsToShow + ", L=" + chainLength + ")", 4, allPredictions.predicted, {
                text: allPredictions.predicted.map(function (point) {
                    var score = data.couplingScores.getCouplingScore(point.i, point.j);
                    return score && score.A_i && score.A_j
                        ? "(" + point.i + score.A_i + ", " + point.j + score.A_j + ")"
                        : "(" + point.i + ", " + point.j + ")";
                }),
            }),
            component_1.generateChartDataEntry('text', correctColor, 'Correct Prediction', "(N=" + allPredictions.correct.length + ", " + correctPredictionPercent + "%)", 6, allPredictions.correct, {
                text: allPredictions.correct.map(function (point) {
                    var score = data.couplingScores.getCouplingScore(point.i, point.j);
                    return score && score.A_i && score.A_j
                        ? "(" + point.i + score.A_i + ", " + point.j + score.A_j + ")"
                        : "(" + point.i + ", " + point.j + ")";
                }),
            }),
        ];
        this.setState({
            numPredictionsToShow: isNewData ? Math.floor(chainLength / 2) : numPredictionsToShow,
            pointsToPlot: newPoints,
        });
    };
    PredictedContactMap.defaultProps = {
        correctColor: '#ff0000',
        data: {
            couplingScores: new data_1.CouplingContainer(),
            secondaryStructures: new Array(),
        },
        height: '100%',
        incorrectColor: '#000000',
        isDataLoading: false,
        width: '100%',
    };
    return PredictedContactMap;
}(React.Component));
exports.PredictedContactMap = PredictedContactMap;


/***/ }),

/***/ "./src/component/TFrameComponent.tsx":
/*!*******************************************!*\
  !*** ./src/component/TFrameComponent.tsx ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", { value: true });
var React = __webpack_require__(/*! react */ "./node_modules/react/index.js");
// tslint:disable-next-line: import-name
var react_iframe_comm_1 = __webpack_require__(/*! react-iframe-comm */ "./node_modules/react-iframe-comm/dist/IframeComm.js");
var context_1 = __webpack_require__(/*! ~chell-viz~/context */ "./src/context/index.ts");
var TFrameComponentClass = /** @class */ (function (_super) {
    __extends(TFrameComponentClass, _super);
    function TFrameComponentClass(props) {
        var _this = _super.call(this, props) || this;
        _this.iFrameRef = null;
        var springContext = props.springContext, data = props.data, padding = props.padding, pointColor = props.pointColor;
        _this.state = {
            postMessageData: {
                payload: {
                    data: data,
                    padding: padding,
                    pointColor: pointColor,
                    springContext: springContext,
                },
                type: 'loaded',
            },
        };
        return _this;
    }
    TFrameComponentClass.prototype.componentDidUpdate = function (prevProps) {
        var _a = this.props, data = _a.data, padding = _a.padding, pointColor = _a.pointColor, springContext = _a.springContext;
        this.setState({
            postMessageData: {
                payload: {
                    data: data,
                    padding: padding,
                    pointColor: pointColor,
                    springContext: springContext,
                },
                type: 'loaded',
            },
        });
        if (springContext && springContext !== prevProps.springContext) {
            this.forceUpdate();
        }
    };
    TFrameComponentClass.prototype.componentWillReceiveProps = function (nextProps) {
        var _this = this;
        var payload = {};
        Object.entries(nextProps).forEach(function (pair) {
            var _a;
            var key = pair['0'];
            // @ts-ignore
            if (nextProps[key] !== _this.props[key]) {
                payload = __assign({}, payload, (_a = {}, _a[key] = nextProps[key], _a));
            }
        });
        this.setState({
            postMessageData: {
                payload: payload,
                type: 'loaded',
            },
        });
    };
    TFrameComponentClass.prototype.shouldComponentUpdate = function (nextProps) {
        return (nextProps.springContext.currentCells &&
            nextProps.springContext.currentCells !== this.props.springContext.currentCells);
    };
    TFrameComponentClass.prototype.render = function () {
        var _a = this.props, height = _a.height, width = _a.width;
        var attributes = {
            height: height,
            src: 'http://localhost:8080/TContainer.html',
            width: width,
        };
        return React.createElement(react_iframe_comm_1.default, { attributes: attributes, postMessageData: this.state.postMessageData });
    };
    TFrameComponentClass.defaultProps = {
        data: [[0], [0]],
        height: 400,
        padding: 0,
        pointColor: '#000000',
        springContext: __assign({}, context_1.initialSpringContext),
        width: 400,
    };
    return TFrameComponentClass;
}(React.Component));
exports.TFrameComponentClass = TFrameComponentClass;
exports.TFrameComponent = function (props) { return (React.createElement(context_1.SpringContext.Consumer, null, function (springContext) { return React.createElement(TFrameComponentClass, __assign({}, props, { springContext: springContext })); })); };


/***/ }),

/***/ "./src/component/TensorTComponent.tsx":
/*!********************************************!*\
  !*** ./src/component/TensorTComponent.tsx ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", { value: true });
var React = __webpack_require__(/*! react */ "./node_modules/react/index.js");
var component_1 = __webpack_require__(/*! ~chell-viz~/component */ "./src/component/index.ts");
var TensorTComponentClass = /** @class */ (function (_super) {
    __extends(TensorTComponentClass, _super);
    function TensorTComponentClass(props) {
        var _this = _super.call(this, props) || this;
        _this.canvasContext = null;
        return _this;
    }
    TensorTComponentClass.prototype.render = function () {
        var pointsToPlot = this.props.pointsToPlot;
        return (React.createElement(component_1.PlotlyChart, { data: pointsToPlot, layout: __assign({}, component_1.defaultPlotlyLayout, { dragmode: 'select', margin: {
                    b: 20,
                }, xaxis: { autorange: false, range: [0, 1], showline: true }, yaxis: { autorange: false, range: [0, 1], showline: true } }), onSelectedCallback: this.props.onSelectedCallback }));
    };
    TensorTComponentClass.defaultProps = {
        pointsToPlot: [],
        style: {
            padding: 0,
        },
    };
    return TensorTComponentClass;
}(React.Component));
exports.TensorTComponent = function (props) { return React.createElement(TensorTComponentClass, __assign({}, props)); };


/***/ }),

/***/ "./src/component/VizSelectorPanel.tsx":
/*!********************************************!*\
  !*** ./src/component/VizSelectorPanel.tsx ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var React = __webpack_require__(/*! react */ "./node_modules/react/index.js");
var semantic_ui_react_1 = __webpack_require__(/*! semantic-ui-react */ "./node_modules/semantic-ui-react/dist/es/index.js");
var component_1 = __webpack_require__(/*! ~chell-viz~/component */ "./src/component/index.ts");
var container_1 = __webpack_require__(/*! ~chell-viz~/container */ "./src/container/index.ts");
var data_1 = __webpack_require__(/*! ~chell-viz~/data */ "./src/data/index.ts");
/**
 * A single visualization panel allowing a user to select how they wish to view data.
 *
 * @export
 * @extends {React.Component<VizPanelProps, VizPanelState>}
 */
var VizSelectorPanel = /** @class */ (function (_super) {
    __extends(VizSelectorPanel, _super);
    function VizSelectorPanel(props) {
        var _this = _super.call(this, props) || this;
        _this.onVizSelect = function (event, data) {
            _this.setState({
                selectedViz: data.value,
            });
        };
        _this.generateDropdownItems = function (supportedVisualizations) {
            return supportedVisualizations
                .map(function (viz) { return ({
                key: viz,
                text: viz,
                value: viz,
            }); })
                .sort(function (a, b) { return a.key.localeCompare(b.key); });
        };
        _this.state = {
            selectedViz: props.initialViz,
        };
        return _this;
    }
    VizSelectorPanel.prototype.render = function () {
        // N.B. We are only setting the width of the VizSelectorPanel, explicitly leaving out the height.
        // This means a component can only grow vertically, but not horizontally, and be correctly styled in containers.
        var _a = this.props, data = _a.data, supportedVisualizations = _a.supportedVisualizations, width = _a.width;
        return (React.createElement("div", { className: "VizSelectorPanel", style: { width: width } },
            React.createElement(semantic_ui_react_1.Dropdown, { options: this.generateDropdownItems(supportedVisualizations), fluid: true, onChange: this.onVizSelect, defaultValue: this.props.initialViz }),
            React.createElement(semantic_ui_react_1.Card, { fluid: true, raised: true }, this.renderVizContainer(this.state.selectedViz, data))));
    };
    VizSelectorPanel.prototype.renderVizContainer = function (viz, data) {
        var padding = this.props.padding;
        var paddedHeight = this.props.height - padding * 2;
        var paddedWidth = this.props.width - padding * 2;
        switch (viz) {
            case data_1.VIZ_TYPE['T-SNE']:
            case data_1.VIZ_TYPE['TENSOR-T-SNE']:
                return (data['TENSOR-T-SNE'] && (React.createElement(container_1.TensorTContainer, { style: {
                        padding: padding,
                    } })));
            case data_1.VIZ_TYPE['T-SNE-FRAME']:
                return (data['T-SNE'] && (React.createElement(component_1.TFrameComponent, { data: data['T-SNE'], height: paddedHeight, padding: padding, width: paddedWidth })));
            case data_1.VIZ_TYPE.SPRING:
                return React.createElement(container_1.SpringContainer, { padding: padding });
            case data_1.VIZ_TYPE.NGL:
                return (data.NGL && (React.createElement(component_1.NGLComponent, { data: data.NGL, height: paddedHeight, style: { padding: padding }, width: paddedWidth })));
            case data_1.VIZ_TYPE.CONTACT_MAP:
                return (data['Contact Map'] && (React.createElement(component_1.PredictedContactMap, { data: data['Contact Map'], height: paddedHeight, style: { padding: padding }, width: paddedWidth })));
            case data_1.VIZ_TYPE.INFO_PANEL:
                return React.createElement(component_1.InfoPanel, { data: data['Contact Map'], height: 400, width: 400 });
            default:
                throw new Error("Unknown viz: " + viz);
        }
    };
    VizSelectorPanel.defaultProps = {
        data: new Object(),
        height: 450,
        initialViz: data_1.VIZ_TYPE['T-SNE'],
        padding: 15,
        supportedVisualizations: [],
        width: 450,
    };
    return VizSelectorPanel;
}(React.Component));
exports.VizSelectorPanel = VizSelectorPanel;


/***/ }),

/***/ "./src/component/chart/AuxiliaryAxis.ts":
/*!**********************************************!*\
  !*** ./src/component/chart/AuxiliaryAxis.ts ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __values = (this && this.__values) || function (o) {
    var m = typeof Symbol === "function" && o[Symbol.iterator], i = 0;
    if (m) return m.call(o);
    return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spread = (this && this.__spread) || function () {
    for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));
    return ar;
};
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Class to represent an extra x and/or y axis for a Plotly chart.
 */
var AuxiliaryAxis = /** @class */ (function () {
    /**
     * Creates an instance of AuxiliaryAxis.
     * @param sections The underlying data to be represented by these axes.
     * @param [axisIndex=2] The index of this axis, if there are multiple auxiliary axes.
     * @param [defaultColor='black'] What color should the axis be by default?
     * @param [colorMap] Allows specific data pieces to be colored.
     * @param [dataTransformFn] Determine how a section is to be transformed to the main and opposite axis.
     *  For example, for a sine wave, the main axis increments by 1 but the opposite needs to be increased by a Math.sin() call.
     * @param [filterFn=() => false] Function to allow certain elements to be filtered out and thus not show up on the axis.
     */
    function AuxiliaryAxis(sections, axisIndex, defaultColor, colorMap, dataTransformFn, filterFn) {
        if (axisIndex === void 0) { axisIndex = 2; }
        if (defaultColor === void 0) { defaultColor = 'black'; }
        if (filterFn === void 0) { filterFn = function () { return false; }; }
        var _this = this;
        this.sections = sections;
        this.axisIndex = axisIndex;
        this.defaultColor = defaultColor;
        this.colorMap = colorMap;
        this.dataTransformFn = dataTransformFn;
        this.filterFn = filterFn;
        this.axes = new Map();
        this.highlightedAxes = new Map();
        /**
         * Plotly data specific for the x axis.
         *
         * @param key The label for this piece of data.
         */
        this.generateXAxisSegment = function (key) { return (__assign({}, _this.auxiliaryAxisDefaults(key), { orientation: 'h', xaxis: 'x', yaxis: "y" + _this.axisIndex })); };
        /**
         * Plotly data specific for the highlighted x axis.
         *
         * @param key The label for this piece of data.
         */
        this.generateHighlightedXAxisSegment = function (key) { return (__assign({}, _this.highlightedAuxiliaryAxisDefaults(key), { orientation: 'h', xaxis: 'x', yaxis: "y" + _this.axisIndex })); };
        /**
         * Plotly data specific for the y axis.
         *
         * @param key The label for this piece of data.
         */
        this.generateYAxisSegment = function (key) { return (__assign({}, _this.auxiliaryAxisDefaults(key), { orientation: 'v', xaxis: "x" + _this.axisIndex, yaxis: 'y' })); };
        /**
         * Plotly data specific for the highlighted y axis.
         *
         * @param key The label for this piece of data.
         */
        this.generateHighlightedYAxisSegment = function (key) { return (__assign({}, _this.highlightedAuxiliaryAxisDefaults(key), { orientation: 'v', xaxis: "x" + _this.axisIndex, yaxis: 'y' })); };
        /**
         * Default plotly data for an axis.
         *
         * @param key The label for this piece of data.
         */
        this.auxiliaryAxisDefaults = function (key) { return ({
            connectgaps: false,
            hoverinfo: 'none',
            line: {
                color: _this.colorMap && _this.colorMap[key] ? _this.colorMap[key] : _this.defaultColor,
                shape: 'spline',
                smoothing: 1.3,
                width: 1.5,
            },
            marker: {
                symbol: [],
            },
            mode: 'lines',
            name: key,
            showlegend: false,
            type: 'scatter',
            x: [],
            y: [],
        }); };
        /**
         * Default plotly data for a highlighted axis.
         *
         * @param key The label for this piece of data.
         */
        this.highlightedAuxiliaryAxisDefaults = function (key) { return (__assign({}, _this.auxiliaryAxisDefaults(key), { fill: 'toself', line: {
                color: _this.colorMap && _this.colorMap[key] ? _this.colorMap[key] : _this.defaultColor,
                width: 0,
            } })); };
        /**
         * Determines the points that make up the axis for both the main and opposite axis side.
         * @param section The section of data to derive points for.
         */
        this.derivePointsInAxis = function (section) {
            var result = {
                main: [section.start],
                opposite: [null],
            };
            for (var i = section.start; i <= section.end; ++i) {
                var transformResult = _this.dataTransformFn && _this.dataTransformFn[section.label]
                    ? _this.dataTransformFn[section.label](section, i)
                    : { main: i, opposite: -1 };
                result.main.push(transformResult.main);
                result.opposite.push(transformResult.opposite);
            }
            result.main.push(section.end);
            result.opposite.push(null);
            return result;
        };
        this.deriveHighlightedPointsInAxis = function (section) {
            var result = {
                main: [section.start],
                opposite: [null],
            };
            result.main.push(section.start);
            result.opposite.push(-1);
            result.main.push(section.start);
            result.opposite.push(1);
            result.main.push(section.end);
            result.opposite.push(1);
            result.main.push(section.end);
            result.opposite.push(-1);
            result.main.push(section.end);
            result.opposite.push(null);
            return result;
        };
        this.setupAuxiliaryAxis();
    }
    Object.defineProperty(AuxiliaryAxis.prototype, "axis", {
        /**
         * Get all the axis objects belonging to this Auxiliary Axis.
         */
        get: function () {
            return this.axes;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AuxiliaryAxis.prototype, "xAxes", {
        /**
         * Get all the x-axis objects belonging to this Auxiliary Axis.
         */
        get: function () {
            var result = new Array();
            this.axes.forEach(function (value) {
                result.push(value.x);
            });
            return result;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AuxiliaryAxis.prototype, "highlightedXAxes", {
        /**
         * Get all the highlighted x-axis objects belonging to this Auxiliary Axis.
         */
        get: function () {
            var result = new Array();
            this.highlightedAxes.forEach(function (value) {
                result.push(value.x);
            });
            return result;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AuxiliaryAxis.prototype, "yAxes", {
        /**
         * Get all the y-axis objects belonging to this Auxiliary Axis.
         */
        get: function () {
            var result = new Array();
            this.axes.forEach(function (value) {
                result.push(value.y);
            });
            return result;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AuxiliaryAxis.prototype, "highlightedYAxes", {
        /**
         * Get all the highlighted y-axis objects belonging to this Auxiliary Axis.
         */
        get: function () {
            var result = new Array();
            this.highlightedAxes.forEach(function (value) {
                result.push(value.y);
            });
            return result;
        },
        enumerable: true,
        configurable: true
    });
    AuxiliaryAxis.prototype.getAxisById = function (id) {
        return this.axes.get(id);
    };
    /**
     * Create the Auxiliary Axis.
     */
    AuxiliaryAxis.prototype.setupAuxiliaryAxis = function () {
        var e_1, _a, _b, _c, _d, _e, _f, _g, _h, _j;
        try {
            for (var _k = __values(this.sections), _l = _k.next(); !_l.done; _l = _k.next()) {
                var section = _l.value;
                if (this.filterFn(section)) {
                    continue;
                }
                var label = section.label;
                if (!this.axes.has(label)) {
                    this.axes.set(label, {
                        x: this.generateXAxisSegment(label),
                        y: this.generateYAxisSegment(label),
                    });
                }
                if (!this.highlightedAxes.has(label)) {
                    this.highlightedAxes.set(label, {
                        x: this.generateHighlightedXAxisSegment(label),
                        y: this.generateHighlightedYAxisSegment(label),
                    });
                }
                var labelAxis = this.axes.get(label);
                var highlightAxis = this.highlightedAxes.get(label);
                if (labelAxis && highlightAxis) {
                    var points = this.derivePointsInAxis(section);
                    (_b = labelAxis.x.x).push.apply(_b, __spread(points.main));
                    (_c = labelAxis.x.y).push.apply(_c, __spread(points.opposite));
                    (_d = labelAxis.y.y).push.apply(_d, __spread(points.main));
                    (_e = labelAxis.y.x).push.apply(_e, __spread(points.opposite));
                    var highlightedPoints = this.deriveHighlightedPointsInAxis(section);
                    (_f = highlightAxis.x.x).push.apply(_f, __spread(highlightedPoints.main));
                    (_g = highlightAxis.x.y).push.apply(_g, __spread(highlightedPoints.opposite));
                    (_h = highlightAxis.y.y).push.apply(_h, __spread(highlightedPoints.main));
                    (_j = highlightAxis.y.x).push.apply(_j, __spread(highlightedPoints.opposite));
                }
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_l && !_l.done && (_a = _k.return)) _a.call(_k);
            }
            finally { if (e_1) throw e_1.error; }
        }
    };
    return AuxiliaryAxis;
}());
exports.AuxiliaryAxis = AuxiliaryAxis;


/***/ }),

/***/ "./src/component/chart/ContactMapChart.tsx":
/*!*************************************************!*\
  !*** ./src/component/chart/ContactMapChart.tsx ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)
            t[p[i]] = s[p[i]];
    return t;
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spread = (this && this.__spread) || function () {
    for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));
    return ar;
};
Object.defineProperty(exports, "__esModule", { value: true });
var React = __webpack_require__(/*! react */ "./node_modules/react/index.js");
var semantic_ui_react_1 = __webpack_require__(/*! semantic-ui-react */ "./node_modules/semantic-ui-react/dist/es/index.js");
var component_1 = __webpack_require__(/*! ~chell-viz~/component */ "./src/component/index.ts");
var helper_1 = __webpack_require__(/*! ~chell-viz~/helper */ "./src/helper/index.ts");
exports.generateChartDataEntry = function (hoverinfo, color, name, subtitle, nodeSize, points, extra) {
    if (extra === void 0) { extra = {}; }
    return (__assign({ hoverinfo: hoverinfo, marker: typeof color === 'string'
            ? { color: new Array(points.length * 2).fill(color) }
            : {
                colorscale: [
                    [0, 'rgb(12,50,102)'],
                    [0.1, 'rgb(17,83,150)'],
                    [0.2, 'rgb(40,114,175)'],
                    [0.3, 'rgb(71,147,193)'],
                    [0.4, 'rgb(111,175,209)'],
                    [0.5, 'rgb(160,202,222)'],
                    [0.6, 'rgb(200,219,237)'],
                    [0.7, 'rgb(224,235,246)'],
                    [0.8, 'rgb(247,251,255)'],
                    [0.9, 'rgb(249,253,255)'],
                    [1, 'rgb(255,255,255)'],
                ],
            }, mode: 'lines+markers', name: name,
        nodeSize: nodeSize,
        points: points,
        subtitle: subtitle }, extra));
};
/**
 * Intermediary between a ContactMap and a PlotlyChart.
 *
 * Will transform data and setup layout from science/chell data type into the Plotly type.
 * @extends {React.Component<IContactMapChartProps, any>}
 */
var ContactMapChart = /** @class */ (function (_super) {
    __extends(ContactMapChart, _super);
    function ContactMapChart(props) {
        var _this = _super.call(this, props) || this;
        _this.toggleLegendVisibility = function () {
            _this.setState({
                showlegend: !_this.state.showlegend,
            });
        };
        _this.state = {
            numLegends: 0,
            plotlyData: [],
            showlegend: false,
        };
        return _this;
    }
    ContactMapChart.prototype.componentDidMount = function () {
        this.setupData();
    };
    ContactMapChart.prototype.componentDidUpdate = function (prevProps) {
        var _a = this.props, contactData = _a.contactData, secondaryStructures = _a.secondaryStructures, selectedSecondaryStructures = _a.selectedSecondaryStructures;
        if (prevProps.contactData !== contactData ||
            prevProps.secondaryStructures !== secondaryStructures ||
            prevProps.selectedSecondaryStructures !== selectedSecondaryStructures) {
            this.setupData();
        }
    };
    ContactMapChart.prototype.render = function () {
        var _a = this.props, configurations = _a.configurations, contactData = _a.contactData, legendModifiers = _a.legendModifiers, marginModifiers = _a.marginModifiers, range = _a.range, showConfigurations = _a.showConfigurations, passThroughProps = __rest(_a, ["configurations", "contactData", "legendModifiers", "marginModifiers", "range", "showConfigurations"]);
        var _b = this.state, plotlyData = _b.plotlyData, showlegend = _b.showlegend;
        return (React.createElement(component_1.SettingsPanel, { configurations: configurations, showConfigurations: showConfigurations },
            React.createElement(semantic_ui_react_1.Button, { basic: true, floated: 'left', icon: React.createElement(semantic_ui_react_1.Icon, { name: 'question circle outline', size: 'large' }), onClick: this.toggleLegendVisibility, style: { float: 'left', margin: '0 0 0 15px', position: 'relative', top: '500px', zIndex: 999 } }),
            React.createElement(component_1.PlotlyChart, __assign({ data: plotlyData, layout: {
                    legend: {
                        orientation: 'h',
                        y: legendModifiers.y,
                        yanchor: 'bottom',
                    },
                    margin: {
                        b: marginModifiers.b,
                        l: marginModifiers.l,
                    },
                    showlegend: showlegend,
                    xaxis: {
                        autorange: true,
                        fixedrange: true,
                        nticks: 10,
                        range: [0, 33000],
                        rangemode: 'nonnegative',
                        showline: true,
                        tickmode: 'auto',
                        title: 'Residue #',
                    },
                    yaxis: {
                        autorange: 'reversed',
                        fixedrange: true,
                        nticks: 10,
                        range: [0, 33000],
                        rangemode: 'nonnegative',
                        showline: true,
                        tickmode: 'auto',
                        title: 'Residue #',
                    },
                } }, passThroughProps))));
    };
    /**
     * Sets up the chart and axis data for the ContactMap.
     *
     * Transforms all data from chell terminology to data properly formatted for Plotly consumption.
     */
    ContactMapChart.prototype.setupData = function () {
        var _a = this.props, contactData = _a.contactData, dataTransformFn = _a.dataTransformFn, secondaryStructures = _a.secondaryStructures, selectedSecondaryStructures = _a.selectedSecondaryStructures;
        var plotlyData = __spread(contactData.map(function (entry) { return dataTransformFn(entry, true); }));
        secondaryStructures.forEach(function (secondaryStructure, index) {
            var axis = new component_1.SecondaryStructureAxis(secondaryStructure, 3, index + 2);
            plotlyData.push.apply(plotlyData, __spread(axis.xAxes, axis.yAxes));
        });
        var highlightedAxes = new Array();
        selectedSecondaryStructures.forEach(function (selectedStructure, index) {
            var axis = new component_1.AuxiliaryAxis(selectedStructure, index + 2, 'orange');
            highlightedAxes.push.apply(highlightedAxes, __spread(axis.highlightedXAxes, axis.highlightedYAxes));
        });
        this.setState({
            numLegends: new Set(plotlyData.filter(function (datum) { return datum.showlegend !== false && datum.name !== undefined; }).map(function (legend) { return legend.name; })).size,
            // Makes sure that highlighted axis is behind the axis.
            plotlyData: __spread(highlightedAxes, plotlyData),
        });
    };
    ContactMapChart.defaultProps = {
        candidateResidues: new Array(),
        configurations: new Array(),
        dataTransformFn: helper_1.generateScatterGLData,
        height: '100%',
        legendModifiers: {
            y: -0.4,
        },
        marginModifiers: {
            b: 65,
            l: 65,
        },
        range: 100,
        secondaryStructures: [],
        selectedSecondaryStructures: [],
        selectedSecondaryStructuresColor: '#feb83f',
        showConfigurations: true,
        width: '100%',
    };
    return ContactMapChart;
}(React.Component));
exports.ContactMapChart = ContactMapChart;


/***/ }),

/***/ "./src/component/chart/PlotlyChart.tsx":
/*!*********************************************!*\
  !*** ./src/component/chart/PlotlyChart.tsx ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spread = (this && this.__spread) || function () {
    for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));
    return ar;
};
var __values = (this && this.__values) || function (o) {
    var m = typeof Symbol === "function" && o[Symbol.iterator], i = 0;
    if (m) return m.call(o);
    return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
};
Object.defineProperty(exports, "__esModule", { value: true });
var Immutable = __webpack_require__(/*! immutable */ "./node_modules/immutable/dist/immutable.js");
var lodash_1 = __webpack_require__(/*! lodash */ "./node_modules/lodash/lodash.js");
var plotly = __webpack_require__(/*! plotly.js-gl2d-dist */ "./node_modules/plotly.js-gl2d-dist/plotly-gl2d.js");
var React = __webpack_require__(/*! react */ "./node_modules/react/index.js");
var semantic_ui_react_1 = __webpack_require__(/*! semantic-ui-react */ "./node_modules/semantic-ui-react/dist/es/index.js");
var data_1 = __webpack_require__(/*! ~chell-viz~/data */ "./src/data/index.ts");
exports.defaultPlotlyConfig = {
    displayModeBar: false,
    doubleClick: 'reset',
    scrollZoom: true,
    showAxisDragHandles: false,
    staticPlot: false,
};
exports.defaultPlotlyLayout = {
    autosize: true,
    dragmode: 'zoom',
    hovermode: 'closest',
    legend: {},
    margin: {
        b: 10,
        l: 40,
        r: 10,
        t: 10,
    },
    showlegend: false,
    title: '',
};
/**
 * React wrapper for a Plotly Chart.
 *
 * @description
 * Based upon: https://github.com/davidctj/react-plotlyjs-ts
 *
 * @export
 * @extends {React.Component<IPlotlyChartProps, any>}
 */
var PlotlyChart = /** @class */ (function (_super) {
    __extends(PlotlyChart, _super);
    function PlotlyChart() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.plotlyCanvas = null;
        // Makes sure single click isn't fired when double click is in flight. Required due to https://github.com/plotly/plotly.js/issues/1546
        _this.isDoubleClickInProgress = false;
        _this.canvasRef = null;
        _this.plotlyFormattedData = [];
        /**
         * Resizes the inner Plotly canvas.
         */
        _this.resize = function () {
            if (_this.plotlyCanvas) {
                plotly.Plots.resize(_this.plotlyCanvas);
            }
        };
        /**
         * Sends a draw call to Plotly since it is using canvas/WebGL which is outside of the locus of control for React.
         */
        _this.draw = function () { return __awaiter(_this, void 0, void 0, function () {
            var _a, config, layout, mergedLayout, mergedConfig, _b;
            return __generator(this, function (_c) {
                switch (_c.label) {
                    case 0:
                        _a = this.props, config = _a.config, layout = _a.layout;
                        if (!(this.plotlyCanvas && this.canvasRef)) return [3 /*break*/, 2];
                        mergedLayout = this.getMergedLayout(layout, this.plotlyFormattedData);
                        mergedConfig = this.getMergedConfig(config);
                        // console.log(mergedLayout);
                        // console.log(mergedConfig);
                        _b = this;
                        return [4 /*yield*/, plotly.react(this.canvasRef, this.plotlyFormattedData, mergedLayout, mergedConfig)];
                    case 1:
                        // console.log(mergedLayout);
                        // console.log(mergedConfig);
                        _b.plotlyCanvas = _c.sent();
                        _c.label = 2;
                    case 2: return [2 /*return*/];
                }
            });
        }); };
        _this.deriveChartPiece = function (xDatum, yDatum, data) {
            var x = xDatum;
            var y = yDatum;
            if (data) {
                var isExtraXAxis = data.xaxis && data.xaxis !== 'x';
                var isExtraYAxis = data.yaxis && data.yaxis !== 'y';
                if (isExtraXAxis || isExtraYAxis) {
                    return {
                        chartPiece: data_1.CHELL_CHART_PIECE.AXIS,
                        selectedPoints: isExtraXAxis ? [y] : [x],
                    };
                }
            }
            return {
                chartPiece: data_1.CHELL_CHART_PIECE.POINT,
                selectedPoints: [x, y],
            };
        };
        /**
         * Generate axis data for those beyond the original x/yaxis.
         *
         * @param ids All of the axis ids associated with plotly data.
         */
        _this.generateExtraPlotlyAxis = function (ids) {
            return Array.from(ids.values())
                .filter(function (id) { return id.length >= 2; }) // Ignores { xaxis: x } and { yaxis: y }.
                .map(function (id) { return _this.generateExtraPlotlyAxisFromId(id); })
                .reduce(function (prev, curr) {
                return __assign({}, prev, curr);
            }, {});
        };
        _this.getMergedConfig = function (config) {
            if (config === void 0) { config = {}; }
            var copiedConfig = Immutable.fromJS(__assign({}, exports.defaultPlotlyConfig));
            var immutableConfigFromJs = Immutable.fromJS(__assign({}, config));
            return __assign({}, copiedConfig.mergeDeep(immutableConfigFromJs).toJS());
        };
        _this.getMergedLayout = function (layout, plotlyFormattedData) {
            if (layout === void 0) { layout = {}; }
            if (plotlyFormattedData === void 0) { plotlyFormattedData = []; }
            var copiedLayout = Immutable.fromJS(__assign({}, layout));
            var copiedLayoutFromData = Immutable.fromJS(__assign({}, exports.defaultPlotlyLayout, _this.deriveAxisParams(plotlyFormattedData)));
            var result = __assign({}, copiedLayoutFromData.mergeDeep(copiedLayout).toJS());
            if (_this.savedAxisZoom && result.xaxis && result.yaxis) {
                result.xaxis.range = _this.savedAxisZoom.xaxis.range;
                result.yaxis.range = _this.savedAxisZoom.yaxis.range;
            }
            return result;
        };
        _this.onAfterPlot = function () {
            var onAfterPlotCallback = _this.props.onAfterPlotCallback;
            if (onAfterPlotCallback) {
                onAfterPlotCallback(new data_1.ChellChartEvent(data_1.CHELL_CHART_EVENT_TYPE.AFTER_PLOT));
            }
        };
        _this.onClick = function (event) {
            var shouldHandleClick = _this.isDoubleClickInProgress === false && event.points !== undefined && event.points.length > 0;
            if (shouldHandleClick) {
                var onClickCallback = _this.props.onClickCallback;
                if (onClickCallback) {
                    var x = event.points[0].x ? event.points[0].x : event.points[0].data.x[0];
                    var y = event.points[0].y ? event.points[0].y : event.points[0].data.y[0];
                    var _a = _this.deriveChartPiece(x, y, event.points[0].data), chartPiece = _a.chartPiece, selectedPoints = _a.selectedPoints;
                    onClickCallback(new data_1.ChellChartEvent(data_1.CHELL_CHART_EVENT_TYPE.CLICK, chartPiece, selectedPoints));
                }
            }
        };
        _this.onDoubleClick = function () {
            _this.isDoubleClickInProgress = true;
            var onDoubleClickCallback = _this.props.onDoubleClickCallback;
            if (onDoubleClickCallback) {
                onDoubleClickCallback(new data_1.ChellChartEvent(data_1.CHELL_CHART_EVENT_TYPE.DOUBLE_CLICK));
            }
        };
        _this.onHover = function (event) {
            var onHoverCallback = _this.props.onHoverCallback;
            if (event.points && event.points[0] && onHoverCallback) {
                var x = event.points[0].x ? event.points[0].x : event.points[0].data.x[0];
                var y = event.points[0].y ? event.points[0].y : event.points[0].data.y[0];
                var _a = _this.deriveChartPiece(x, y, event.points[0].data), chartPiece = _a.chartPiece, selectedPoints = _a.selectedPoints;
                onHoverCallback(new data_1.ChellChartEvent(data_1.CHELL_CHART_EVENT_TYPE.HOVER, chartPiece, selectedPoints));
            }
        };
        _this.onRelayout = function (event) {
            _this.isDoubleClickInProgress = false;
            // !IMPORTANT! Yes, these numbers have to be accessed like this, see:
            // https://plot.ly/javascript/plotlyjs-function-reference/#plotlyrestyle
            // https://github.com/plotly/plotly.js/issues/2843
            var axisKeys = ['xaxis.range[0]', 'xaxis.range[1]', 'yaxis.range[0]', 'yaxis.range[1]'];
            var isEventFormattedCorrect = event !== undefined && axisKeys.reduce(function (prev, cur) { return prev && event[cur] !== undefined; }, true) === true;
            _this.savedAxisZoom = isEventFormattedCorrect
                ? {
                    xaxis: {
                        autorange: false,
                        range: [event[axisKeys[0]], event[axisKeys[1]]],
                    },
                    yaxis: {
                        autorange: false,
                        range: [event[axisKeys[2]], event[axisKeys[3]]],
                    },
                }
                : undefined;
            var onRelayoutCallback = _this.props.onRelayoutCallback;
            if (onRelayoutCallback) {
                onRelayoutCallback(new data_1.ChellChartEvent(data_1.CHELL_CHART_EVENT_TYPE.RELAYOUT));
            }
        };
        _this.onSelect = function (event) { return __awaiter(_this, void 0, void 0, function () {
            var onSelectedCallback, allPoints, chartPiece;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        onSelectedCallback = this.props.onSelectedCallback;
                        if (event && onSelectedCallback) {
                            allPoints = new Array();
                            if (event.points.length >= 1) {
                                allPoints = event.points.reduce(function (prev, cur) {
                                    prev.push.apply(prev, __spread([cur.x, cur.y]));
                                    return prev;
                                }, allPoints);
                            }
                            else if (event.range) {
                                // If it is a range, it is a box and so the coordinates can be directly accessed like so.
                                allPoints.push(event.range.x[0], event.range.y[0], event.range.x[1], event.range.y[1]);
                            }
                            chartPiece = (allPoints.length > 0
                                ? this.deriveChartPiece(allPoints[0], allPoints[1])
                                : { chartPiece: data_1.CHELL_CHART_PIECE.POINT }).chartPiece;
                            onSelectedCallback(new data_1.ChellChartEvent(data_1.CHELL_CHART_EVENT_TYPE.SELECTION, chartPiece, allPoints, event));
                        }
                        return [4 /*yield*/, this.draw()];
                    case 1:
                        _a.sent();
                        return [2 /*return*/];
                }
            });
        }); };
        _this.onUnHover = function (event) {
            var onUnHoverCallback = _this.props.onUnHoverCallback;
            if (event && onUnHoverCallback) {
                var _a = event.points[0], data = _a.data, x = _a.x, y = _a.y;
                var _b = _this.deriveChartPiece(x, y, data), chartPiece = _b.chartPiece, selectedPoints = _b.selectedPoints;
                onUnHoverCallback(new data_1.ChellChartEvent(data_1.CHELL_CHART_EVENT_TYPE.UNHOVER, chartPiece, selectedPoints));
            }
        };
        return _this;
    }
    /**
     * Setup all the event listeners for the plotly canvas.
     */
    PlotlyChart.prototype.attachListeners = function () {
        if (this.plotlyCanvas) {
            this.plotlyCanvas.on('plotly_afterplot', this.onAfterPlot);
            this.plotlyCanvas.on('plotly_click', this.onClick);
            this.plotlyCanvas.on('plotly_doubleclick', this.onDoubleClick);
            this.plotlyCanvas.on('plotly_hover', this.onHover);
            this.plotlyCanvas.on('plotly_relayout', this.onRelayout);
            this.plotlyCanvas.on('plotly_selected', this.onSelect);
            this.plotlyCanvas.on('plotly_unhover', this.onUnHover);
        }
        window.removeEventListener('resize', this.resize);
        window.addEventListener('resize', this.resize);
    };
    /**
     * Determines if we should send a draw call to Plotly based on if data has actually changed.
     *
     * @param prevProps The previous props for the PlotlyChart.
     */
    PlotlyChart.prototype.componentDidUpdate = function (prevProps) {
        return __awaiter(this, void 0, void 0, function () {
            var _a, data, layout, config;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = this.props, data = _a.data, layout = _a.layout, config = _a.config;
                        if (!(!lodash_1.isEqual(data, prevProps.data) || !lodash_1.isEqual(layout, prevProps.layout) || !lodash_1.isEqual(config, prevProps.config))) return [3 /*break*/, 2];
                        this.plotlyFormattedData = lodash_1.isEqual(data, prevProps.data)
                            ? this.plotlyFormattedData
                            : Immutable.fromJS(data).toJS();
                        return [4 /*yield*/, this.draw()];
                    case 1:
                        _b.sent();
                        _b.label = 2;
                    case 2: return [2 /*return*/];
                }
            });
        });
    };
    PlotlyChart.prototype.componentDidMount = function () {
        return __awaiter(this, void 0, void 0, function () {
            var data, immutableData, _a;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        if (!(this.canvasRef && !this.plotlyCanvas)) return [3 /*break*/, 3];
                        data = this.props.data;
                        immutableData = Immutable.fromJS(data);
                        this.plotlyFormattedData = immutableData.toJS();
                        _a = this;
                        return [4 /*yield*/, plotly.react(this.canvasRef, this.plotlyFormattedData)];
                    case 1:
                        _a.plotlyCanvas = _b.sent();
                        this.attachListeners();
                        return [4 /*yield*/, this.draw()];
                    case 2:
                        _b.sent();
                        _b.label = 3;
                    case 3: return [2 /*return*/];
                }
            });
        });
    };
    PlotlyChart.prototype.componentWillUnmount = function () {
        if (this.renderTimeout) {
            clearTimeout(this.renderTimeout);
        }
        if (this.plotlyCanvas) {
            plotly.purge(this.plotlyCanvas);
            this.plotlyCanvas = null;
            this.canvasRef = null;
        }
        window.removeEventListener('resize', this.resize);
    };
    PlotlyChart.prototype.render = function () {
        var _this = this;
        var _a = this.props, height = _a.height, showLoader = _a.showLoader, style = _a.style, width = _a.width;
        return (React.createElement(React.Fragment, null,
            showLoader && (React.createElement(semantic_ui_react_1.Dimmer, { active: !this.isDataLoaded() },
                React.createElement(semantic_ui_react_1.Loader, null))),
            React.createElement("div", { className: 'plotly-chart', ref: function (node) { return (_this.canvasRef = node ? node : null); }, style: __assign({ marginBottom: 5 }, style, { height: height, width: width }) })));
    };
    PlotlyChart.prototype.generateExtraPlotlyAxisFromId = function (id) {
        var _a;
        var axisId = id.substr(0, 1);
        var axisNum = Number.parseInt(id.substr(1), 10);
        return _a = {},
            _a[axisId + "axis" + axisNum] = {
                // TODO Have this number - 0.05 - be configurable. Requires some design work to look good for various numbers of total axes.
                domain: [1 - (axisNum - 1) * 0.05, 1 - (axisNum - 2) * 0.05],
                visible: false,
            },
            _a;
    };
    /**
     * Create [0-n] plotly axes given some plotly data.
     *
     * @param allData The already formatted Plotly data - meaning each data should have the proper axis already assigned.
     * @returns A object containing xaxis and yaxis fields, as well as xaxis# and yaxis# fields where # is derived from the given data.
     */
    PlotlyChart.prototype.deriveAxisParams = function (allData) {
        var e_1, _a;
        var uniqueXAxisIds = new Set();
        var uniqueYAxisIds = new Set();
        try {
            for (var allData_1 = __values(allData), allData_1_1 = allData_1.next(); !allData_1_1.done; allData_1_1 = allData_1.next()) {
                var data = allData_1_1.value;
                var xaxis = data.xaxis, yaxis = data.yaxis;
                if (xaxis) {
                    uniqueXAxisIds.add(xaxis);
                }
                if (yaxis) {
                    uniqueYAxisIds.add(yaxis);
                }
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (allData_1_1 && !allData_1_1.done && (_a = allData_1.return)) _a.call(allData_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
        // TODO Have the spacing number - 0.05 - be configurable. Requires some design work to look good for various numbers of total axes.
        return __assign({}, this.generateExtraPlotlyAxis(uniqueXAxisIds), this.generateExtraPlotlyAxis(uniqueYAxisIds), { xaxis: {
                domain: [0, 1 - uniqueXAxisIds.size * 0.05],
                range: [30],
                zeroline: false,
            }, yaxis: {
                domain: [0, 1 - uniqueXAxisIds.size * 0.05],
                range: [30],
                zeroline: false,
            } });
    };
    /**
     * Is the data ready to be plotted?
     */
    PlotlyChart.prototype.isDataLoaded = function () {
        return (this.props.data.length > 0 ||
            this.plotlyFormattedData.filter(function (dataPoint) { return dataPoint.x && dataPoint.x.length >= 1; }).length > 0);
    };
    PlotlyChart.defaultProps = {
        config: {},
        data: [],
        height: '100%',
        layout: {},
        showLoader: true,
        width: '100%',
    };
    return PlotlyChart;
}(React.Component));
exports.PlotlyChart = PlotlyChart;


/***/ }),

/***/ "./src/component/chart/SecondaryStructureAxis.ts":
/*!*******************************************************!*\
  !*** ./src/component/chart/SecondaryStructureAxis.ts ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", { value: true });
// tslint:disable-next-line:no-relative-imports
var _1 = __webpack_require__(/*! ./ */ "./src/component/chart/index.ts");
/**
 * Class to represent the x and y axis for a secondary structure on a Plotly graph.
 *
 * @export
 */
var SecondaryStructureAxis = /** @class */ (function (_super) {
    __extends(SecondaryStructureAxis, _super);
    function SecondaryStructureAxis(sections, minimumRequiredResidues, axisIndex, defaultColor, colorMap, dataTransformFn, filterFn) {
        if (minimumRequiredResidues === void 0) { minimumRequiredResidues = 3; }
        if (axisIndex === void 0) { axisIndex = 2; }
        if (defaultColor === void 0) { defaultColor = 'black'; }
        if (colorMap === void 0) { colorMap = {
            C: 'red',
            E: 'green',
            H: 'blue',
        }; }
        if (dataTransformFn === void 0) { dataTransformFn = {
            C: SecondaryStructureAxis.centerSectionPositionFn,
            E: SecondaryStructureAxis.centerSectionPositionFn,
            H: function (section, index) { return ({
                main: index,
                opposite: Math.sin(index),
            }); },
        }; }
        if (filterFn === void 0) { filterFn = function (section) { return section.length <= minimumRequiredResidues; }; }
        var _this = _super.call(this, sections, axisIndex, defaultColor, colorMap, dataTransformFn, filterFn) || this;
        _this.sections = sections;
        _this.minimumRequiredResidues = minimumRequiredResidues;
        _this.axisIndex = axisIndex;
        _this.defaultColor = defaultColor;
        _this.colorMap = colorMap;
        _this.dataTransformFn = dataTransformFn;
        _this.filterFn = filterFn;
        return _this;
    }
    SecondaryStructureAxis.prototype.setupAuxiliaryAxis = function () {
        _super.prototype.setupAuxiliaryAxis.call(this);
        var sheetAxis = this.getAxisById('E');
        var BLANK_LINE = 'line-ne';
        var TRIANGLE_RIGHT = 'triangle-right';
        var TRIANGLE_DOWN = 'triangle-down';
        if (sheetAxis && sheetAxis.x.x && sheetAxis.x.y) {
            var symbols = {
                main: new Array(sheetAxis.x.x.length).fill(BLANK_LINE),
                opposite: new Array(sheetAxis.x.x.length).fill(BLANK_LINE),
            };
            for (var i = 1; i < sheetAxis.x.x.length - 1; ++i) {
                if (sheetAxis.x.y[i + 1] === null) {
                    symbols.main[i] = TRIANGLE_RIGHT;
                    symbols.opposite[i] = TRIANGLE_DOWN;
                }
            }
            sheetAxis.x = __assign({}, sheetAxis.x, this.generateBetaSheetStyle(sheetAxis.x, symbols.main));
            sheetAxis.y = __assign({}, sheetAxis.y, this.generateBetaSheetStyle(sheetAxis.y, symbols.opposite));
        }
    };
    /**
     * Generate the Plotly layout specific to beta sheet representation.
     *
     * @param data Data for this axis.
     * @param symbols The symbols that make up this axis. Should be an array of empty lines with an arrow at the end.
     * @returns Plotly layout specific to beta sheet representation.
     */
    SecondaryStructureAxis.prototype.generateBetaSheetStyle = function (data, symbols) {
        return {
            line: __assign({}, data.line, { width: 5 }),
            marker: __assign({}, data.marker, { color: this.colorMap.E, size: 10, symbol: symbols }),
            mode: 'lines+markers',
        };
    };
    SecondaryStructureAxis.centerSectionPositionFn = function (section, index) { return ({
        main: index,
        opposite: 0,
    }); };
    return SecondaryStructureAxis;
}(_1.AuxiliaryAxis));
exports.SecondaryStructureAxis = SecondaryStructureAxis;


/***/ }),

/***/ "./src/component/chart/index.ts":
/*!**************************************!*\
  !*** ./src/component/chart/index.ts ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./PlotlyChart */ "./src/component/chart/PlotlyChart.tsx"));
__export(__webpack_require__(/*! ./AuxiliaryAxis */ "./src/component/chart/AuxiliaryAxis.ts"));
__export(__webpack_require__(/*! ./ContactMapChart */ "./src/component/chart/ContactMapChart.tsx"));
__export(__webpack_require__(/*! ./SecondaryStructureAxis */ "./src/component/chart/SecondaryStructureAxis.ts"));


/***/ }),

/***/ "./src/component/index.ts":
/*!********************************!*\
  !*** ./src/component/index.ts ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./chart */ "./src/component/chart/index.ts"));
__export(__webpack_require__(/*! ./widget */ "./src/component/widget/index.ts"));
__export(__webpack_require__(/*! ./ContactMap */ "./src/component/ContactMap.tsx"));
__export(__webpack_require__(/*! ./FeatureViewer */ "./src/component/FeatureViewer.tsx"));
__export(__webpack_require__(/*! ./InfoPanel */ "./src/component/InfoPanel.tsx"));
__export(__webpack_require__(/*! ./NGLComponent */ "./src/component/NGLComponent.tsx"));
__export(__webpack_require__(/*! ./PredictedContactMap */ "./src/component/PredictedContactMap.tsx"));
__export(__webpack_require__(/*! ./TensorTComponent */ "./src/component/TensorTComponent.tsx"));
__export(__webpack_require__(/*! ./TFrameComponent */ "./src/component/TFrameComponent.tsx"));
__export(__webpack_require__(/*! ./VizSelectorPanel */ "./src/component/VizSelectorPanel.tsx"));


/***/ }),

/***/ "./src/component/widget/CategorySelector.tsx":
/*!***************************************************!*\
  !*** ./src/component/widget/CategorySelector.tsx ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spread = (this && this.__spread) || function () {
    for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));
    return ar;
};
Object.defineProperty(exports, "__esModule", { value: true });
var React = __webpack_require__(/*! react */ "./node_modules/react/index.js");
var semantic_ui_react_1 = __webpack_require__(/*! semantic-ui-react */ "./node_modules/semantic-ui-react/dist/es/index.js");
/**
 * Class to represent a dropdown.
 *
 * @extends {React.Component<ICategorySelectorProps, any>}
 */
var CategorySelector = /** @class */ (function (_super) {
    __extends(CategorySelector, _super);
    function CategorySelector(props) {
        return _super.call(this, props) || this;
    }
    CategorySelector.prototype.render = function () {
        return (this.props.categories && (React.createElement(semantic_ui_react_1.Dropdown, { fluid: true, onChange: this.props.onCategoryChange, options: __spread(this.props.categories.map(function (cat) {
                return { key: cat, text: cat, value: cat };
            })), placeholder: 'Select Category', search: true })));
    };
    CategorySelector.defaultProps = {
        categories: [],
    };
    return CategorySelector;
}(React.Component));
exports.CategorySelector = CategorySelector;


/***/ }),

/***/ "./src/component/widget/ChellRadioGroup.tsx":
/*!**************************************************!*\
  !*** ./src/component/widget/ChellRadioGroup.tsx ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var React = __webpack_require__(/*! react */ "./node_modules/react/index.js");
var semantic_ui_react_1 = __webpack_require__(/*! semantic-ui-react */ "./node_modules/semantic-ui-react/dist/es/index.js");
var ChellRadioGroup = /** @class */ (function (_super) {
    __extends(ChellRadioGroup, _super);
    function ChellRadioGroup(props) {
        var _this = _super.call(this, props) || this;
        _this.handleChange = function (index) { return function (event, data) {
            _this.setState({
                selectedIndex: index,
            });
            if (_this.props.onChange) {
                _this.props.onChange(index);
            }
        }; };
        _this.renderOptions = function (id, options, disabled, style) { return (React.createElement(semantic_ui_react_1.Grid, { centered: true, columns: 2, relaxed: true, padded: true }, options.map(function (option, index) { return (React.createElement(semantic_ui_react_1.Grid.Column, { key: id + "-" + option, textAlign: 'center' },
            React.createElement(semantic_ui_react_1.Form.Radio, { checked: _this.state.selectedIndex === index, disabled: disabled, label: { children: option, style: style }, name: option, onChange: _this.handleChange(index), value: index }))); }))); };
        _this.state = {
            selectedIndex: 0,
        };
        return _this;
    }
    ChellRadioGroup.prototype.render = function () {
        var _a = this.props, disabled = _a.disabled, id = _a.id, options = _a.options, style = _a.style, title = _a.title;
        return (React.createElement(semantic_ui_react_1.Form, { style: style },
            React.createElement(semantic_ui_react_1.Form.Field, null, title),
            this.renderOptions(id, options, disabled, style)));
    };
    ChellRadioGroup.defaultProps = {
        disabled: false,
        style: {},
        title: 'How to calculate distance between two residues:',
    };
    return ChellRadioGroup;
}(React.Component));
exports.ChellRadioGroup = ChellRadioGroup;


/***/ }),

/***/ "./src/component/widget/ChellSlider.tsx":
/*!**********************************************!*\
  !*** ./src/component/widget/ChellSlider.tsx ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)
            t[p[i]] = s[p[i]];
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
// tslint:disable-next-line:import-name
var rc_slider_1 = __webpack_require__(/*! rc-slider */ "./node_modules/rc-slider/es/index.js");
var React = __webpack_require__(/*! react */ "./node_modules/react/index.js");
// https://github.com/react-component/slider/ requires the css imported like this.
// tslint:disable-next-line:no-submodule-imports no-import-side-effect
__webpack_require__(/*! rc-slider/assets/index.css */ "./node_modules/rc-slider/assets/index.css");
var semantic_ui_react_1 = __webpack_require__(/*! semantic-ui-react */ "./node_modules/semantic-ui-react/dist/es/index.js");
/**
 * Represents a simple 2d slider, allowing a value to be selected between a minimum and maximum.
 *
 * @export
 * @extends {React.Component<ChellSliderProps, IChellSliderState>}
 */
var ChellSlider = /** @class */ (function (_super) {
    __extends(ChellSlider, _super);
    function ChellSlider(props) {
        var _this = _super.call(this, props) || this;
        /**
         * Updates the state of the slider after user commits to change. If applicable, invokes appropriate callback.
         */
        _this.onAfterChange = function (cb) { return function (value) {
            if (cb) {
                cb(value);
            }
            _this.setState({
                value: value,
            });
        }; };
        /**
         * Updates the state of the slider as the user moves the slider around but before selection is committed.
         * If applicable, invokes appropriate callback as well.
         */
        _this.onChange = function (cb) { return function (value) {
            if (cb) {
                cb(value);
            }
            _this.setState({
                value: value,
            });
        }; };
        _this.onReset = function () {
            _this.onChange(_this.props.onChange)(_this.state.defaultValue);
            // this.onAfterChange(this.props.onAfterChange)(this.state.defaultValue);
        };
        _this.state = {
            defaultValue: props.defaultValue ? props.defaultValue : props.value,
            value: props.value,
        };
        return _this;
    }
    ChellSlider.prototype.componentDidUpdate = function (prevProps) {
        var _a = this.props, defaultValue = _a.defaultValue, value = _a.value;
        if (value && value !== prevProps.value) {
            this.setState({
                value: value,
            });
        }
        var candidateDefaultValue = defaultValue ? defaultValue : value;
        if (this.state.defaultValue === -1 && candidateDefaultValue !== this.state.defaultValue) {
            this.setState({
                defaultValue: candidateDefaultValue,
            });
        }
    };
    ChellSlider.prototype.render = function () {
        var _a = this.props, className = _a.className, value = _a.value, hideLabelValue = _a.hideLabelValue, max = _a.max, min = _a.min, label = _a.label, onAfterChange = _a.onAfterChange, onChange = _a.onChange, style = _a.style, remainingProps = __rest(_a, ["className", "value", "hideLabelValue", "max", "min", "label", "onAfterChange", "onChange", "style"]);
        return (React.createElement(semantic_ui_react_1.Grid, { columns: 'equal', style: style, textAlign: 'left' },
            React.createElement(semantic_ui_react_1.Grid.Column, { className: className },
                !hideLabelValue && React.createElement("p", null, label + ": " + this.state.value),
                React.createElement(rc_slider_1.default, __assign({ max: max, min: min, onAfterChange: this.onAfterChange(onAfterChange), onChange: this.onChange(onChange), value: value }, remainingProps))),
            React.createElement(semantic_ui_react_1.Grid.Column, { verticalAlign: 'middle', width: 2 },
                React.createElement(semantic_ui_react_1.Button, { icon: 'undo', onClick: this.onReset, size: 'small' }))));
    };
    return ChellSlider;
}(React.Component));
exports.ChellSlider = ChellSlider;


/***/ }),

/***/ "./src/component/widget/ChellTooltip.tsx":
/*!***********************************************!*\
  !*** ./src/component/widget/ChellTooltip.tsx ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var React = __webpack_require__(/*! react */ "./node_modules/react/index.js");
var defaultStyle = {
    backgroundColor: 'rgba(0, 244, 0, 0.6)',
    color: 'lightgrey',
    display: 'block',
    fontFamily: 'sans-serif',
    padding: '0.5em',
    pointerEvents: 'none',
    position: 'absolute',
    zIndex: 10,
};
exports.initialTooltipState = {
    show: true,
    timer: undefined,
};
var ChellTooltip = /** @class */ (function (_super) {
    __extends(ChellTooltip, _super);
    function ChellTooltip(props) {
        var _this = _super.call(this, props) || this;
        _this.state = exports.initialTooltipState;
        return _this;
    }
    ChellTooltip.prototype.componentDidUpdate = function (nextProps) {
        var _this = this;
        var _a = nextProps.timeout, timeout = _a === void 0 ? 0 : _a;
        if (!this.state.timer && timeout > 0) {
            var timer = setTimeout(function () {
                _this.setState({ show: false });
            }, timeout);
            this.setState({
                timer: timer,
            });
        }
    };
    ChellTooltip.prototype.componentWillUnmount = function () {
        var timer = this.state.timer;
        if (timer) {
            clearTimeout(timer);
        }
    };
    ChellTooltip.prototype.render = function () {
        var _a = this.props, message = _a.message, _b = _a.style, style = _b === void 0 ? defaultStyle : _b;
        var show = this.state.show;
        return (show && (React.createElement("div", { style: style, className: "ChellTooltip" }, message)));
    };
    return ChellTooltip;
}(React.Component));
exports.ChellTooltip = ChellTooltip;


/***/ }),

/***/ "./src/component/widget/ComponentCard.tsx":
/*!************************************************!*\
  !*** ./src/component/widget/ComponentCard.tsx ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", { value: true });
var React = __webpack_require__(/*! react */ "./node_modules/react/index.js");
var ReactDOM = __webpack_require__(/*! react-dom */ "./node_modules/react-dom/index.js");
var semantic_ui_react_1 = __webpack_require__(/*! semantic-ui-react */ "./node_modules/semantic-ui-react/dist/es/index.js");
var ComponentCard = /** @class */ (function (_super) {
    __extends(ComponentCard, _super);
    function ComponentCard(props) {
        var _this = _super.call(this, props) || this;
        _this.cardRef = null;
        _this.renderTopMenu = function (height) { return (React.createElement(semantic_ui_react_1.Menu, { secondary: true, style: { margin: 0, height: height } },
            React.createElement(semantic_ui_react_1.Menu.Item, { position: 'left', fitted: 'horizontally', style: { margin: 0 } },
                React.createElement("img", { alt: 'component icon', src: _this.props.iconSrc, style: { height: '32px', padding: '2px', width: '32px' } }),
                _this.props.componentName),
            React.createElement(semantic_ui_react_1.Menu.Item, { position: 'right', fitted: 'horizontally', style: { margin: 0 } },
                React.createElement(semantic_ui_react_1.Icon, { name: _this.state.isFullPage ? 'compress' : 'expand arrows alternate', onClick: _this.onFullPageToggle }),
                _this.props.showSettings && React.createElement(semantic_ui_react_1.Icon, { name: 'settings' })))); };
        _this.onFullPageToggle = function () {
            _this.setState({
                isFullPage: !_this.state.isFullPage,
            });
        };
        _this.state = {
            framedStyle: {
                transformOrigin: 'top left',
            },
            isFullPage: props.isFullPage,
        };
        return _this;
    }
    ComponentCard.prototype.componentDidMount = function () {
        var _this = this;
        if (this.props.isFramedComponent) {
            window.onresize = function () {
                if (_this.props.isFramedComponent) {
                    _this.resizeFramedComponent();
                }
            };
            this.resizeFramedComponent();
        }
    };
    ComponentCard.prototype.componentDidUpdate = function (prevProps, prevState) {
        var isFullPage = this.state.isFullPage;
        if (isFullPage !== prevState.isFullPage) {
            this.resizeFramedComponent();
        }
    };
    ComponentCard.prototype.render = function () {
        var _this = this;
        var _a = this.props, children = _a.children, headerHeight = _a.headerHeight, height = _a.height, isFramedComponent = _a.isFramedComponent, width = _a.width;
        var _b = this.state, isFullPage = _b.isFullPage, framedStyle = _b.framedStyle;
        var expandedStyle = {
            bottom: 0,
            height: 'calc(100vmin)',
            left: 0,
            padding: '5px',
            position: 'fixed',
            right: 0,
            width: 'calc(100vmin)',
            zIndex: 10000,
        };
        var cardStyle = __assign({ maxWidth: 'unset', padding: '0 0 5px 5px' }, (isFullPage ? __assign({}, expandedStyle) : { height: height, width: width }));
        var dimmedBackground = document.getElementById('chell-dimmed-background');
        if (isFullPage && dimmedBackground) {
            dimmedBackground.style.display = 'block';
        }
        else if (dimmedBackground) {
            dimmedBackground.style.display = 'none';
        }
        return (React.createElement(semantic_ui_react_1.Card, { centered: true, className: 'chell-component-card', ref: function (ref) { return (_this.cardRef = ref); }, style: cardStyle },
            this.renderTopMenu(headerHeight),
            isFramedComponent ? React.createElement("div", { style: framedStyle }, children) : children));
    };
    ComponentCard.prototype.resizeFramedComponent = function () {
        var _a = this.props, frameHeight = _a.frameHeight, frameWidth = _a.frameWidth, headerHeight = _a.headerHeight;
        var _b = this.state, framedStyle = _b.framedStyle, isFullPage = _b.isFullPage;
        if (this.cardRef) {
            var iFrameNodeRef = ReactDOM.findDOMNode(this.cardRef);
            var iFrameNodeStyle = iFrameNodeRef ? window.getComputedStyle(iFrameNodeRef) : null;
            if (iFrameNodeStyle && iFrameNodeStyle.width && iFrameNodeStyle.height) {
                document.body.style.overflowY = isFullPage ? 'hidden' : 'auto';
                var refHeight = parseInt(iFrameNodeStyle.height, 10) - 18;
                var refWidth = parseInt(iFrameNodeStyle.width, 10) - 10;
                this.setState({
                    framedStyle: __assign({}, framedStyle, { transform: "scale(calc(" + refWidth + "/" + frameWidth + "),calc((" + refHeight + " - " + headerHeight + ")/" + frameHeight + "))" }),
                });
            }
        }
    };
    ComponentCard.defaultProps = {
        frameHeight: 0,
        frameWidth: 0,
        headerHeight: 32,
        height: '525px',
        iconSrc: 'assets/icons/spring-icon.png',
        isFramedComponent: false,
        isFullPage: false,
        padding: 0,
        showSettings: false,
        width: '525px',
    };
    return ComponentCard;
}(React.Component));
exports.ComponentCard = ComponentCard;


/***/ }),

/***/ "./src/component/widget/SettingsPanel.tsx":
/*!************************************************!*\
  !*** ./src/component/widget/SettingsPanel.tsx ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", { value: true });
var React = __webpack_require__(/*! react */ "./node_modules/react/index.js");
var semantic_ui_react_1 = __webpack_require__(/*! semantic-ui-react */ "./node_modules/semantic-ui-react/dist/es/index.js");
var component_1 = __webpack_require__(/*! ~chell-viz~/component */ "./src/component/index.ts");
var data_1 = __webpack_require__(/*! ~chell-viz~/data */ "./src/data/index.ts");
var SettingsPanel = /** @class */ (function (_super) {
    __extends(SettingsPanel, _super);
    function SettingsPanel(props) {
        var _this = _super.call(this, props) || this;
        _this.panel = null;
        _this.onButtonClick = function (e) {
            _this.setState({
                visible: !_this.state.visible,
            });
        };
        _this.renderSettingsButton = function () { return (React.createElement(semantic_ui_react_1.Button, { basic: true, floated: 'right', icon: 'settings', onClick: _this.onButtonClick })); };
        _this.state = {
            visible: false,
        };
        return _this;
    }
    SettingsPanel.prototype.componentDidUpdate = function (prevProps, prevState) {
        var _this = this;
        var visible = this.state.visible;
        if (visible && prevState.visible !== visible) {
            window.addEventListener('click', function (e) {
                if (_this.panel) {
                    var panelRect = _this.panel.getBoundingClientRect();
                    var x = e.x, y = e.y;
                    var isIntersected = x >= panelRect.left && x <= panelRect.right && y >= panelRect.top && y <= panelRect.bottom;
                    if (!isIntersected) {
                        _this.hideSettingsPanel();
                        window.removeEventListener('click', _this.hideSettingsPanel);
                    }
                }
            });
        }
        else {
            window.removeEventListener('click', function (e) { return _this.hideSettingsPanel; });
        }
    };
    SettingsPanel.prototype.render = function () {
        var _this = this;
        var _a = this.props, children = _a.children, configurations = _a.configurations, inverted = _a.inverted, opacity = _a.opacity, showConfigurations = _a.showConfigurations, width = _a.width;
        var visible = this.state.visible;
        return (React.createElement("div", { ref: function (node) { return (_this.panel = node ? node : null); } },
            React.createElement(semantic_ui_react_1.Grid, { columns: 1 },
                showConfigurations && React.createElement(semantic_ui_react_1.Grid.Column, null, this.renderSettingsButton()),
                React.createElement(semantic_ui_react_1.Sidebar.Pushable, { style: { width: width } },
                    React.createElement(semantic_ui_react_1.Sidebar, { as: semantic_ui_react_1.Menu, animation: 'overlay', inverted: inverted, style: { width: width, opacity: opacity }, vertical: true, visible: visible }, this.renderConfigurations(configurations)),
                    React.createElement(semantic_ui_react_1.Sidebar.Pusher, null, children)))));
    };
    SettingsPanel.prototype.renderConfigurations = function (configurations) {
        var _this = this;
        return (React.createElement(semantic_ui_react_1.Grid, { centered: true }, configurations.map(function (config, index) {
            var id = config.id
                ? config.id
                : config.name
                    .toLowerCase()
                    .split(' ')
                    .join('-') + "-" + index;
            switch (config.type) {
                case data_1.CONFIGURATION_COMPONENT_TYPE.BUTTON:
                    return React.createElement(semantic_ui_react_1.Grid.Row, { key: id }, _this.renderConfigurationButton(config, id));
                case data_1.CONFIGURATION_COMPONENT_TYPE.LABEL:
                    return React.createElement(semantic_ui_react_1.Grid.Row, { key: id }, _this.renderConfigurationLabel(config, id));
                case data_1.CONFIGURATION_COMPONENT_TYPE.RADIO:
                    return React.createElement(semantic_ui_react_1.Grid.Row, { key: id }, _this.renderConfigurationRadioButton(config, id));
                case data_1.CONFIGURATION_COMPONENT_TYPE.SLIDER:
                    return React.createElement(semantic_ui_react_1.Grid.Row, { key: id }, _this.renderConfigurationSlider(config, id));
                default: {
                    return React.createElement(semantic_ui_react_1.Grid.Row, { key: id }, "configuration for " + id);
                }
            }
        })));
    };
    SettingsPanel.prototype.renderConfigurationButton = function (config, id) {
        return (React.createElement(semantic_ui_react_1.Button, { compact: true, id: id, onClick: config.onClick, style: __assign({}, config.style) },
            config.icon && React.createElement(semantic_ui_react_1.Icon, { name: config.icon }),
            config.name));
    };
    SettingsPanel.prototype.renderConfigurationLabel = function (config, id) {
        return (React.createElement(semantic_ui_react_1.Label, { basic: true, id: id, style: __assign({}, config.style), color: 'orange' }, config.name));
    };
    SettingsPanel.prototype.renderConfigurationRadioButton = function (config, id) {
        return (React.createElement(component_1.ChellRadioGroup, { id: id, options: config.options, onChange: config.onChange, style: __assign({ color: 'white' }, config.style), title: config.name }));
    };
    SettingsPanel.prototype.renderConfigurationSlider = function (config, id) {
        return (React.createElement(component_1.ChellSlider, { className: id, label: config.name, max: config.values.max, min: config.values.min, onAfterChange: config.onAfterChange, onChange: config.onChange, style: __assign({ color: 'white', padding: '0 25px', width: '95%' }, config.style), value: config.values.current }));
    };
    SettingsPanel.prototype.hideSettingsPanel = function () {
        this.setState({
            visible: false,
        });
    };
    SettingsPanel.defaultProps = {
        configurations: new Array(),
        direction: 'left',
        inverted: true,
        opacity: 0.6,
        showConfigurations: true,
        width: '100%',
    };
    return SettingsPanel;
}(React.Component));
exports.SettingsPanel = SettingsPanel;


/***/ }),

/***/ "./src/component/widget/index.ts":
/*!***************************************!*\
  !*** ./src/component/widget/index.ts ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./CategorySelector */ "./src/component/widget/CategorySelector.tsx"));
__export(__webpack_require__(/*! ./ChellRadioGroup */ "./src/component/widget/ChellRadioGroup.tsx"));
__export(__webpack_require__(/*! ./ChellSlider */ "./src/component/widget/ChellSlider.tsx"));
__export(__webpack_require__(/*! ./ChellTooltip */ "./src/component/widget/ChellTooltip.tsx"));
__export(__webpack_require__(/*! ./ComponentCard */ "./src/component/widget/ComponentCard.tsx"));
__export(__webpack_require__(/*! ./SettingsPanel */ "./src/component/widget/SettingsPanel.tsx"));


/***/ }),

/***/ "./src/container/AnatomogramContainer.tsx":
/*!************************************************!*\
  !*** ./src/container/AnatomogramContainer.tsx ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", { value: true });
// tslint:disable-next-line:import-name
var anatomogram_1 = __webpack_require__(/*! anatomogram */ "./node_modules/anatomogram/lib/index.js");
var React = __webpack_require__(/*! react */ "./node_modules/react/index.js");
var immutable_1 = __webpack_require__(/*! immutable */ "./node_modules/immutable/dist/immutable.js");
var context_1 = __webpack_require__(/*! ~chell-viz~/context */ "./src/context/index.ts");
exports.springToAnatomogramMapping = {
    homo_sapiens: {
        P11A: 'UBERON_0000178',
        P11B: 'UBERON_0001155',
        P12A: 'UBERON_0000955',
        P9A: 'UBERON_0000977',
    },
    mus_musculus: {
        Bladder: 'UBERON_0001255',
        Heart: 'UBERON_0000948',
        Kidney: 'UBERON_0002113',
        Limb: 'UBERON_0014892',
        Liver: 'UBERON_0002107',
        Lung: 'UBERON_0002048',
        Mammary: 'UBERON_0001911',
        Marrow: 'UBERON_0002371',
        Muscle: 'UBERON_0014892',
        Spleen: 'UBERON_0002106',
        Thymus: 'UBERON_0002370',
        Tongue: 'UBERON_0001723',
        Trachea: 'UBERON_0003126',
    },
};
exports.anatomogramToSpringMapping = {
    homo_sapiens: {
        UBERON_0000178: ['P11A'],
        UBERON_0000955: ['P12A'],
        UBERON_0000977: ['P9A'],
        UBERON_0001155: ['P11B'],
    },
    mus_musculus: {
        UBERON_0000948: ['Heart_and_Aorta', 'Heart_and_Aorta-10X_P7_4'],
        UBERON_0001255: ['Bladder', 'Bladder-10X_P4_3', 'Bladder-10X_P4_4', 'Bladder-10X_P7_7'],
        UBERON_0001723: ['Tongue', 'Tongue-10X_P4_0', 'Tongue-10X_P4_1', 'Tongue-10X_P7_10'],
        UBERON_0001911: ['Mammary_Gland', 'Mammary_Gland-10X_P7_12', 'Mammary_Gland-10X_P7_13'],
        UBERON_0002048: ['Lung', 'Lung-10X_P7_8', 'Lung-10X_P7_9', 'Lung-10X_P8_12', 'Lung-10X_P8_13'],
        UBERON_0002106: ['Spleen', 'Spleen-10X_P4_7', 'Spleen-10X_P7_6'],
        UBERON_0002107: ['Liver', 'Liver-10X_P4_2', 'Liver-10X_P7_0', 'Liver-10X_P7_1'],
        UBERON_0002113: ['Kidney', 'Kidney-10X_P4_5', 'Kidney-10X_P4_6', 'Kidney-10X_P7_5'],
        UBERON_0002370: ['Thymus', 'Thymus-10X_P7_11'],
        UBERON_0002371: ['Marrow', 'Marrow-10X_P7_2', 'Marrow-10X_P7_3'],
        UBERON_0003126: ['Trachea', 'Trachea-10X_P8_14', 'Trachea-10X_P8_15'],
        UBERON_0014892: ['Limb_Muscle', 'Limb_Muscle-10X_P7_14', 'Limb_Muscle-10X_P7_15'],
    },
};
var AnatomogramContainerClass = /** @class */ (function (_super) {
    __extends(AnatomogramContainerClass, _super);
    function AnatomogramContainerClass(props) {
        var _this = _super.call(this, props) || this;
        _this.onClick = function (id) {
            var _a = _this.props, species = _a.species, springContext = _a.springContext;
            var labels = exports.anatomogramToSpringMapping[species][id];
            springContext.toggleLabels(labels);
        };
        _this.onMouseOut = function (id) {
            return;
        };
        _this.onMouseOver = function (id) {
            return;
        };
        _this.parseCategory = function (category) {
            var splitCategories = category.split(/-|_/);
            return splitCategories[0];
        };
        _this.state = {
            ids: Object.keys(exports.anatomogramToSpringMapping[props.species]),
            selectIds: immutable_1.Set(),
        };
        return _this;
    }
    AnatomogramContainerClass.prototype.componentDidUpdate = function (prevProps) {
        var _this = this;
        var springContext = this.props.springContext;
        if (!springContext.selectedLabels.equals(prevProps.springContext.selectedLabels)) {
            var selectIds = springContext.selectedLabels
                .toArray()
                .filter(function (label) { return exports.springToAnatomogramMapping[_this.props.species][_this.parseCategory(label)] !== undefined; })
                .map(function (label) { return exports.springToAnatomogramMapping[_this.props.species][_this.parseCategory(label)]; });
            this.setState({
                selectIds: immutable_1.Set(selectIds),
            });
        }
    };
    AnatomogramContainerClass.prototype.render = function () {
        var _a = this.state, ids = _a.ids, selectIds = _a.selectIds;
        return (React.createElement("div", { className: 'anatomogram-container', style: { height: '100%' } },
            React.createElement(anatomogram_1.default, { atlasUrl: "", highlightColour: 'yellow', onClick: this.onClick, onMouseOut: this.onMouseOut, onMouseOver: this.onMouseOver, selectColour: 'ffaa00', selectIds: selectIds.toArray(), showIds: ids, species: this.props.species, selectedView: this.props.species === 'mus_musculus' ? 'female' : 'male' })));
    };
    AnatomogramContainerClass.defaultProps = {
        height: '300px',
        springContext: __assign({}, context_1.initialSpringContext),
        style: {},
        width: '400px',
    };
    AnatomogramContainerClass.displayName = 'Anatomogram';
    return AnatomogramContainerClass;
}(React.Component));
exports.AnatomogramContainerClass = AnatomogramContainerClass;
exports.AnatomogramContainer = function (props) { return (React.createElement(context_1.SpringContext.Consumer, null, function (springContext) { return React.createElement(AnatomogramContainerClass, __assign({}, props, { springContext: springContext })); })); };


/***/ }),

/***/ "./src/container/ProteinFeatureViewer.tsx":
/*!************************************************!*\
  !*** ./src/container/ProteinFeatureViewer.tsx ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
var React = __webpack_require__(/*! react */ "./node_modules/react/index.js");
var semantic_ui_react_1 = __webpack_require__(/*! semantic-ui-react */ "./node_modules/semantic-ui-react/dist/es/index.js");
var component_1 = __webpack_require__(/*! ~chell-viz~/component */ "./src/component/index.ts");
var data_1 = __webpack_require__(/*! ~chell-viz~/data */ "./src/data/index.ts");
var helper_1 = __webpack_require__(/*! ~chell-viz~/helper */ "./src/helper/index.ts");
var ProteinFeatureViewer = /** @class */ (function (_super) {
    __extends(ProteinFeatureViewer, _super);
    function ProteinFeatureViewer(props) {
        var _this = _super.call(this, props) || this;
        _this.onProteinInputChange = function (event, data) {
            _this.setState({
                proteinId: data.value,
            });
        };
        _this.onProteinInputSubmit = function (event, data) { return __awaiter(_this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.deriveProteinData()];
                    case 1:
                        _a.sent();
                        return [2 /*return*/];
                }
            });
        }); };
        _this.onShowGroupedChange = function (event, data) {
            _this.setState({
                showGrouped: data.checked !== undefined ? data.checked : _this.state.showGrouped,
            });
        };
        _this.renderAnnotationText = function (proteinId, index) {
            var _a = _this.state, domainData = _a.domainData, protein = _a.protein;
            var pFamIds = protein
                ? protein.dbReferences
                    .filter(function (dbRef) { return dbRef.type === 'Pfam'; })
                    .filter(function (pFamRef) {
                    var properties = pFamRef.properties;
                    var entryName = properties ? properties['entry name'] : null;
                    return entryName && (entryName === proteinId || entryName.localeCompare(proteinId + "-like " + index));
                })
                : [];
            return pFamIds.length >= 1
                ? proteinId + ": " + proteinId + " domain (" + domainData[index].start + " - " + domainData[index].end + ")<br /><a href=\"http://pfam.xfam.org/family/" + pFamIds[0].id + "\">PFAM</a> <a href=\"http://mutationaligner.org/domains/" + pFamIds[0].id + "\">Mutagen Aligner</a>"
                : '';
        };
        _this.state = {
            data: [],
            domainData: [],
            proteinId: props.initialProteinId,
            showGrouped: true,
        };
        return _this;
    }
    ProteinFeatureViewer.prototype.componentDidMount = function () {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.deriveProteinData()];
                    case 1:
                        _a.sent();
                        return [2 /*return*/];
                }
            });
        });
    };
    ProteinFeatureViewer.prototype.render = function () {
        var _a = this.state, domainData = _a.domainData, protein = _a.protein, proteinId = _a.proteinId, showGrouped = _a.showGrouped;
        return (React.createElement("div", { className: 'protein-feature-viewer' },
            React.createElement(semantic_ui_react_1.GridRow, { centered: true, stretched: false },
                React.createElement(semantic_ui_react_1.GridColumn, null,
                    React.createElement(component_1.FeatureViewer, { data: domainData, getTextForHover: this.renderAnnotationText, title: protein ? protein.id : '', showGrouped: showGrouped })),
                React.createElement(semantic_ui_react_1.GridColumn, null,
                    React.createElement(semantic_ui_react_1.Form, { onSubmit: this.onProteinInputSubmit },
                        React.createElement(semantic_ui_react_1.Form.Input, { onChange: this.onProteinInputChange, value: proteinId, fluid: false, width: 'three' }),
                        React.createElement(semantic_ui_react_1.Form.Button, null, "Submit Protein ID"),
                        React.createElement(semantic_ui_react_1.Form.Checkbox, { defaultChecked: true, label: 'Show grouped?', onChange: this.onShowGroupedChange }))))));
    };
    ProteinFeatureViewer.prototype.deriveProteinData = function () {
        return __awaiter(this, void 0, void 0, function () {
            var result, protein, domains, colorMapper_1, e_1;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        _a.trys.push([0, 4, , 5]);
                        return [4 /*yield*/, fetch("https://www.ebi.ac.uk/proteins/api/proteins/" + this.state.proteinId)];
                    case 1:
                        result = _a.sent();
                        if (!(result && result.ok)) return [3 /*break*/, 3];
                        return [4 /*yield*/, result.json()];
                    case 2:
                        protein = (_a.sent());
                        domains = protein.features.filter(function (feature) { return feature.type === 'DOMAIN'; });
                        colorMapper_1 = new helper_1.ColorMapper();
                        this.setState({
                            domainData: domains.map(function (domain, index) {
                                var begin = domain.begin, _a = domain.description, description = _a === void 0 ? '' : _a, end = domain.end;
                                // This matches domains that do and do not have other of the same domain in the protein.
                                var domainName = description.split('-like')[0];
                                return new data_1.TintedChell1DSection(domainName, begin ? Number.parseInt(begin, 10) : -1, end ? Number.parseInt(end, 10) : -1, colorMapper_1.getColorFor(domainName));
                            }),
                            protein: protein,
                        });
                        _a.label = 3;
                    case 3: return [3 /*break*/, 5];
                    case 4:
                        e_1 = _a.sent();
                        console.log(e_1);
                        return [3 /*break*/, 5];
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    ProteinFeatureViewer.defaultProps = {
        // initialProteinId: 'Q13485',
        initialProteinId: 'Q9NYJ7',
    };
    return ProteinFeatureViewer;
}(React.Component));
exports.ProteinFeatureViewer = ProteinFeatureViewer;


/***/ }),

/***/ "./src/container/SiteHeader.tsx":
/*!**************************************!*\
  !*** ./src/container/SiteHeader.tsx ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var React = __webpack_require__(/*! react */ "./node_modules/react/index.js");
var react_router_dom_1 = __webpack_require__(/*! react-router-dom */ "./node_modules/react-router-dom/es/index.js");
var semantic_ui_react_1 = __webpack_require__(/*! semantic-ui-react */ "./node_modules/semantic-ui-react/dist/es/index.js");
var data_1 = __webpack_require__(/*! ~chell-viz~/data */ "./src/data/index.ts");
var SiteHeader = /** @class */ (function (_super) {
    __extends(SiteHeader, _super);
    function SiteHeader(props) {
        var _this = _super.call(this, props) || this;
        _this.renderNavMenu = function () {
            return (React.createElement(semantic_ui_react_1.Menu, { defaultActiveIndex: -1, secondary: true },
                React.createElement(semantic_ui_react_1.Menu.Item, { key: 'datasets' },
                    React.createElement(react_router_dom_1.Link, { to: '/dataset', style: { color: 'black', fontSize: '18px' } }, "datasets")),
                React.createElement(semantic_ui_react_1.Menu.Item, { key: 'visualizations' },
                    React.createElement(react_router_dom_1.Link, { to: '/visualizations', style: { color: 'black', fontSize: '18px' } }, "visualizations")),
                React.createElement(semantic_ui_react_1.Menu.Item, { key: 'stories' },
                    React.createElement(react_router_dom_1.Link, { to: '/stories', style: { color: 'black', fontSize: '18px' } }, "stories"))));
        };
        _this.onMouseClick = function (e) {
            return;
        };
        _this.renderVisualizationsMenu = function () {
            return (React.createElement(semantic_ui_react_1.Container, { fluid: true },
                React.createElement(semantic_ui_react_1.Header, null, "Visualization applications"),
                React.createElement(semantic_ui_react_1.Divider, null),
                "dataset",
                React.createElement(semantic_ui_react_1.Divider, null),
                React.createElement(semantic_ui_react_1.Search, { defaultValue: 'search', icon: false }),
                React.createElement(semantic_ui_react_1.Table, { basic: 'very' },
                    React.createElement(semantic_ui_react_1.Table.Header, null,
                        React.createElement(semantic_ui_react_1.Table.Row, null,
                            React.createElement(semantic_ui_react_1.Table.HeaderCell, null, "Select"),
                            React.createElement(semantic_ui_react_1.Table.HeaderCell, null, "Name"),
                            React.createElement(semantic_ui_react_1.Table.HeaderCell, null, "Author(s)"),
                            React.createElement(semantic_ui_react_1.Table.HeaderCell, null, "Last updated")),
                        React.createElement(semantic_ui_react_1.Table.Row, { cells: [
                                { key: 'Select', content: React.createElement(semantic_ui_react_1.Checkbox, { checked: true }) },
                                { key: 'Name', content: 'SPRING' },
                                { key: 'Author', content: 'Weinreb, Wolock, Klein' },
                                { key: 'Last Updated', content: 'Nov 13, 2018' },
                            ] }),
                        React.createElement(semantic_ui_react_1.Table.Row, { cells: [
                                { key: 'Select', content: React.createElement(semantic_ui_react_1.Checkbox, { checked: false }) },
                                { key: 'Name', content: 'tSNE-Tensor' },
                                { key: 'Author', content: '??' },
                                { key: 'Last Updated', content: 'Nov 13, 2018' },
                            ], style: { border: 'none' } }),
                        React.createElement(semantic_ui_react_1.Table.Row, { cells: [
                                { key: 'Select', content: React.createElement(semantic_ui_react_1.Checkbox, { checked: false }) },
                                { key: 'Name', content: 'Anatomogram' },
                                { key: 'Author', content: '??' },
                                { key: 'Last Updated', content: 'Nov 13, 2018' },
                            ], style: { border: 'none' } })))));
        };
        _this.renderDatasetMenu = function () {
            var visualizations = [];
            if (_this.props.location) {
                var params = new URLSearchParams(_this.props.location.search);
                visualizations = params.getAll('viz').map(function (viz) { return "viz=" + viz; });
            }
            var datasets = ['hpc/full', 'hpc_sf2/full', 'tabula_muris/10k', 'tabula_muris/full', 'tabula_muris/lung'];
            var panes = [
                {
                    menuItem: 'human cell atlas',
                    render: function () { return (React.createElement(semantic_ui_react_1.Tab.Pane, null,
                        React.createElement(semantic_ui_react_1.Container, { fluid: true },
                            React.createElement(semantic_ui_react_1.Table, { basic: 'very' },
                                React.createElement(semantic_ui_react_1.Table.Header, null,
                                    React.createElement(semantic_ui_react_1.Table.Row, null,
                                        React.createElement(semantic_ui_react_1.Table.HeaderCell, null,
                                            React.createElement(semantic_ui_react_1.Dropdown, { placeholder: 'search', selection: true })),
                                        React.createElement(semantic_ui_react_1.Table.HeaderCell, null,
                                            React.createElement(semantic_ui_react_1.Dropdown, { placeholder: 'organ', selection: true })),
                                        React.createElement(semantic_ui_react_1.Table.HeaderCell, null,
                                            React.createElement(semantic_ui_react_1.Dropdown, { placeholder: 'method', selection: true })))))))); },
                },
                {
                    menuItem: 'HCA Dynamics public',
                    render: function () { return (React.createElement(semantic_ui_react_1.List, null, datasets.map(function (dataset, index) { return _this.renderDatasetLinkItem(dataset, index, visualizations); }))); },
                },
                {
                    menuItem: 'upload from computer',
                    render: function () { return React.createElement(semantic_ui_react_1.Tab.Pane, null, "Coming soon!"); },
                },
            ];
            return (React.createElement(semantic_ui_react_1.Container, { fluid: true },
                React.createElement(semantic_ui_react_1.Header, null, "datasets"),
                React.createElement(semantic_ui_react_1.Divider, null),
                React.createElement(semantic_ui_react_1.Tab, { defaultActiveIndex: 1, menu: { secondary: true, pointing: true }, panes: panes })));
        };
        _this.renderDatasetLinkItem = function (datasetName, index, visualizations) { return (React.createElement(semantic_ui_react_1.List.Item, { key: "dataset-link-" + index },
            React.createElement(react_router_dom_1.Link, { onClick: _this.closeModal, to: { pathname: '/dataset', search: "?name=" + datasetName + "&" + visualizations.join('&') } }, datasetName))); };
        _this.closeModal = function () {
            _this.setState({ isModalOpen: false });
        };
        _this.openModal = function (event, data) {
            _this.setState({ isModalOpen: true });
        };
        _this.state = {
            currentPageName: null,
            isModalOpen: false,
        };
        return _this;
    }
    SiteHeader.prototype.componentDidMount = function () {
        window.addEventListener('click', this.onMouseClick);
        if (this.props.location) {
            this.handleQueryParams(this.props.location.search);
        }
    };
    SiteHeader.prototype.componentDidUpdate = function (prevProps) {
        if (this.props.location && this.props.location !== prevProps.location) {
            this.handleQueryParams(this.props.location.search);
        }
    };
    SiteHeader.prototype.componentWillUnmount = function () {
        window.removeEventListener('click', this.onMouseClick);
    };
    SiteHeader.prototype.render = function () {
        return (React.createElement(semantic_ui_react_1.Header, null,
            React.createElement(semantic_ui_react_1.Menu, { secondary: true, borderless: true, fluid: true, style: { maxHeight: '40px', padding: '20px 0 0 0' } },
                React.createElement(semantic_ui_react_1.Menu.Item, { fitted: 'vertically', position: 'left' },
                    React.createElement(react_router_dom_1.Link, { to: '/' },
                        React.createElement("img", { alt: 'hca-dynamics-icon', src: 'assets/icons/bio-blocks-icon-2x.png', style: { height: '32px', width: '32px' } }),
                        React.createElement("span", { style: { color: 'black', fontSize: '32px', fontWeight: 'bold' } }, "HCA Dynamics"))),
                this.renderNavMenu(),
                React.createElement(semantic_ui_react_1.Menu.Item, { position: 'right' },
                    React.createElement(semantic_ui_react_1.Input, { icon: 'search', size: 'massive', transparent: true }))),
            this.renderNavBreadcrumb(),
            this.renderCurrentData()));
    };
    SiteHeader.prototype.renderCurrentData = function () {
        var location = this.props.location;
        if (location) {
            var params = new URLSearchParams(location.search);
            var visualizations = params.getAll('viz');
            // tslint:disable-next-line:no-backbone-get-set-outside-model
            var name_1 = params.get('name');
            return (name_1 &&
                data_1.DatasetData[name_1] && (React.createElement(semantic_ui_react_1.Grid, { centered: true, padded: true, textAlign: 'center' },
                React.createElement(semantic_ui_react_1.Grid.Row, { textAlign: 'left' },
                    React.createElement("p", null, "Selected visualization(s): ",
                        React.createElement("span", { style: { fontWeight: 'normal' } }, visualizations.map(function (viz) { return data_1.VizData[viz].name; }).join(', ')),
                        React.createElement("br", null),
                        name_1 && "Selected dataset: ",
                        React.createElement("span", { style: { fontWeight: 'normal' } }, data_1.DatasetData[name_1].fullName + " (" + name_1 + ")"))))));
        }
        else {
            return null;
        }
    };
    SiteHeader.prototype.renderNavBreadcrumb = function () {
        return (React.createElement(semantic_ui_react_1.Breadcrumb, { style: { padding: '0 0 0 40px' } },
            React.createElement(semantic_ui_react_1.Breadcrumb.Section, null,
                React.createElement(react_router_dom_1.Link, { to: '/' }, "home")),
            this.props.location &&
                this.props.location.pathname
                    .split('/')
                    .filter(function (candidatePath) { return candidatePath.length >= 1; })
                    .map(function (path, index) { return (React.createElement(React.Fragment, { key: "breadcrumb-" + index },
                    React.createElement(semantic_ui_react_1.Breadcrumb.Divider, { icon: 'right angle' }),
                    React.createElement(semantic_ui_react_1.Breadcrumb.Section, null,
                        React.createElement(react_router_dom_1.Link, { to: "/" + path }, path)))); }),
            this.state.currentPageName && (React.createElement(React.Fragment, null,
                React.createElement(semantic_ui_react_1.Breadcrumb.Divider, { icon: 'right angle' }),
                React.createElement(semantic_ui_react_1.Breadcrumb.Section, null, this.state.currentPageName)))));
    };
    SiteHeader.prototype.handleQueryParams = function (search) {
        var params = new URLSearchParams(search);
        var visualizations = params.getAll('viz');
        // tslint:disable-next-line:no-backbone-get-set-outside-model
        var name = params.get('name');
        if (visualizations.length >= 1 && !name) {
            this.setState({
                currentPageName: name,
                isModalOpen: true,
            });
        }
        else {
            this.setState({
                currentPageName: name,
                isModalOpen: false,
            });
        }
    };
    return SiteHeader;
}(React.Component));
exports.SiteHeader = SiteHeader;


/***/ }),

/***/ "./src/container/SpringContainer.tsx":
/*!*******************************************!*\
  !*** ./src/container/SpringContainer.tsx ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", { value: true });
var React = __webpack_require__(/*! react */ "./node_modules/react/index.js");
// tslint:disable:import-name match-default-export-name
var react_iframe_comm_1 = __webpack_require__(/*! react-iframe-comm */ "./node_modules/react-iframe-comm/dist/IframeComm.js");
// tslint:enable:import-name match-default-export-name
var component_1 = __webpack_require__(/*! ~chell-viz~/component */ "./src/component/index.ts");
var context_1 = __webpack_require__(/*! ~chell-viz~/context */ "./src/context/index.ts");
var SpringContainerClass = /** @class */ (function (_super) {
    __extends(SpringContainerClass, _super);
    function SpringContainerClass(props) {
        var _this = _super.call(this, props) || this;
        _this.onReady = function () {
            return;
        };
        _this.onReceiveMessage = function (msg) {
            var data = msg.data;
            var springContext = _this.props.springContext;
            switch (data.type) {
                case 'selected-category-update':
                case 'selected-cells-update': {
                    springContext.update(data.payload.indices, data.payload.currentCategory);
                    break;
                }
                case 'loaded': {
                    _this.setState({
                        postMessageData: {
                            payload: {
                                indices: springContext.currentCells.toArray(),
                            },
                            type: 'init',
                        },
                    });
                }
                default: {
                    console.log("Got this msg for ya: " + JSON.stringify(msg));
                }
            }
        };
        _this.generateSpringURL = function (dataset) {
            return window.location.origin + "/" + window.location.pathname.substr(0, window.location.pathname.lastIndexOf('/')) + "/springViewer.html?datasets/" + dataset;
        };
        _this.state = {
            postMessageData: {
                payload: {},
                type: 'init',
            },
            springUrl: _this.generateSpringURL(_this.props.datasetLocation),
        };
        return _this;
    }
    SpringContainerClass.prototype.componentDidUpdate = function (prevProps, prevState) {
        var springContext = this.props.springContext;
        if (!prevProps.springContext.currentCells.equals(springContext.currentCells)) {
            console.log("sending new cells to spring, totalling " + springContext.currentCells.size);
            this.setState({
                postMessageData: {
                    payload: {
                        indices: springContext.currentCells.toArray(),
                    },
                    type: 'selected-cells-update',
                },
            });
        }
        else if (prevProps.datasetLocation !== this.props.datasetLocation) {
            this.setState({
                springUrl: this.generateSpringURL(this.props.datasetLocation),
            });
        }
    };
    SpringContainerClass.prototype.render = function () {
        var _a = this.props, isFullPage = _a.isFullPage, springHeight = _a.springHeight, springWidth = _a.springWidth;
        var _b = this.state, postMessageData = _b.postMessageData, springUrl = _b.springUrl;
        var attributes = {
            allowFullScreen: true,
            height: springHeight,
            src: springUrl,
            width: springWidth,
        };
        var targetOriginPieces = springUrl.split('/');
        return (React.createElement(component_1.ComponentCard, { componentName: SpringContainerClass.displayName, isFramedComponent: true, isFullPage: isFullPage, frameHeight: springHeight, frameWidth: springWidth, height: '500px' },
            React.createElement(react_iframe_comm_1.default, { attributes: attributes, postMessageData: postMessageData, handleReady: this.onReady, handleReceiveMessage: this.onReceiveMessage, targetOrigin: targetOriginPieces[0] + "//" + targetOriginPieces[2] })));
    };
    SpringContainerClass.defaultProps = {
        data: {
            links: new Array(),
            nodes: new Array(),
        },
        datasetLocation: 'hpc/full',
        headerHeight: 32,
        isFullPage: false,
        padding: 0,
        selectedCategory: '',
        springContext: __assign({}, context_1.initialSpringContext),
        springHeight: 1150,
        springWidth: 1150,
    };
    SpringContainerClass.displayName = 'SPRING';
    return SpringContainerClass;
}(React.Component));
exports.SpringContainerClass = SpringContainerClass;
exports.SpringContainer = function (props) { return (React.createElement(context_1.SpringContext.Consumer, null, function (springContext) { return React.createElement(SpringContainerClass, __assign({}, props, { springContext: springContext })); })); };


/***/ }),

/***/ "./src/container/TensorTContainer.tsx":
/*!********************************************!*\
  !*** ./src/container/TensorTContainer.tsx ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __values = (this && this.__values) || function (o) {
    var m = typeof Symbol === "function" && o[Symbol.iterator], i = 0;
    if (m) return m.call(o);
    return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
};
Object.defineProperty(exports, "__esModule", { value: true });
var lodash_1 = __webpack_require__(/*! lodash */ "./node_modules/lodash/lodash.js");
var React = __webpack_require__(/*! react */ "./node_modules/react/index.js");
var tensorFlow = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/@tensorflow/tfjs-core/dist/tf-core.esm.js");
// tslint:disable-next-line:no-submodule-imports
var tsne_1 = __webpack_require__(/*! @tensorflow/tfjs-tsne/dist/tsne */ "./node_modules/@tensorflow/tfjs-tsne/dist/tsne.js");
var semantic_ui_react_1 = __webpack_require__(/*! semantic-ui-react */ "./node_modules/semantic-ui-react/dist/es/index.js");
var component_1 = __webpack_require__(/*! ~chell-viz~/component */ "./src/component/index.ts");
var context_1 = __webpack_require__(/*! ~chell-viz~/context */ "./src/context/index.ts");
var data_1 = __webpack_require__(/*! ~chell-viz~/data */ "./src/data/index.ts");
var helper_1 = __webpack_require__(/*! ~chell-viz~/helper */ "./src/helper/index.ts");
var TensorTContainerClass = /** @class */ (function (_super) {
    __extends(TensorTContainerClass, _super);
    function TensorTContainerClass(props) {
        var _this = _super.call(this, props) || this;
        _this.canvasContext = null;
        _this.getPlotlyCoordsFromTsne = function (coords) {
            var springContext = _this.props.springContext;
            return [
                {
                    marker: {
                        color: _this.props.pointColor,
                    },
                    mode: 'markers',
                    type: 'scattergl',
                    x: coords.map(function (coord) { return coord[0]; }),
                    y: coords.map(function (coord) { return coord[1]; }),
                },
                {
                    marker: {
                        color: '#ffaa00',
                    },
                    mode: 'markers',
                    type: 'scattergl',
                    x: springContext.currentCells.toArray().map(function (cellIndex) { return coords[cellIndex][0]; }),
                    y: springContext.currentCells.toArray().map(function (cellIndex) { return coords[cellIndex][1]; }),
                },
            ];
        };
        _this.getPlotlyCoordsFromSpring = function (coords, currentCells) {
            return [
                {
                    marker: {
                        color: _this.props.pointColor,
                    },
                    mode: 'markers',
                    type: 'scattergl',
                    x: coords.map(function (coord) { return coord[0]; }),
                    y: coords.map(function (coord) { return coord[1]; }),
                },
                {
                    marker: {
                        color: '#ffaa00',
                    },
                    mode: 'markers',
                    type: 'scattergl',
                    x: currentCells.map(function (cellIndex) { return coords[cellIndex][0]; }),
                    y: currentCells.map(function (cellIndex) { return coords[cellIndex][1]; }),
                },
            ];
        };
        _this.getTensorConfigs = function () { return [
            {
                name: 'Iterate Once',
                onClick: _this.onIterateForward(),
                type: data_1.CONFIGURATION_COMPONENT_TYPE.BUTTON,
            },
            {
                name: 'Iterate Ten Times',
                onClick: _this.onIterateForward(10),
                type: data_1.CONFIGURATION_COMPONENT_TYPE.BUTTON,
            },
            {
                name: 'Iterate Fifty Times',
                onClick: _this.onIterateForward(50),
                type: data_1.CONFIGURATION_COMPONENT_TYPE.BUTTON,
            },
            {
                name: 'Reset',
                onClick: _this.onReset(),
                type: data_1.CONFIGURATION_COMPONENT_TYPE.BUTTON,
            },
            {
                icon: 'hashtag',
                name: "Total Iterations: " + _this.state.numIterations,
                type: data_1.CONFIGURATION_COMPONENT_TYPE.LABEL,
            },
        ]; };
        _this.handlePointSelection = function (event) {
            var springContext = _this.props.springContext;
            var coordsArray = _this.state.coordsArray;
            var selectedCells = new Array();
            var _loop_1 = function (i) {
                var x = event.selectedPoints[i];
                var y = event.selectedPoints[i + 1];
                var cellIndex = coordsArray.findIndex(function (coord) { return coord[0] === x && coord[1] === y; });
                if (cellIndex >= 0) {
                    selectedCells.push(cellIndex);
                }
            };
            for (var i = 0; i < event.selectedPoints.length - 1; i += 2) {
                _loop_1(i);
            }
            springContext.setCells(selectedCells);
        };
        _this.renderIterateLabel = function () { return React.createElement("label", null, "iterations: " + _this.state.numIterations); };
        /**
         * Renders the radio button responsible for toggling the animation on/off.
         */
        _this.renderIterateButton = function () { return (React.createElement(semantic_ui_react_1.Radio, { label: React.createElement("label", { style: { fontSize: '14px', fontWeight: 'bold' } }, "iterate"), onClick: _this.onIterationToggle(), toggle: true })); };
        _this.renderResetButton = function () { return React.createElement(semantic_ui_react_1.Icon, { name: 'undo', onClick: _this.onReset() }); };
        _this.onIterateForward = function (amount) {
            if (amount === void 0) { amount = 1; }
            return function () { return __awaiter(_this, void 0, void 0, function () {
                var _a, isComputing, tsne, coordsArray, plotlyCoords;
                return __generator(this, function (_b) {
                    switch (_b.label) {
                        case 0:
                            _a = this.state, isComputing = _a.isComputing, tsne = _a.tsne;
                            if (!(tsne && !isComputing)) return [3 /*break*/, 3];
                            this.setState({
                                isComputing: true,
                            });
                            return [4 /*yield*/, tsne.iterate(amount)];
                        case 1:
                            _b.sent();
                            return [4 /*yield*/, tsne.coordsArray()];
                        case 2:
                            coordsArray = _b.sent();
                            plotlyCoords = this.getPlotlyCoordsFromTsne(coordsArray);
                            this.setState({
                                coordsArray: coordsArray,
                                isComputing: false,
                                numIterations: this.state.numIterations + amount,
                                plotlyCoords: plotlyCoords,
                            });
                            _b.label = 3;
                        case 3: return [2 /*return*/];
                    }
                });
            }); };
        };
        _this.onIterationToggle = function () { return function () {
            var isAnimating = !_this.state.isAnimating;
            if (isAnimating) {
                var animationFrame_1 = function () { return __awaiter(_this, void 0, void 0, function () {
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, this.onIterateForward(1)()];
                            case 1:
                                _a.sent();
                                if (this.state.isAnimating && this.state.numIterations < 500) {
                                    requestAnimationFrame(animationFrame_1);
                                }
                                else {
                                    this.setState({ isAnimating: false });
                                }
                                return [2 /*return*/];
                        }
                    });
                }); };
                requestAnimationFrame(animationFrame_1);
            }
            _this.setState({ isAnimating: isAnimating });
        }; };
        _this.onReset = function () { return function () { return __awaiter(_this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.computeTensorTsne(0)];
                    case 1:
                        _a.sent();
                        return [2 /*return*/];
                }
            });
        }); }; };
        _this.state = {
            coordsArray: [],
            isAnimating: false,
            isComputing: false,
            numIterations: 0,
            plotlyCoords: [],
        };
        return _this;
    }
    TensorTContainerClass.prototype.componentDidMount = function () {
        return __awaiter(this, void 0, void 0, function () {
            var tensorData, tsneData, tsne, e_1;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        _a.trys.push([0, 4, , 5]);
                        return [4 /*yield*/, helper_1.fetchTensorTSneCoordinateData("datasets/" + this.props.datasetLocation)];
                    case 1:
                        tensorData = _a.sent();
                        tsneData = tensorFlow.tensor(tensorData);
                        return [4 /*yield*/, Promise.resolve().then(function () { return __webpack_require__(/*! @tensorflow/tfjs-tsne */ "./node_modules/@tensorflow/tfjs-tsne/dist-es6/index.js"); })];
                    case 2:
                        tsne = (_a.sent()).tsne(tsneData);
                        this.setState({
                            tsne: tsne,
                        });
                        return [4 /*yield*/, this.computeTensorTsne(this.state.numIterations)];
                    case 3:
                        _a.sent();
                        return [3 /*break*/, 5];
                    case 4:
                        e_1 = _a.sent();
                        console.log(e_1);
                        return [3 /*break*/, 5];
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    TensorTContainerClass.prototype.componentDidUpdate = function (prevProps) {
        return __awaiter(this, void 0, void 0, function () {
            var e_2, _a, springContext, tsne, _b, _c, _d, indices, _e, _f, node, _g, _h, _j;
            return __generator(this, function (_k) {
                switch (_k.label) {
                    case 0:
                        springContext = this.props.springContext;
                        tsne = this.state.tsne;
                        if (!(this.props.datasetLocation !== prevProps.datasetLocation)) return [3 /*break*/, 2];
                        return [4 /*yield*/, this.setupTensorData()];
                    case 1:
                        _k.sent();
                        return [3 /*break*/, 6];
                    case 2:
                        if (!tsne) return [3 /*break*/, 6];
                        if (!(springContext.currentCells !== prevProps.springContext.currentCells)) return [3 /*break*/, 4];
                        _b = this.setState;
                        _c = {};
                        _d = this.getPlotlyCoordsFromTsne;
                        return [4 /*yield*/, tsne.coordsArray()];
                    case 3:
                        _b.apply(this, [(_c.plotlyCoords = _d.apply(this, [_k.sent()]),
                                _c)]);
                        return [3 /*break*/, 6];
                    case 4:
                        if (!!lodash_1.isEqual(springContext.selectedLabels, prevProps.springContext.selectedLabels)) return [3 /*break*/, 6];
                        indices = new Array();
                        try {
                            for (_e = __values(springContext.graphData.nodes), _f = _e.next(); !_f.done; _f = _e.next()) {
                                node = _f.value;
                                if (springContext.selectedLabels.includes(node.labelForCategory[springContext.selectedCategory])) {
                                    indices.push(node.number);
                                }
                            }
                        }
                        catch (e_2_1) { e_2 = { error: e_2_1 }; }
                        finally {
                            try {
                                if (_f && !_f.done && (_a = _e.return)) _a.call(_e);
                            }
                            finally { if (e_2) throw e_2.error; }
                        }
                        _g = this.setState;
                        _h = {};
                        _j = this.getPlotlyCoordsFromSpring;
                        return [4 /*yield*/, tsne.coordsArray()];
                    case 5:
                        _g.apply(this, [(_h.plotlyCoords = _j.apply(this, [_k.sent(), indices]),
                                _h)]);
                        _k.label = 6;
                    case 6: return [2 /*return*/];
                }
            });
        });
    };
    TensorTContainerClass.prototype.render = function () {
        var isFullPage = this.props.isFullPage;
        var plotlyCoords = this.state.plotlyCoords;
        return (React.createElement(component_1.ComponentCard, { componentName: TensorTContainerClass.displayName, iconSrc: 'assets/icons/tfjs-tsne-icon.png', isFullPage: isFullPage },
            React.createElement(semantic_ui_react_1.Grid, { centered: true, style: { height: '100%', marginLeft: 0, width: '100%' } },
                React.createElement(semantic_ui_react_1.Grid.Row, { columns: 'equal', style: { maxHeight: '23px', padding: '7px 0 0 0' } },
                    React.createElement(semantic_ui_react_1.Grid.Column, { floated: 'left' }, this.renderIterateButton()),
                    React.createElement(semantic_ui_react_1.Grid.Column, null, this.renderIterateLabel()),
                    React.createElement(semantic_ui_react_1.Grid.Column, { floated: 'right' }, this.renderResetButton())),
                React.createElement(semantic_ui_react_1.Grid.Row, { stretched: true, style: { height: '90%', margin: 0 } },
                    React.createElement(component_1.TensorTComponent, { onSelectedCallback: this.handlePointSelection, pointsToPlot: plotlyCoords })))));
    };
    TensorTContainerClass.prototype.computeTensorTsne = function (numIterations) {
        return __awaiter(this, void 0, void 0, function () {
            var _a, isComputing, tsne, coordsArray, plotlyCoords;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = this.state, isComputing = _a.isComputing, tsne = _a.tsne;
                        if (!(tsne && !isComputing)) return [3 /*break*/, 3];
                        this.setState({
                            isComputing: true,
                        });
                        return [4 /*yield*/, tsne.compute(numIterations)];
                    case 1:
                        _b.sent();
                        return [4 /*yield*/, tsne.coordsArray()];
                    case 2:
                        coordsArray = _b.sent();
                        plotlyCoords = this.getPlotlyCoordsFromTsne(coordsArray);
                        this.setState({
                            coordsArray: coordsArray,
                            isComputing: false,
                            numIterations: numIterations,
                            plotlyCoords: plotlyCoords,
                        });
                        _b.label = 3;
                    case 3: return [2 /*return*/];
                }
            });
        });
    };
    TensorTContainerClass.prototype.setupTensorData = function () {
        return __awaiter(this, void 0, void 0, function () {
            var tensorData, tsneData, tsne, numIterations, coordsArray, plotlyCoords, e_3;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        _a.trys.push([0, 4, , 5]);
                        this.setState({
                            isAnimating: false,
                            isComputing: true,
                            plotlyCoords: [],
                            tsne: undefined,
                        });
                        return [4 /*yield*/, helper_1.fetchTensorTSneCoordinateData("datasets/" + this.props.datasetLocation)];
                    case 1:
                        tensorData = _a.sent();
                        tsneData = tensorFlow.tensor(tensorData);
                        tsne = new tsne_1.TSNE(tsneData);
                        numIterations = 0;
                        return [4 /*yield*/, tsne.compute(numIterations)];
                    case 2:
                        _a.sent();
                        return [4 /*yield*/, tsne.coordsArray()];
                    case 3:
                        coordsArray = _a.sent();
                        plotlyCoords = this.getPlotlyCoordsFromTsne(coordsArray);
                        this.setState({
                            coordsArray: coordsArray,
                            isComputing: false,
                            numIterations: numIterations,
                            plotlyCoords: plotlyCoords,
                        });
                        return [3 /*break*/, 5];
                    case 4:
                        e_3 = _a.sent();
                        console.log(e_3);
                        return [3 /*break*/, 5];
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    TensorTContainerClass.defaultProps = {
        datasetLocation: 'hpc/full',
        height: 400,
        isFullPage: false,
        pointColor: '#aa0000',
        springContext: __assign({}, context_1.initialSpringContext),
        style: {
            padding: 0,
        },
        width: 400,
    };
    TensorTContainerClass.displayName = 'tSNE - TensorFlow';
    return TensorTContainerClass;
}(React.Component));
exports.TensorTContainerClass = TensorTContainerClass;
exports.TensorTContainer = function (props) { return (React.createElement(context_1.SpringContext.Consumer, null, function (springContext) { return React.createElement(TensorTContainerClass, __assign({}, props, { springContext: springContext })); })); };


/***/ }),

/***/ "./src/container/VizPanelContainer.tsx":
/*!*********************************************!*\
  !*** ./src/container/VizPanelContainer.tsx ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __values = (this && this.__values) || function (o) {
    var m = typeof Symbol === "function" && o[Symbol.iterator], i = 0;
    if (m) return m.call(o);
    return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spread = (this && this.__spread) || function () {
    for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));
    return ar;
};
Object.defineProperty(exports, "__esModule", { value: true });
var React = __webpack_require__(/*! react */ "./node_modules/react/index.js");
var semantic_ui_react_1 = __webpack_require__(/*! semantic-ui-react */ "./node_modules/semantic-ui-react/dist/es/index.js");
var component_1 = __webpack_require__(/*! ~chell-viz~/component */ "./src/component/index.ts");
var data_1 = __webpack_require__(/*! ~chell-viz~/data */ "./src/data/index.ts");
var helper_1 = __webpack_require__(/*! ~chell-viz~/helper */ "./src/helper/index.ts");
exports.initialVizPanelState = {
    currentDataDir: '',
    data: new Object(),
};
var VizPanelContainer = /** @class */ (function (_super) {
    __extends(VizPanelContainer, _super);
    function VizPanelContainer(props) {
        var _this = _super.call(this, props) || this;
        _this.state = exports.initialVizPanelState;
        _this.renderFileUploadForm = function () { return (React.createElement(semantic_ui_react_1.Label, { as: "label", basic: true, htmlFor: 'upload' },
            React.createElement(semantic_ui_react_1.Button, { icon: 'upload', label: {
                    basic: true,
                    content: 'Upload',
                }, labelPosition: 'right' }),
            React.createElement("input", { id: 'upload', onChange: _this.onDataUpload, hidden: true, type: 'file', multiple: true, required: true }))); };
        _this.onDataUpload = function (e) { return __awaiter(_this, void 0, void 0, function () {
            var fileList, files, pdbIndex, mappingIndex_1, couplingIndex, pdbData, couplingResult, mappingResult, data;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        fileList = e.target.files;
                        if (!fileList) return [3 /*break*/, 5];
                        files = Array.from(fileList);
                        pdbIndex = files.findIndex(function (file) { return file.name.endsWith('.pdb'); });
                        mappingIndex_1 = files.findIndex(function (file) { return file.name.localeCompare('residue_mapping.csv') === 0; });
                        couplingIndex = files.findIndex(function (file, index) { return file.name.endsWith('.csv') && index !== mappingIndex_1; });
                        if (!(pdbIndex === -1 || mappingIndex_1 === -1 || couplingIndex === -1)) return [3 /*break*/, 1];
                        alert('Incorrect files uploaded! Please upload a file named residue_mapping.csv as well as a .pdb and .csv file!');
                        return [3 /*break*/, 5];
                    case 1: return [4 /*yield*/, data_1.ChellPDB.createPDB(files[pdbIndex])];
                    case 2:
                        pdbData = _a.sent();
                        return [4 /*yield*/, helper_1.readFileAsText(files[couplingIndex])];
                    case 3:
                        couplingResult = _a.sent();
                        return [4 /*yield*/, helper_1.readFileAsText(files[mappingIndex_1])];
                    case 4:
                        mappingResult = _a.sent();
                        data = {
                            couplingScores: helper_1.getCouplingScoresData(couplingResult, helper_1.generateResidueMapping(mappingResult)),
                            pdbData: pdbData,
                            secondaryStructures: [],
                        };
                        this.setState({
                            data: __assign({}, this.state.data, { 'Contact Map': data, NGL: pdbData.nglStructure }),
                        });
                        _a.label = 5;
                    case 5: return [2 /*return*/];
                }
            });
        }); };
        _this.onDataDirChange = function (event, data) {
            _this.setState({
                currentDataDir: data.value,
            });
        };
        _this.state = __assign({}, _this.state, { currentDataDir: props.dataDirs[0] });
        return _this;
    }
    VizPanelContainer.prototype.componentDidMount = function () {
        return __awaiter(this, void 0, void 0, function () {
            var e_1, _a, results, _b, _c, viz, _d, _e, e_1_1;
            return __generator(this, function (_f) {
                switch (_f.label) {
                    case 0:
                        results = {};
                        _f.label = 1;
                    case 1:
                        _f.trys.push([1, 6, 7, 8]);
                        _b = __values(this.props.supportedVisualizations), _c = _b.next();
                        _f.label = 2;
                    case 2:
                        if (!!_c.done) return [3 /*break*/, 5];
                        viz = _c.value;
                        _d = results;
                        _e = viz;
                        return [4 /*yield*/, helper_1.fetchAppropriateData(viz, this.state.currentDataDir)];
                    case 3:
                        _d[_e] = _f.sent();
                        _f.label = 4;
                    case 4:
                        _c = _b.next();
                        return [3 /*break*/, 2];
                    case 5: return [3 /*break*/, 8];
                    case 6:
                        e_1_1 = _f.sent();
                        e_1 = { error: e_1_1 };
                        return [3 /*break*/, 8];
                    case 7:
                        try {
                            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                        }
                        finally { if (e_1) throw e_1.error; }
                        return [7 /*endfinally*/];
                    case 8:
                        this.setState({
                            data: __assign({}, results),
                        });
                        return [2 /*return*/];
                }
            });
        });
    };
    VizPanelContainer.prototype.componentDidUpdate = function (prevProps, prevState) {
        return __awaiter(this, void 0, void 0, function () {
            var e_2, _a, results, _b, _c, viz, _d, _e, e_2_1;
            return __generator(this, function (_f) {
                switch (_f.label) {
                    case 0:
                        if (!(prevState.currentDataDir !== this.state.currentDataDir)) return [3 /*break*/, 9];
                        results = {};
                        _f.label = 1;
                    case 1:
                        _f.trys.push([1, 6, 7, 8]);
                        _b = __values(this.props.supportedVisualizations), _c = _b.next();
                        _f.label = 2;
                    case 2:
                        if (!!_c.done) return [3 /*break*/, 5];
                        viz = _c.value;
                        _d = results;
                        _e = viz;
                        return [4 /*yield*/, helper_1.fetchAppropriateData(viz, this.state.currentDataDir)];
                    case 3:
                        _d[_e] = _f.sent();
                        _f.label = 4;
                    case 4:
                        _c = _b.next();
                        return [3 /*break*/, 2];
                    case 5: return [3 /*break*/, 8];
                    case 6:
                        e_2_1 = _f.sent();
                        e_2 = { error: e_2_1 };
                        return [3 /*break*/, 8];
                    case 7:
                        try {
                            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                        }
                        finally { if (e_2) throw e_2.error; }
                        return [7 /*endfinally*/];
                    case 8:
                        this.setState({
                            data: __assign({}, results),
                        });
                        _f.label = 9;
                    case 9: return [2 /*return*/];
                }
            });
        });
    };
    VizPanelContainer.prototype.render = function () {
        var allowUploads = this.props.allowUploads;
        return (React.createElement(semantic_ui_react_1.Grid, { className: 'VizPanelContainer', columns: this.props.numPanels, centered: true, relaxed: true },
            React.createElement(semantic_ui_react_1.GridRow, { columns: 1, centered: true },
                React.createElement(semantic_ui_react_1.Dropdown, { className: 'viz-panel-container-dropdown', onChange: this.onDataDirChange, options: __spread(this.props.dataDirs.map(function (dir) {
                        return { key: dir, text: dir, value: dir };
                    })), placeholder: this.props.dataDirs[0], search: true })),
            this.renderPanels(this.props.numPanels, this.state.data, this.props.initialVisualizations).map(function (panel, index) { return (React.createElement(semantic_ui_react_1.GridColumn, { key: index }, panel)); }),
            allowUploads && this.renderFileUploadForm()));
    };
    VizPanelContainer.prototype.renderPanels = function (numPanels, data, initialVisualizations) {
        var result = [];
        for (var i = 0; i < numPanels; ++i) {
            result.push(React.createElement(component_1.VizSelectorPanel, { data: data, initialViz: initialVisualizations[i], supportedVisualizations: this.props.supportedVisualizations }));
        }
        return result;
    };
    VizPanelContainer.defaultProps = {
        allowUploads: true,
        initialVisualizations: [],
        /** Number of panels to be controlled by this container. Currently limited to 4. */
        numPanels: 1,
    };
    return VizPanelContainer;
}(React.Component));
exports.VizPanelContainer = VizPanelContainer;


/***/ }),

/***/ "./src/container/index.ts":
/*!********************************!*\
  !*** ./src/container/index.ts ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./AnatomogramContainer */ "./src/container/AnatomogramContainer.tsx"));
__export(__webpack_require__(/*! ./ProteinFeatureViewer */ "./src/container/ProteinFeatureViewer.tsx"));
__export(__webpack_require__(/*! ./SpringContainer */ "./src/container/SpringContainer.tsx"));
__export(__webpack_require__(/*! ./SiteHeader */ "./src/container/SiteHeader.tsx"));
__export(__webpack_require__(/*! ./TensorTContainer */ "./src/container/TensorTContainer.tsx"));
__export(__webpack_require__(/*! ./VizPanelContainer */ "./src/container/VizPanelContainer.tsx"));


/***/ }),

/***/ "./src/context/ChellContextProvider.tsx":
/*!**********************************************!*\
  !*** ./src/context/ChellContextProvider.tsx ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var React = __webpack_require__(/*! react */ "./node_modules/react/index.js");
var context_1 = __webpack_require__(/*! ~chell-viz~/context */ "./src/context/index.ts");
/**
 * Shorthand for passing all Chell contexts down.
 *
 * @export
 * @extends {React.Component<any, any>}
 */
var ChellContextProvider = /** @class */ (function (_super) {
    __extends(ChellContextProvider, _super);
    function ChellContextProvider(props) {
        return _super.call(this, props) || this;
    }
    ChellContextProvider.prototype.render = function () {
        var params = new URLSearchParams(this.props.location ? this.props.location.search : '');
        // tslint:disable-next-line:no-backbone-get-set-outside-model
        var datasetLocation = params.get('name');
        return (React.createElement(context_1.SecondaryStructureContextProvider, null,
            React.createElement(context_1.SpringContextProvider, { datasetLocation: datasetLocation ? datasetLocation : '' },
                React.createElement(context_1.ResidueContextProvider, null, this.props.children))));
    };
    return ChellContextProvider;
}(React.Component));
exports.ChellContextProvider = ChellContextProvider;


/***/ }),

/***/ "./src/context/CouplingContext.tsx":
/*!*****************************************!*\
  !*** ./src/context/CouplingContext.tsx ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var React = __webpack_require__(/*! react */ "./node_modules/react/index.js");
var context_1 = __webpack_require__(/*! ~chell-viz~/context */ "./src/context/index.ts");
var data_1 = __webpack_require__(/*! ~chell-viz~/data */ "./src/data/index.ts");
exports.initialCouplingContext = {
    couplingScores: new data_1.CouplingContainer(),
};
exports.CouplingContext = React.createContext(exports.initialCouplingContext);
exports.CouplingContextConsumer = exports.CouplingContext.Consumer;
/**
 * Shorthand for passing contexts relevant for Coupling Scores - Primarily interaction with residues and secondary structures.
 *
 * @export
 * @extends {React.Component<any, ICouplingContext>}
 */
var CouplingContextProvider = /** @class */ (function (_super) {
    __extends(CouplingContextProvider, _super);
    function CouplingContextProvider(props) {
        var _this = _super.call(this, props) || this;
        _this.state = exports.initialCouplingContext;
        return _this;
    }
    CouplingContextProvider.prototype.render = function () {
        return (React.createElement(context_1.SecondaryStructureContextProvider, null,
            React.createElement(context_1.ResidueContextProvider, null,
                React.createElement(exports.CouplingContext.Provider, { value: this.state }, this.props.children))));
    };
    return CouplingContextProvider;
}(React.Component));
exports.CouplingContextProvider = CouplingContextProvider;


/***/ }),

/***/ "./src/context/GenericContextProvider.tsx":
/*!************************************************!*\
  !*** ./src/context/GenericContextProvider.tsx ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spread = (this && this.__spread) || function () {
    for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));
    return ar;
};
Object.defineProperty(exports, "__esModule", { value: true });
// tslint:disable:max-classes-per-file
var React = __webpack_require__(/*! react */ "./node_modules/react/index.js");
exports.createGenericContext = function (readValue, writeValue) {
    var readContext = React.createContext(readValue);
    var writeContext = React.createContext(writeValue);
    // tslint:disable-next-line:no-object-literal-type-assertion
    var bothContext = React.createContext(__assign({}, readValue, writeValue));
    var Consumers = {
        Both: bothContext.Consumer,
        Read: readContext.Consumer,
        Write: writeContext.Consumer,
    };
    var Providers = {
        Both: bothContext.Provider,
        Read: readContext.Provider,
        Write: writeContext.Provider,
    };
    var allConsumers = __spread(Object.values(Consumers));
    var allProviders = __spread(Object.values(Providers));
    return {
        Consumers: Consumers,
        Providers: Providers,
        allConsumers: allConsumers,
        allProviders: allProviders,
        allProvidersJSX: function (state, children) {
            // tslint:disable-next-line
            return allProviders.reduce(function (prev, Curr) { return React.createElement(Curr, { value: state }, prev); }, children);
        },
    };
};


/***/ }),

/***/ "./src/context/ResidueContext.tsx":
/*!****************************************!*\
  !*** ./src/context/ResidueContext.tsx ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", { value: true });
var React = __webpack_require__(/*! react */ "./node_modules/react/index.js");
exports.initialResidueContext = {
    addCandidateResidues: function (residues) {
        return;
    },
    addHoveredResidues: function (residues) {
        return;
    },
    addLockedResiduePair: function (residues) {
        return;
    },
    candidateResidues: new Array(),
    clearAllResidues: function () {
        return;
    },
    hoveredResidues: new Array(),
    lockedResiduePairs: new Map(),
    removeAllLockedResiduePairs: function () {
        return;
    },
    removeCandidateResidues: function () {
        return;
    },
    removeHoveredResidues: function () {
        return;
    },
    removeLockedResiduePair: function (residues) {
        return;
    },
    removeNonLockedResidues: function () {
        return;
    },
    toggleLockedResiduePair: function (residues) {
        return;
    },
};
exports.ResidueContext = React.createContext(exports.initialResidueContext);
exports.ResidueContextConsumer = exports.ResidueContext.Consumer;
var ResidueContextProvider = /** @class */ (function (_super) {
    __extends(ResidueContextProvider, _super);
    function ResidueContextProvider(props) {
        var _this = _super.call(this, props) || this;
        _this.onAddCandidateResidues = function (candidateResidues) {
            _this.setState({
                candidateResidues: candidateResidues.sort(),
            });
        };
        _this.onAddHoveredResidues = function (hoveredResidues) {
            _this.setState({
                hoveredResidues: hoveredResidues.sort(),
            });
        };
        _this.onAddLockedResiduePair = function (residues) {
            var lockedResiduePairs = _this.state.lockedResiduePairs;
            var sortedResidues = residues.sort();
            var residuePairKey = sortedResidues.toString();
            if (!lockedResiduePairs.has(residuePairKey)) {
                var result = new Map(lockedResiduePairs);
                result.set(residuePairKey, sortedResidues);
                _this.setState({
                    lockedResiduePairs: result,
                });
            }
        };
        _this.onClearAllResidues = function () {
            _this.setState({
                candidateResidues: new Array(),
                hoveredResidues: new Array(),
                lockedResiduePairs: new Map(),
            });
        };
        _this.onRemoveAllLockedResiduePairs = function () {
            _this.setState({
                lockedResiduePairs: new Map(),
            });
        };
        _this.onRemoveCandidateResidue = function () {
            _this.setState({
                candidateResidues: new Array(),
            });
        };
        _this.onRemoveHoveredResidues = function () {
            _this.setState({
                hoveredResidues: new Array(),
            });
        };
        _this.onRemoveLockedResiduePair = function (residues) {
            var residuePairKey = residues.sort().join(',');
            var lockedResiduePairs = _this.state.lockedResiduePairs;
            if (lockedResiduePairs.has(residuePairKey)) {
                var result = new Map(lockedResiduePairs);
                result.delete(residuePairKey);
                _this.setState({
                    lockedResiduePairs: result,
                });
            }
        };
        _this.onRemoveNonLockedResidues = function () {
            _this.setState({
                candidateResidues: new Array(),
                hoveredResidues: new Array(),
            });
        };
        _this.onToggleLockedResiduePair = function (residues) {
            var lockedResiduePairs = _this.state.lockedResiduePairs;
            var sortedResidues = residues.sort();
            var residuePairKey = sortedResidues.toString();
            var result = new Map(lockedResiduePairs);
            if (!lockedResiduePairs.has(residuePairKey)) {
                result.set(residuePairKey, sortedResidues);
            }
            else {
                result.delete(residuePairKey);
            }
            _this.setState({
                lockedResiduePairs: result,
            });
        };
        _this.state = __assign({}, exports.initialResidueContext, { addCandidateResidues: _this.onAddCandidateResidues, addHoveredResidues: _this.onAddHoveredResidues, addLockedResiduePair: _this.onAddLockedResiduePair, clearAllResidues: _this.onClearAllResidues, removeAllLockedResiduePairs: _this.onRemoveAllLockedResiduePairs, removeCandidateResidues: _this.onRemoveCandidateResidue, removeHoveredResidues: _this.onRemoveHoveredResidues, removeLockedResiduePair: _this.onRemoveLockedResiduePair, removeNonLockedResidues: _this.onRemoveNonLockedResidues, toggleLockedResiduePair: _this.onToggleLockedResiduePair });
        return _this;
    }
    ResidueContextProvider.prototype.render = function () {
        return React.createElement(exports.ResidueContext.Provider, { value: this.state }, this.props.children);
    };
    return ResidueContextProvider;
}(React.Component));
exports.ResidueContextProvider = ResidueContextProvider;


/***/ }),

/***/ "./src/context/SecondaryStructureContext.tsx":
/*!***************************************************!*\
  !*** ./src/context/SecondaryStructureContext.tsx ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spread = (this && this.__spread) || function () {
    for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));
    return ar;
};
Object.defineProperty(exports, "__esModule", { value: true });
// tslint:disable:max-classes-per-file
var React = __webpack_require__(/*! react */ "./node_modules/react/index.js");
exports.initialSecondaryStructContextRead = {
    hoveredSecondaryStructures: new Array(),
    selectedSecondaryStructures: new Array(),
};
exports.initialSecondaryStructContextWrite = {
    addHoveredSecondaryStructure: function (section) {
        return;
    },
    addSelectedSecondaryStructure: function (section) {
        return;
    },
    clearAllSecondaryStructures: function () {
        return;
    },
    removeHoveredSecondaryStructure: function (section) {
        return;
    },
    removeSecondaryStructure: function (section) {
        return;
    },
};
exports.initialSecondaryStructureContext = __assign({}, exports.initialSecondaryStructContextWrite, exports.initialSecondaryStructContextRead);
exports.SecondaryStructureContextRead = React.createContext(exports.initialSecondaryStructContextRead);
exports.SecondaryStructureContextWrite = React.createContext(exports.initialSecondaryStructContextWrite);
exports.SecondaryStructureContext = React.createContext(exports.initialSecondaryStructureContext);
exports.SecondaryStructureContextReadConsumer = exports.SecondaryStructureContextRead.Consumer;
exports.SecondaryStructureContextWriteConsumer = exports.SecondaryStructureContextWrite.Consumer;
exports.SecondaryStructureContextConsumer = exports.SecondaryStructureContext.Consumer;
var SecondaryStructureContextProvider = /** @class */ (function (_super) {
    __extends(SecondaryStructureContextProvider, _super);
    function SecondaryStructureContextProvider(props) {
        var _this = _super.call(this, props) || this;
        _this.onAddHoveredSecondaryStructure = function () { return function (section) {
            if (!_this.state.hoveredSecondaryStructures.includes(section)) {
                _this.setState({
                    hoveredSecondaryStructures: __spread(_this.state.hoveredSecondaryStructures, [section]),
                });
            }
        }; };
        _this.onAddSelectedSecondaryStructure = function () { return function (section) {
            if (!_this.state.selectedSecondaryStructures.includes(section)) {
                _this.setState({
                    selectedSecondaryStructures: __spread(_this.state.selectedSecondaryStructures, [section]),
                });
            }
        }; };
        _this.onClearSecondaryStructure = function () { return function () {
            _this.setState({
                hoveredSecondaryStructures: new Array(),
                selectedSecondaryStructures: new Array(),
            });
        }; };
        _this.onRemoveHoveredSecondaryStructure = function () { return function (sectionToRemove) {
            var prevIndex = _this.state.hoveredSecondaryStructures.findIndex(function (section) {
                return section.label === sectionToRemove.label &&
                    section.start === sectionToRemove.start &&
                    section.end === sectionToRemove.end;
            });
            _this.setState({
                hoveredSecondaryStructures: __spread(_this.state.hoveredSecondaryStructures.splice(0, prevIndex), _this.state.hoveredSecondaryStructures.splice(prevIndex + 1)),
            });
        }; };
        _this.onRemoveSecondaryStructure = function () { return function (sectionToRemove) {
            var prevSelectedIndex = _this.state.selectedSecondaryStructures.findIndex(function (section) {
                return section.label === sectionToRemove.label &&
                    section.start === sectionToRemove.start &&
                    section.end === sectionToRemove.end;
            });
            var prevHoveredIndex = _this.state.hoveredSecondaryStructures.findIndex(function (section) {
                return section.label === sectionToRemove.label &&
                    section.start === sectionToRemove.start &&
                    section.end === sectionToRemove.end;
            });
            _this.setState({
                hoveredSecondaryStructures: __spread(_this.state.hoveredSecondaryStructures.splice(0, prevHoveredIndex), _this.state.hoveredSecondaryStructures.splice(prevHoveredIndex + 1)),
                selectedSecondaryStructures: __spread(_this.state.selectedSecondaryStructures.splice(0, prevSelectedIndex), _this.state.selectedSecondaryStructures.splice(prevSelectedIndex + 1)),
            });
        }; };
        _this.state = {
            addHoveredSecondaryStructure: _this.onAddHoveredSecondaryStructure(),
            addSelectedSecondaryStructure: _this.onAddSelectedSecondaryStructure(),
            clearAllSecondaryStructures: _this.onClearSecondaryStructure(),
            hoveredSecondaryStructures: new Array(),
            removeHoveredSecondaryStructure: _this.onRemoveHoveredSecondaryStructure(),
            removeSecondaryStructure: _this.onRemoveSecondaryStructure(),
            selectedSecondaryStructures: new Array(),
        };
        return _this;
    }
    SecondaryStructureContextProvider.prototype.render = function () {
        return (React.createElement(exports.SecondaryStructureContextRead.Provider, { value: this.state },
            React.createElement(exports.SecondaryStructureContextWrite.Provider, { value: this.state },
                React.createElement(exports.SecondaryStructureContext.Provider, { value: this.state }, this.props.children))));
    };
    return SecondaryStructureContextProvider;
}(React.Component));
exports.SecondaryStructureContextProvider = SecondaryStructureContextProvider;


/***/ }),

/***/ "./src/context/SpringContext.tsx":
/*!***************************************!*\
  !*** ./src/context/SpringContext.tsx ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __values = (this && this.__values) || function (o) {
    var m = typeof Symbol === "function" && o[Symbol.iterator], i = 0;
    if (m) return m.call(o);
    return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
};
Object.defineProperty(exports, "__esModule", { value: true });
var immutable_1 = __webpack_require__(/*! immutable */ "./node_modules/immutable/dist/immutable.js");
var React = __webpack_require__(/*! react */ "./node_modules/react/index.js");
var helper_1 = __webpack_require__(/*! ~chell-viz~/helper */ "./src/helper/index.ts");
exports.initialSpringContext = {
    addLabel: function (label) {
        return;
    },
    addLabels: function (labels) {
        return;
    },
    categories: immutable_1.Set(),
    changeCategory: function (selectedCategory) {
        return;
    },
    currentCells: immutable_1.Set(),
    graphData: { nodes: new Array() },
    labelsByCategory: new Map(),
    removeAllCells: function () {
        return;
    },
    removeCells: function (cells) {
        return;
    },
    removeLabel: function (label) {
        return;
    },
    removeLabels: function (labels) {
        return;
    },
    selectedCategory: '',
    selectedLabels: immutable_1.Set(),
    setCells: function (cells) {
        return;
    },
    toggleLabels: function (labels) {
        return;
    },
    update: function (cells, selectedCategory, label) {
        return;
    },
};
exports.SpringContext = React.createContext(exports.initialSpringContext);
var SpringContextProvider = /** @class */ (function (_super) {
    __extends(SpringContextProvider, _super);
    function SpringContextProvider(props) {
        var _this = _super.call(this, props) || this;
        _this.deriveCurrentCellsFromLabels = function (selectedLabels) {
            var e_1, _a;
            var _b = _this.state, categories = _b.categories, graphData = _b.graphData, labelsByCategory = _b.labelsByCategory;
            var validCategories = immutable_1.Set();
            selectedLabels.forEach(function (label) {
                if (label) {
                    categories.forEach(function (category) {
                        if (category) {
                            var labels = labelsByCategory.get(category);
                            if (labels && labels.includes(label)) {
                                validCategories = validCategories.add(category);
                            }
                        }
                    });
                }
            });
            var cellIndices = immutable_1.Set();
            var _loop_1 = function (node) {
                validCategories.forEach(function (category) {
                    if (category && selectedLabels.includes(node.labelForCategory[category])) {
                        cellIndices = cellIndices.add(node.number);
                        return;
                    }
                });
            };
            try {
                for (var _c = __values(graphData.nodes), _d = _c.next(); !_d.done; _d = _c.next()) {
                    var node = _d.value;
                    _loop_1(node);
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
                }
                finally { if (e_1) throw e_1.error; }
            }
            return cellIndices;
        };
        _this.deriveValidLabelsFromCells = function (currentCells) {
            var e_2, _a, e_3, _b;
            var _c = _this.state, categories = _c.categories, graphData = _c.graphData;
            var result = immutable_1.Set();
            try {
                for (var currentCells_1 = __values(currentCells), currentCells_1_1 = currentCells_1.next(); !currentCells_1_1.done; currentCells_1_1 = currentCells_1.next()) {
                    var cellIndex = currentCells_1_1.value;
                    try {
                        for (var _d = __values(categories.toArray()), _e = _d.next(); !_e.done; _e = _d.next()) {
                            var category = _e.value;
                            result = result.add(graphData.nodes[cellIndex].labelForCategory[category]);
                        }
                    }
                    catch (e_3_1) { e_3 = { error: e_3_1 }; }
                    finally {
                        try {
                            if (_e && !_e.done && (_b = _d.return)) _b.call(_d);
                        }
                        finally { if (e_3) throw e_3.error; }
                    }
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (currentCells_1_1 && !currentCells_1_1.done && (_a = currentCells_1.return)) _a.call(currentCells_1);
                }
                finally { if (e_2) throw e_2.error; }
            }
            return result;
        };
        _this.onAddLabel = function (label) {
            var selectedLabels = _this.state.selectedLabels;
            if (!selectedLabels.includes(label)) {
                _this.setState({
                    selectedLabels: selectedLabels.add(label),
                });
            }
        };
        _this.onAddLabels = function (labels) {
            var e_4, _a;
            var selectedLabels = _this.state.selectedLabels;
            try {
                for (var labels_1 = __values(labels), labels_1_1 = labels_1.next(); !labels_1_1.done; labels_1_1 = labels_1.next()) {
                    var label = labels_1_1.value;
                    if (!selectedLabels.includes(label)) {
                        selectedLabels = selectedLabels.add(label);
                    }
                }
            }
            catch (e_4_1) { e_4 = { error: e_4_1 }; }
            finally {
                try {
                    if (labels_1_1 && !labels_1_1.done && (_a = labels_1.return)) _a.call(labels_1);
                }
                finally { if (e_4) throw e_4.error; }
            }
            _this.setState({ selectedLabels: selectedLabels });
        };
        _this.onChangeCategory = function (selectedCategory) {
            _this.setState({
                selectedCategory: selectedCategory,
            });
        };
        _this.onRemoveAllCells = function () {
            _this.setState({
                currentCells: immutable_1.Set(),
            });
        };
        _this.onRemoveCells = function (cellsToRemove) {
            var currentCells = _this.state.currentCells;
            _this.setState({
                currentCells: immutable_1.Set(currentCells.filter(function (cell) { return cell !== undefined && !cellsToRemove.includes(cell); })),
            });
        };
        _this.onRemoveLabel = function (label) {
            var selectedLabels = _this.state.selectedLabels;
            _this.setState({
                selectedLabels: selectedLabels.remove(label),
            });
        };
        _this.onRemoveLabels = function (labels) {
            var e_5, _a;
            var selectedLabels = _this.state.selectedLabels;
            try {
                for (var labels_2 = __values(labels), labels_2_1 = labels_2.next(); !labels_2_1.done; labels_2_1 = labels_2.next()) {
                    var label = labels_2_1.value;
                    selectedLabels = selectedLabels.remove(label);
                }
            }
            catch (e_5_1) { e_5 = { error: e_5_1 }; }
            finally {
                try {
                    if (labels_2_1 && !labels_2_1.done && (_a = labels_2.return)) _a.call(labels_2);
                }
                finally { if (e_5) throw e_5.error; }
            }
            _this.setState({
                selectedLabels: selectedLabels,
            });
        };
        _this.onSetCells = function (cells) {
            _this.setState({
                currentCells: immutable_1.Set(cells),
            });
        };
        _this.onToggleLabels = function (labels) {
            var e_6, _a;
            var selectedLabels = _this.state.selectedLabels;
            try {
                for (var labels_3 = __values(labels), labels_3_1 = labels_3.next(); !labels_3_1.done; labels_3_1 = labels_3.next()) {
                    var label = labels_3_1.value;
                    selectedLabels = selectedLabels.includes(label) ? selectedLabels.remove(label) : selectedLabels.add(label);
                }
            }
            catch (e_6_1) { e_6 = { error: e_6_1 }; }
            finally {
                try {
                    if (labels_3_1 && !labels_3_1.done && (_a = labels_3.return)) _a.call(labels_3);
                }
                finally { if (e_6) throw e_6.error; }
            }
            _this.setState({
                currentCells: _this.deriveCurrentCellsFromLabels(selectedLabels),
                selectedLabels: selectedLabels,
            });
        };
        _this.onUpdate = function (currentCells, selectedCategory) {
            _this.setState({
                currentCells: immutable_1.Set(currentCells),
                selectedCategory: selectedCategory ? selectedCategory : _this.state.selectedCategory,
                selectedLabels: _this.deriveValidLabelsFromCells(currentCells),
            });
        };
        _this.state = __assign({}, exports.initialSpringContext, { addLabel: _this.onAddLabel, addLabels: _this.onAddLabels, changeCategory: _this.onChangeCategory, removeAllCells: _this.onRemoveAllCells, removeCells: _this.onRemoveCells, removeLabel: _this.onRemoveLabel, removeLabels: _this.onRemoveLabels, setCells: _this.onSetCells, toggleLabels: _this.onToggleLabels, update: _this.onUpdate });
        return _this;
    }
    SpringContextProvider.prototype.componentDidMount = function () {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.setupData()];
                    case 1:
                        _a.sent();
                        return [2 /*return*/];
                }
            });
        });
    };
    SpringContextProvider.prototype.componentDidUpdate = function (prevProps) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!(this.props.datasetLocation !== prevProps.datasetLocation)) return [3 /*break*/, 2];
                        return [4 /*yield*/, this.setupData()];
                    case 1:
                        _a.sent();
                        _a.label = 2;
                    case 2: return [2 /*return*/];
                }
            });
        });
    };
    SpringContextProvider.prototype.render = function () {
        return React.createElement(exports.SpringContext.Provider, { value: this.state }, this.props.children);
    };
    SpringContextProvider.prototype.setupData = function () {
        return __awaiter(this, void 0, void 0, function () {
            var graphData_1, categories, labelsByCategory_1, e_7;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        _a.trys.push([0, 2, , 3]);
                        return [4 /*yield*/, helper_1.fetchSpringData("assets/datasets/" + this.props.datasetLocation)];
                    case 1:
                        graphData_1 = _a.sent();
                        categories = immutable_1.Set(graphData_1.nodes.length >= 1 ? Object.keys(graphData_1.nodes[0].labelForCategory) : []);
                        labelsByCategory_1 = new Map();
                        categories.forEach(function (category) {
                            if (category) {
                                var labels = immutable_1.Set(Array.from(graphData_1.nodes.map(function (node) { return node.labelForCategory[category]; })));
                                labelsByCategory_1.set(category, labels);
                            }
                        });
                        this.setState({
                            categories: categories,
                            graphData: graphData_1,
                            labelsByCategory: labelsByCategory_1,
                        });
                        return [3 /*break*/, 3];
                    case 2:
                        e_7 = _a.sent();
                        console.log(e_7);
                        return [3 /*break*/, 3];
                    case 3: return [2 /*return*/];
                }
            });
        });
    };
    return SpringContextProvider;
}(React.Component));
exports.SpringContextProvider = SpringContextProvider;


/***/ }),

/***/ "./src/context/index.ts":
/*!******************************!*\
  !*** ./src/context/index.ts ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./ChellContextProvider */ "./src/context/ChellContextProvider.tsx"));
__export(__webpack_require__(/*! ./CouplingContext */ "./src/context/CouplingContext.tsx"));
__export(__webpack_require__(/*! ./GenericContextProvider */ "./src/context/GenericContextProvider.tsx"));
__export(__webpack_require__(/*! ./ResidueContext */ "./src/context/ResidueContext.tsx"));
__export(__webpack_require__(/*! ./SecondaryStructureContext */ "./src/context/SecondaryStructureContext.tsx"));
__export(__webpack_require__(/*! ./SpringContext */ "./src/context/SpringContext.tsx"));


/***/ }),

/***/ "./src/data/AminoAcid.ts":
/*!*******************************!*\
  !*** ./src/data/AminoAcid.ts ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var Ala = { fullName: 'Alanine', singleLetterCode: 'A', threeLetterCode: 'ALA' };
var Arg = { fullName: 'Arginine', singleLetterCode: 'R', threeLetterCode: 'ARG' };
var Asn = { fullName: 'Asparagine', singleLetterCode: 'N', threeLetterCode: 'ASN' };
var Asp = { fullName: 'Aspartic Acid', singleLetterCode: 'D', threeLetterCode: 'ASP' };
var Cys = { fullName: 'Cysteine', singleLetterCode: 'C', threeLetterCode: 'CYS' };
var Gln = { fullName: 'Glutamine', singleLetterCode: 'Q', threeLetterCode: 'GLN' };
var Glu = { fullName: 'Glutamic Acid', singleLetterCode: 'E', threeLetterCode: 'GLU' };
var Gly = { fullName: 'Glycine', singleLetterCode: 'G', threeLetterCode: 'GLY' };
var His = { fullName: 'Histidine', singleLetterCode: 'H', threeLetterCode: 'HIS' };
var Ile = { fullName: 'Isoleucine', singleLetterCode: 'I', threeLetterCode: 'ILE' };
var Leu = { fullName: 'Leucine', singleLetterCode: 'L', threeLetterCode: 'LEU' };
var Lys = { fullName: 'Lysine', singleLetterCode: 'K', threeLetterCode: 'LYS' };
var Met = { fullName: 'Methionine', singleLetterCode: 'M', threeLetterCode: 'MET' };
var Phe = { fullName: 'Phenylalanine', singleLetterCode: 'F', threeLetterCode: 'PHE' };
var Pro = { fullName: 'Proline', singleLetterCode: 'P', threeLetterCode: 'PRO' };
var Ser = { fullName: 'Serine', singleLetterCode: 'S', threeLetterCode: 'SER' };
var Thr = { fullName: 'Threonine', singleLetterCode: 'T', threeLetterCode: 'THR' };
var Trp = { fullName: 'Tryptophan', singleLetterCode: 'W', threeLetterCode: 'TRP' };
var Tyr = { fullName: 'Tyrosine', singleLetterCode: 'Y', threeLetterCode: 'TYR' };
var Val = { fullName: 'Valine', singleLetterCode: 'V', threeLetterCode: 'VAL' };
// tslint:disable:object-literal-sort-keys
exports.AMINO_ACIDS_BY_SINGLE_LETTER_CODE = {
    A: Ala,
    R: Arg,
    N: Asn,
    D: Asp,
    C: Cys,
    Q: Gln,
    E: Glu,
    G: Gly,
    H: His,
    I: Ile,
    L: Leu,
    K: Lys,
    M: Met,
    F: Phe,
    P: Pro,
    S: Ser,
    T: Thr,
    W: Trp,
    Y: Tyr,
    V: Val,
};
// tslint:enable:object-literal-sort-keys
exports.AMINO_ACIDS_BY_THREE_LETTER_CODE = {
    ALA: Ala,
    ARG: Arg,
    ASN: Asn,
    ASP: Asp,
    CYS: Cys,
    GLN: Gln,
    GLU: Glu,
    GLY: Gly,
    HIS: His,
    ILE: Ile,
    LEU: Leu,
    LYS: Lys,
    MET: Met,
    PHE: Phe,
    PRO: Pro,
    SER: Ser,
    THR: Thr,
    TRP: Trp,
    TYR: Tyr,
    VAL: Val,
};
exports.AMINO_ACIDS = [
    Ala,
    Arg,
    Asn,
    Asp,
    Cys,
    Gln,
    Glu,
    Gly,
    His,
    Ile,
    Leu,
    Lys,
    Met,
    Phe,
    Pro,
    Ser,
    Thr,
    Trp,
    Tyr,
    Val,
];
exports.getPDBAndCouplingMismatch = function (pdbData, couplingScores) {
    var pdbSequence = pdbData.sequence;
    var couplingSequence = couplingScores.sequence;
    var mismatches = exports.getSequenceMismatch(pdbSequence, couplingSequence);
    if (mismatches.length === 0) {
        return pdbData.getResidueNumberingMismatches(couplingScores);
    }
    return mismatches;
};
exports.getSequenceMismatch = function (firstSequence, secondSequence) {
    var mismatches = new Array();
    if (firstSequence.length === secondSequence.length) {
        for (var i = 0; i < firstSequence.length; ++i) {
            var couplingAminoAcid = firstSequence[i];
            var pdbAminoAcid = secondSequence[i];
            if (couplingAminoAcid !== pdbAminoAcid) {
                mismatches.push({
                    firstAminoAcid: exports.AMINO_ACIDS_BY_SINGLE_LETTER_CODE[couplingAminoAcid],
                    resno: i,
                    secondAminoAcid: exports.AMINO_ACIDS_BY_SINGLE_LETTER_CODE[pdbAminoAcid],
                });
            }
        }
    }
    return mismatches;
};


/***/ }),

/***/ "./src/data/Chell1DSection.ts":
/*!************************************!*\
  !*** ./src/data/Chell1DSection.ts ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __values = (this && this.__values) || function (o) {
    var m = typeof Symbol === "function" && o[Symbol.iterator], i = 0;
    if (m) return m.call(o);
    return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
};
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Class to encapsulate a 1 Dimensional data segment.
 * This is defined as a numerical range with inclusive start, inclusive end, and label associated with it.
 * Additionally, a Section is defined such that [start <= end] - meaning values will be flipped to keep this constraint.
 *
 * @export
 */
var Chell1DSection = /** @class */ (function () {
    function Chell1DSection(label, start, end) {
        if (end === void 0) { end = start; }
        this.label = label;
        this.sectionEnd = 0;
        this.sectionStart = 0;
        this.sectionEnd = Math.max(end, start);
        this.sectionStart = Math.min(start, end);
    }
    Object.defineProperty(Chell1DSection.prototype, "end", {
        get: function () {
            return this.sectionEnd;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Chell1DSection.prototype, "length", {
        get: function () {
            return this.sectionEnd - this.sectionStart + 1;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Chell1DSection.prototype, "start", {
        get: function () {
            return this.sectionStart;
        },
        enumerable: true,
        configurable: true
    });
    Chell1DSection.prototype.contains = function () {
        var values = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            values[_i] = arguments[_i];
        }
        var e_1, _a;
        try {
            for (var values_1 = __values(values), values_1_1 = values_1.next(); !values_1_1.done; values_1_1 = values_1.next()) {
                var value = values_1_1.value;
                if (value < this.sectionStart || value > this.sectionEnd || value === undefined) {
                    return false;
                }
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (values_1_1 && !values_1_1.done && (_a = values_1.return)) _a.call(values_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
        return true;
    };
    Chell1DSection.prototype.updateStart = function (newNum) {
        if (newNum > this.sectionEnd) {
            this.sectionStart = this.sectionEnd;
            this.sectionEnd = newNum;
        }
        else {
            this.sectionStart = newNum;
        }
    };
    Chell1DSection.prototype.updateEnd = function (newNum) {
        if (newNum < this.sectionStart) {
            this.sectionEnd = this.sectionStart;
            this.sectionStart = newNum;
        }
        else {
            this.sectionEnd = newNum;
        }
    };
    return Chell1DSection;
}());
exports.Chell1DSection = Chell1DSection;


/***/ }),

/***/ "./src/data/ChellConfig.ts":
/*!*********************************!*\
  !*** ./src/data/ChellConfig.ts ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var CONFIGURATION_COMPONENT_TYPE;
(function (CONFIGURATION_COMPONENT_TYPE) {
    CONFIGURATION_COMPONENT_TYPE["BUTTON"] = "BUTTON";
    CONFIGURATION_COMPONENT_TYPE["LABEL"] = "LABEL";
    CONFIGURATION_COMPONENT_TYPE["RADIO"] = "RADIO";
    CONFIGURATION_COMPONENT_TYPE["SLIDER"] = "SLIDER";
})(CONFIGURATION_COMPONENT_TYPE = exports.CONFIGURATION_COMPONENT_TYPE || (exports.CONFIGURATION_COMPONENT_TYPE = {}));


/***/ }),

/***/ "./src/data/ChellData.ts":
/*!*******************************!*\
  !*** ./src/data/ChellData.ts ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var VIZ_TYPE;
(function (VIZ_TYPE) {
    VIZ_TYPE["CONTACT_MAP"] = "Contact Map";
    VIZ_TYPE["INFO_PANEL"] = "Info Panel";
    VIZ_TYPE["NGL"] = "NGL";
    VIZ_TYPE["SPRING"] = "Spring";
    VIZ_TYPE["TENSOR-T-SNE"] = "TENSOR-T-SNE";
    VIZ_TYPE["T-SNE"] = "T-SNE";
    VIZ_TYPE["T-SNE-FRAME"] = "T-SNE-FRAME";
})(VIZ_TYPE = exports.VIZ_TYPE || (exports.VIZ_TYPE = {}));
var CONTACT_DISTANCE_PROXIMITY;
(function (CONTACT_DISTANCE_PROXIMITY) {
    CONTACT_DISTANCE_PROXIMITY["CLOSEST"] = "CLOSEST";
    CONTACT_DISTANCE_PROXIMITY["C_ALPHA"] = "C-\u03B1";
})(CONTACT_DISTANCE_PROXIMITY = exports.CONTACT_DISTANCE_PROXIMITY || (exports.CONTACT_DISTANCE_PROXIMITY = {}));
var SECONDARY_STRUCTURE_CODES;
(function (SECONDARY_STRUCTURE_CODES) {
    SECONDARY_STRUCTURE_CODES["G"] = "310_HELIX";
    SECONDARY_STRUCTURE_CODES["H"] = "ALPHA_HELIX";
    SECONDARY_STRUCTURE_CODES["I"] = "PI_HELIX";
    SECONDARY_STRUCTURE_CODES["T"] = "HYDROGEN_BONDED_TURN";
    SECONDARY_STRUCTURE_CODES["E"] = "BETA_SHEET";
    SECONDARY_STRUCTURE_CODES["B"] = "BETA_BRIDGE";
    SECONDARY_STRUCTURE_CODES["S"] = "BEND";
    SECONDARY_STRUCTURE_CODES["C"] = "COIL";
})(SECONDARY_STRUCTURE_CODES = exports.SECONDARY_STRUCTURE_CODES || (exports.SECONDARY_STRUCTURE_CODES = {}));
var CHELL_CHART_EVENT_TYPE;
(function (CHELL_CHART_EVENT_TYPE) {
    CHELL_CHART_EVENT_TYPE[CHELL_CHART_EVENT_TYPE["AFTER_PLOT"] = 0] = "AFTER_PLOT";
    CHELL_CHART_EVENT_TYPE[CHELL_CHART_EVENT_TYPE["CLICK"] = 1] = "CLICK";
    CHELL_CHART_EVENT_TYPE[CHELL_CHART_EVENT_TYPE["DOUBLE_CLICK"] = 2] = "DOUBLE_CLICK";
    CHELL_CHART_EVENT_TYPE[CHELL_CHART_EVENT_TYPE["HOVER"] = 3] = "HOVER";
    CHELL_CHART_EVENT_TYPE[CHELL_CHART_EVENT_TYPE["RELAYOUT"] = 4] = "RELAYOUT";
    CHELL_CHART_EVENT_TYPE[CHELL_CHART_EVENT_TYPE["SELECTION"] = 5] = "SELECTION";
    CHELL_CHART_EVENT_TYPE[CHELL_CHART_EVENT_TYPE["UNHOVER"] = 6] = "UNHOVER";
})(CHELL_CHART_EVENT_TYPE = exports.CHELL_CHART_EVENT_TYPE || (exports.CHELL_CHART_EVENT_TYPE = {}));
var CHELL_CHART_PIECE;
(function (CHELL_CHART_PIECE) {
    CHELL_CHART_PIECE[CHELL_CHART_PIECE["AXIS"] = 0] = "AXIS";
    CHELL_CHART_PIECE[CHELL_CHART_PIECE["POINT"] = 1] = "POINT";
})(CHELL_CHART_PIECE = exports.CHELL_CHART_PIECE || (exports.CHELL_CHART_PIECE = {}));


/***/ }),

/***/ "./src/data/ChellPDB.ts":
/*!******************************!*\
  !*** ./src/data/ChellPDB.ts ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
var NGL = __webpack_require__(/*! ngl */ "./node_modules/ngl/dist/ngl.esm.js");
var data_1 = __webpack_require__(/*! ~chell-viz~/data */ "./src/data/index.ts");
/**
 * A ChellPDB instance provides an API to interact with a loaded PDB file while hiding the implementation details of how it is loaded.
 *
 * @export
 */
var ChellPDB = /** @class */ (function () {
    function ChellPDB() {
        this.fileName = '';
        this.nglData = new NGL.Structure();
    }
    ChellPDB.createEmptyPDB = function () {
        return new ChellPDB();
    };
    /**
     * Creates an instance of ChellPDB with PDB data.
     *
     * !IMPORTANT! Since fetching the data is an asynchronous action, this must be used to create a new instance!
     */
    ChellPDB.createPDB = function (file) {
        if (file === void 0) { file = ''; }
        return __awaiter(this, void 0, void 0, function () {
            var result, _a;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        result = new ChellPDB();
                        _a = result;
                        return [4 /*yield*/, NGL.autoLoad(file)];
                    case 1:
                        _a.nglData = (_b.sent());
                        result.fileName = typeof file === 'string' ? file : file.name;
                        return [2 /*return*/, result];
                }
            });
        });
    };
    ChellPDB.createPDBFromNGLData = function (nglData) {
        var result = new ChellPDB();
        result.nglData = nglData;
        return result;
    };
    Object.defineProperty(ChellPDB.prototype, "contactInformation", {
        get: function () {
            var _this = this;
            if (!this.contactInfo) {
                var result_1 = new data_1.CouplingContainer();
                this.nglData.eachResidue(function (outerResidue) {
                    if (outerResidue.isProtein()) {
                        var i_1 = outerResidue.resno;
                        _this.nglData.eachResidue(function (innerResidue) {
                            var j = innerResidue.resno;
                            if (innerResidue.isProtein() && i_1 !== j) {
                                result_1.addCouplingScore({
                                    dist: _this.getMinDistBetweenResidues(i_1, j).dist,
                                    i: i_1,
                                    j: j,
                                });
                            }
                        });
                    }
                });
                this.contactInfo = result_1;
            }
            return this.contactInfo;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ChellPDB.prototype, "nglStructure", {
        get: function () {
            return this.nglData;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ChellPDB.prototype, "secondaryStructure", {
        get: function () {
            var result = new Array();
            this.nglData.eachResidue(function (residue) {
                if (residue.isProtein()) {
                    var structId = 'C';
                    if (residue.isSheet()) {
                        structId = 'E';
                    }
                    else if (residue.isHelix()) {
                        structId = 'H';
                    }
                    else if (residue.isTurn()) {
                        return;
                    }
                    result.push({ resno: residue.resno, structId: structId });
                }
            });
            return result;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ChellPDB.prototype, "secondaryStructureSections", {
        get: function () {
            var result = new Array();
            this.nglData.eachResidue(function (residue) {
                if (residue.isProtein()) {
                    var chainIndex = residue.chainIndex;
                    while (!result[chainIndex]) {
                        result.push(new Array());
                    }
                    var structId = 'C';
                    if (residue.isSheet()) {
                        structId = 'E';
                    }
                    else if (residue.isHelix()) {
                        structId = 'H';
                    }
                    if (result[chainIndex].length >= 1 && result[chainIndex][result[chainIndex].length - 1].label === structId) {
                        result[chainIndex][result[chainIndex].length - 1].updateEnd(residue.resno);
                    }
                    else {
                        result[chainIndex].push(new data_1.Chell1DSection(structId, residue.resno));
                    }
                }
            });
            return result;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ChellPDB.prototype, "name", {
        get: function () {
            var splitName = this.fileName.split('/');
            var lastPart = splitName[splitName.length - 1];
            return lastPart.slice(0, lastPart.lastIndexOf('.'));
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ChellPDB.prototype, "sequence", {
        get: function () {
            return this.nglData ? this.nglData.getSequence().join('') : '';
        },
        enumerable: true,
        configurable: true
    });
    ChellPDB.prototype.eachResidue = function (callback) {
        this.nglData.eachResidue(callback);
    };
    /**
     * Given some existing coupling scores, a new CouplingContainer will be created with data augmented with info derived from this PDB.
     *
     * @param couplingScores A collection of coupling scores to be augmented.
     * @param measuredProximity How to calculate the distance between two residues.
     * @returns A CouplingContainer with contact information from both the original array and this PDB file.
     */
    ChellPDB.prototype.amendPDBWithCouplingScores = function (couplingScores, measuredProximity) {
        var _this = this;
        var result = new data_1.CouplingContainer(couplingScores);
        var alphaId = this.nglData.atomMap.dict[ChellPDB.NGL_C_ALPHA_INDEX];
        var minDist = {};
        this.nglData.eachResidue(function (outerResidue) {
            _this.nglData.eachResidue(function (innerResidue) {
                if (outerResidue.isProtein() && innerResidue.isProtein()) {
                    if (measuredProximity === data_1.CONTACT_DISTANCE_PROXIMITY.C_ALPHA) {
                        var firstResidueCAlphaIndex = _this.getCAlphaAtomIndexFromResidue(outerResidue.index, alphaId);
                        var secondResidueCAlphaIndex = _this.getCAlphaAtomIndexFromResidue(innerResidue.index, alphaId);
                        result.addCouplingScore({
                            dist: _this.nglData
                                .getAtomProxy(firstResidueCAlphaIndex)
                                .distanceTo(_this.nglData.getAtomProxy(secondResidueCAlphaIndex)),
                            i: outerResidue.resno,
                            j: innerResidue.resno,
                        });
                    }
                    else {
                        var key = Math.min(outerResidue.resno, innerResidue.resno) + "," + Math.max(outerResidue.resno, innerResidue.resno);
                        if (!minDist[key]) {
                            minDist[key] = _this.getMinDistBetweenResidueIndices(outerResidue.index, innerResidue.index).dist;
                        }
                        result.addCouplingScore({
                            dist: minDist[key],
                            i: outerResidue.resno,
                            j: innerResidue.resno,
                        });
                    }
                }
            });
        });
        this.contactInfo = result;
        return this.contactInfo;
    };
    /**
     * Find the index of the c-alpha atom for a given residue.
     *
     * @param residueIndex Index of the residue to find the c-alpha atom for.
     * @param alphaId Index that determines if an atom is a c-alpha.
     * @returns Index of the c-alpha atom with respect to the array of all of the atoms.
     */
    ChellPDB.prototype.getCAlphaAtomIndexFromResidue = function (residueIndex, alphaId) {
        var residueStore = this.nglData.residueStore;
        var atomOffset = residueStore.atomOffset[residueIndex];
        var atomCount = residueStore.atomCount[residueIndex];
        var result = atomOffset;
        while (residueStore.residueTypeId[result] !== alphaId && result < atomOffset + atomCount) {
            result++;
        }
        return result;
    };
    /**
     * Helper function to find the smallest possible distance between two residues via their atoms.
     *
     * @param resnoI The first residue.
     * @param resnoJ The second residue.
     * @returns Shortest distance between the two residues in ngstrms.
     */
    ChellPDB.prototype.getMinDistBetweenResidues = function (resnoI, resnoJ) {
        return this.getMinDistBetweenResidueIndices(this.nglData.residueStore.resno.indexOf(resnoI), this.nglData.residueStore.resno.indexOf(resnoJ));
    };
    ChellPDB.prototype.getResidueNumberingMismatches = function (contacts) {
        var result = new Array();
        this.eachResidue(function (residue) {
            var pdbResCode = residue.resname.toUpperCase();
            var couplingAminoAcid = contacts.getAminoAcidOfContact(residue.resno);
            if (couplingAminoAcid &&
                data_1.AMINO_ACIDS_BY_THREE_LETTER_CODE[pdbResCode] !==
                    data_1.AMINO_ACIDS_BY_SINGLE_LETTER_CODE[couplingAminoAcid.singleLetterCode]) {
                result.push({
                    firstAminoAcid: data_1.AMINO_ACIDS_BY_SINGLE_LETTER_CODE[couplingAminoAcid.singleLetterCode],
                    resno: residue.resno,
                    secondAminoAcid: data_1.AMINO_ACIDS_BY_THREE_LETTER_CODE[pdbResCode],
                });
            }
        });
        return result;
    };
    /**
     * Helper function to find the smallest possible distance between two residues via their atoms.
     *
     * @param indexI Index of the first residue with respect to the array of all residues.
     * @param indexJ Index of the second residue with respect to the array of all residues.
     * @returns Shortest distance between the two residues in ngstrms.
     */
    ChellPDB.prototype.getMinDistBetweenResidueIndices = function (indexI, indexJ) {
        var residueStore = this.nglData.residueStore;
        var firstResCount = residueStore.atomCount[indexI];
        var secondResCount = residueStore.atomCount[indexJ];
        var firstAtomIndex = residueStore.atomOffset[indexI];
        var secondAtomIndex = residueStore.atomOffset[indexJ];
        var result = {
            atomIndexI: -1,
            atomIndexJ: -1,
            dist: Number.MAX_SAFE_INTEGER,
        };
        for (var firstCounter = 0; firstCounter < firstResCount; ++firstCounter) {
            for (var secondCounter = 0; secondCounter < secondResCount; ++secondCounter) {
                var atomIndexI = firstAtomIndex + firstCounter;
                var atomIndexJ = secondAtomIndex + secondCounter;
                var dist = this.nglData.getAtomProxy(atomIndexI).distanceTo(this.nglData.getAtomProxy(atomIndexJ));
                if (dist < result.dist) {
                    result = {
                        atomIndexI: atomIndexI,
                        atomIndexJ: atomIndexJ,
                        dist: dist,
                    };
                }
            }
        }
        return result;
    };
    ChellPDB.NGL_C_ALPHA_INDEX = 'CA|C';
    return ChellPDB;
}());
exports.ChellPDB = ChellPDB;


/***/ }),

/***/ "./src/data/CouplingContainer.ts":
/*!***************************************!*\
  !*** ./src/data/CouplingContainer.ts ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __values = (this && this.__values) || function (o) {
    var m = typeof Symbol === "function" && o[Symbol.iterator], i = 0;
    if (m) return m.call(o);
    return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
};
Object.defineProperty(exports, "__esModule", { value: true });
var data_1 = __webpack_require__(/*! ~chell-viz~/data */ "./src/data/index.ts");
/**
 * A CouplingContainer provides access to the coupling information of residue pairs.
 *
 * Behind the scenes, it is backed by a sparse 2D array to avoid data duplication and provide O(1) access.
 *
 * @export
 */
var CouplingContainer = /** @class */ (function () {
    function CouplingContainer(scores) {
        var e_1, _a;
        if (scores === void 0) { scores = []; }
        var _this = this;
        this.contacts = new Array();
        /** How many distinct contacts are currently stored. */
        this.totalStoredContacts = 0;
        this.indexRange = {
            max: 50,
            min: 1,
        };
        /** Used for iterator access. */
        this.rowCounter = 0;
        /** Used for iterator access. */
        this.colCounter = 0;
        /**
         * Primary interface for getting a coupling score, provides access to the same data object regardless of order of (firstRes, secondRes).
         */
        this.getCouplingScore = function (firstRes, secondRes) {
            var row = _this.contacts[Math.min(firstRes, secondRes) - 1];
            return row ? row[Math.max(firstRes, secondRes) - 1] : undefined;
        };
        this.includes = function (firstRes, secondRes) {
            return _this.contacts[Math.min(firstRes, secondRes) - 1] &&
                _this.contacts[Math.min(firstRes, secondRes) - 1][Math.max(firstRes, secondRes) - 1] !== undefined;
        };
        try {
            for (var scores_1 = __values(scores), scores_1_1 = scores_1.next(); !scores_1_1.done; scores_1_1 = scores_1.next()) {
                var score = scores_1_1.value;
                this.addCouplingScore(score);
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (scores_1_1 && !scores_1_1.done && (_a = scores_1.return)) _a.call(scores_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
    }
    Object.defineProperty(CouplingContainer.prototype, "allContacts", {
        get: function () {
            return this.contacts;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CouplingContainer.prototype, "chainLength", {
        get: function () {
            return this.indexRange.max - this.indexRange.min + 1;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CouplingContainer.prototype, "rankedContacts", {
        get: function () {
            return Array.from(this).sort(function (a, b) {
                if (a.cn && b.cn) {
                    return b.cn - a.cn;
                }
                else if (a.cn && !b.cn) {
                    return -1;
                }
                else if (!a.cn && b.cn) {
                    return 1;
                }
                return 0;
            });
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CouplingContainer.prototype, "residueIndexRange", {
        get: function () {
            return this.indexRange;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CouplingContainer.prototype, "sequence", {
        get: function () {
            var result = '';
            for (var i = this.indexRange.min; i <= this.indexRange.max; ++i) {
                var aminoAcid = this.getAminoAcidOfContact(i);
                if (aminoAcid) {
                    result += aminoAcid.singleLetterCode;
                }
            }
            return result;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CouplingContainer.prototype, "totalContacts", {
        get: function () {
            return this.totalStoredContacts;
        },
        enumerable: true,
        configurable: true
    });
    CouplingContainer.prototype[Symbol.iterator] = function () {
        return this;
    };
    /**
     * Add a coupling score to this collection. If there is already an entry for this (i,j) contact, it will be overridden!
     *
     * @param score A Coupling Score to add to the collection.
     */
    CouplingContainer.prototype.addCouplingScore = function (score) {
        var A_i = score.A_i, A_j = score.A_j, i = score.i, j = score.j;
        var minResidueIndex = Math.min(i, j) - 1;
        var maxResidueIndex = Math.max(i, j) - 1;
        var isFlipped = minResidueIndex + 1 === j;
        if (!this.contacts[minResidueIndex]) {
            this.contacts[minResidueIndex] = new Array();
        }
        if (!this.contacts[minResidueIndex][maxResidueIndex]) {
            this.totalStoredContacts++;
        }
        this.contacts[minResidueIndex][maxResidueIndex] = __assign({}, this.contacts[minResidueIndex][maxResidueIndex], score);
        if (isFlipped) {
            this.contacts[minResidueIndex][maxResidueIndex].i = j;
            this.contacts[minResidueIndex][maxResidueIndex].j = i;
            if (A_i && A_j) {
                this.contacts[minResidueIndex][maxResidueIndex].A_i = A_j;
                this.contacts[minResidueIndex][maxResidueIndex].A_j = A_i;
            }
        }
        this.indexRange = {
            max: Math.max(this.indexRange.max, maxResidueIndex + 1),
            min: Math.min(this.indexRange.min, minResidueIndex + 1),
        };
    };
    CouplingContainer.prototype.getAminoAcidOfContact = function (resno) {
        var e_2, _a, e_3, _b;
        if (resno > this.chainLength + 1) {
            return undefined;
        }
        try {
            for (var _c = __values(this.allContacts), _d = _c.next(); !_d.done; _d = _c.next()) {
                var outerContact = _d.value;
                if (outerContact) {
                    try {
                        for (var outerContact_1 = __values(outerContact), outerContact_1_1 = outerContact_1.next(); !outerContact_1_1.done; outerContact_1_1 = outerContact_1.next()) {
                            var innerContact = outerContact_1_1.value;
                            if (innerContact && innerContact.i === resno && innerContact.A_i) {
                                return data_1.AMINO_ACIDS_BY_SINGLE_LETTER_CODE[innerContact.A_i];
                            }
                            else if (innerContact && innerContact.j === resno && innerContact.A_j) {
                                return data_1.AMINO_ACIDS_BY_SINGLE_LETTER_CODE[innerContact.A_j];
                            }
                        }
                    }
                    catch (e_3_1) { e_3 = { error: e_3_1 }; }
                    finally {
                        try {
                            if (outerContact_1_1 && !outerContact_1_1.done && (_b = outerContact_1.return)) _b.call(outerContact_1);
                        }
                        finally { if (e_3) throw e_3.error; }
                    }
                }
            }
        }
        catch (e_2_1) { e_2 = { error: e_2_1 }; }
        finally {
            try {
                if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
            }
            finally { if (e_2) throw e_2.error; }
        }
        return undefined;
    };
    /**
     * Determine which contacts in this coupling container are observed.
     *
     * @param [distFilter=5] For each score, if dist <= distFilter, it is considered observed.
     * @param [linearDistFilter=5] For each score, if |i - j| >= linearDistFilter, it will be a candidate for being correct/incorrect.
     * @returns Contacts that should be considered observed in the current data set.
     */
    CouplingContainer.prototype.getObservedContacts = function (distFilter, linearDistFilter) {
        if (distFilter === void 0) { distFilter = 5; }
        if (linearDistFilter === void 0) { linearDistFilter = 5; }
        var e_4, _a;
        var result = new Array();
        try {
            for (var _b = __values(this), _c = _b.next(); !_c.done; _c = _b.next()) {
                var score = _c.value;
                if (score.dist && score.dist <= distFilter && Math.abs(score.i - score.j) >= linearDistFilter) {
                    result.push(score);
                }
            }
        }
        catch (e_4_1) { e_4 = { error: e_4_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_4) throw e_4.error; }
        }
        return result;
    };
    /**
     * Determine which contacts in this coupling container are both predicted and correct.
     *
     * @param totalPredictionsToShow How many predictions, max, to return.
     * @param [linearDistFilter=5] For each score, if |i - j| >= linearDistFilter, it will be a candidate for being correct/incorrect.
     * @param [measuredContactDistFilter=5]  If the dist for the contact is less than predictionCutoffDist, it is considered correct.
     * @returns An object containing 2 array fields: correct and predicted.
     */
    CouplingContainer.prototype.getPredictedContacts = function (totalPredictionsToShow, linearDistFilter, measuredContactDistFilter) {
        if (linearDistFilter === void 0) { linearDistFilter = 5; }
        if (measuredContactDistFilter === void 0) { measuredContactDistFilter = 5; }
        var e_5, _a;
        var result = {
            correct: new Array(),
            predicted: new Array(),
        };
        try {
            for (var _b = __values(this.rankedContacts
                .filter(function (score) { return Math.abs(score.i - score.j) >= linearDistFilter; })
                .slice(0, totalPredictionsToShow)), _c = _b.next(); !_c.done; _c = _b.next()) {
                var contact = _c.value;
                if (contact.dist && contact.dist < measuredContactDistFilter) {
                    result.correct.push(contact);
                }
                result.predicted.push(contact);
            }
        }
        catch (e_5_1) { e_5 = { error: e_5_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_5) throw e_5.error; }
        }
        return result;
    };
    CouplingContainer.prototype.next = function () {
        for (var i = this.rowCounter; i < this.contacts.length; ++i) {
            if (this.contacts[i]) {
                for (var j = this.colCounter; j < this.contacts[i].length; ++j) {
                    var score = this.contacts[i][j];
                    if (score) {
                        this.rowCounter = i;
                        this.colCounter = j + 1;
                        return {
                            done: false,
                            value: score,
                        };
                    }
                }
                this.colCounter = 0;
            }
        }
        this.rowCounter = 0;
        this.colCounter = 0;
        return {
            done: true,
            value: null,
        };
    };
    CouplingContainer.prototype.updateContact = function (i, j, score) {
        this.addCouplingScore(__assign({ i: i, j: j }, score));
    };
    return CouplingContainer;
}());
exports.CouplingContainer = CouplingContainer;


/***/ }),

/***/ "./src/data/PlotlyData.ts":
/*!********************************!*\
  !*** ./src/data/PlotlyData.ts ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var PLOTLY_CHART_TYPE;
(function (PLOTLY_CHART_TYPE) {
    /** [Plotly Bar Chart](https://plot.ly/javascript/bar-charts/) */
    PLOTLY_CHART_TYPE["bar"] = "bar";
    /** [Plotly Point Cloud](https://plot.ly/javascript/pointcloud/) */
    PLOTLY_CHART_TYPE["pointcloud"] = "pointcloud";
    /** [Plotly Line/Scatter Chart](https://plot.ly/javascript/line-and-scatter/) */
    PLOTLY_CHART_TYPE["scatter"] = "scatter";
    /** [Plotly Line/Scatter Chart in WebGL](https://plot.ly/javascript/line-and-scatter/) */
    PLOTLY_CHART_TYPE["scattergl"] = "scattergl";
    /** [Plotly 3D Scatter Plot](https://plot.ly/javascript/3d-scatter-plots/) */
    PLOTLY_CHART_TYPE["scatter3d"] = "scatter3d";
})(PLOTLY_CHART_TYPE = exports.PLOTLY_CHART_TYPE || (exports.PLOTLY_CHART_TYPE = {}));


/***/ }),

/***/ "./src/data/Protein.ts":
/*!*****************************!*\
  !*** ./src/data/Protein.ts ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// cSpell:disable
// tslint:disable:max-line-length no-reserved-keywords
Object.defineProperty(exports, "__esModule", { value: true });
var PROTEIN_COMMENT_TYPE;
(function (PROTEIN_COMMENT_TYPE) {
    PROTEIN_COMMENT_TYPE[PROTEIN_COMMENT_TYPE["DISEASE"] = 0] = "DISEASE";
    PROTEIN_COMMENT_TYPE[PROTEIN_COMMENT_TYPE["DOMAIN"] = 1] = "DOMAIN";
    PROTEIN_COMMENT_TYPE[PROTEIN_COMMENT_TYPE["FUNCTION"] = 2] = "FUNCTION";
    PROTEIN_COMMENT_TYPE[PROTEIN_COMMENT_TYPE["INTERACTION"] = 3] = "INTERACTION";
    PROTEIN_COMMENT_TYPE[PROTEIN_COMMENT_TYPE["MIM"] = 4] = "MIM";
    PROTEIN_COMMENT_TYPE[PROTEIN_COMMENT_TYPE["PTM"] = 5] = "PTM";
    PROTEIN_COMMENT_TYPE[PROTEIN_COMMENT_TYPE["SIMILARITY"] = 6] = "SIMILARITY";
    PROTEIN_COMMENT_TYPE[PROTEIN_COMMENT_TYPE["SUBCELLULAR_LOCATION"] = 7] = "SUBCELLULAR_LOCATION";
    PROTEIN_COMMENT_TYPE[PROTEIN_COMMENT_TYPE["SUBUNIT"] = 8] = "SUBUNIT";
    PROTEIN_COMMENT_TYPE[PROTEIN_COMMENT_TYPE["WEBRESOURCE"] = 9] = "WEBRESOURCE";
})(PROTEIN_COMMENT_TYPE = exports.PROTEIN_COMMENT_TYPE || (exports.PROTEIN_COMMENT_TYPE = {}));


/***/ }),

/***/ "./src/data/TintedChell1DSection.ts":
/*!******************************************!*\
  !*** ./src/data/TintedChell1DSection.ts ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var data_1 = __webpack_require__(/*! ~chell-viz~/data */ "./src/data/index.ts");
/**
 * Class to encapsulate a 1 Dimensional data segment that has an associated color with it.
 *
 * @export
 * @extends Chell1DSection
 */
var TintedChell1DSection = /** @class */ (function (_super) {
    __extends(TintedChell1DSection, _super);
    function TintedChell1DSection(label, start, end, color) {
        if (end === void 0) { end = start; }
        if (color === void 0) { color = 'orange'; }
        var _this = _super.call(this, label, start, end) || this;
        _this.label = label;
        _this.sectionColor = 'orange';
        _this.sectionColor = color;
        return _this;
    }
    Object.defineProperty(TintedChell1DSection.prototype, "color", {
        get: function () {
            return this.sectionColor;
        },
        enumerable: true,
        configurable: true
    });
    TintedChell1DSection.prototype.updateColor = function (color) {
        this.sectionColor = color;
    };
    return TintedChell1DSection;
}(data_1.Chell1DSection));
exports.TintedChell1DSection = TintedChell1DSection;


/***/ }),

/***/ "./src/data/VizData.ts":
/*!*****************************!*\
  !*** ./src/data/VizData.ts ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var springExamples = [
    {
        icon: 'assets/icons/example_hpc_sf2-spring.png',
        link: '/dataset?name=hpc_sf2/full&viz=spring',
        name: 'HPC (hematopoietic progenitor cells)',
        summary: 'Analysis of 33,473 hematopoietic progenitor cells as they differentiate over 6 days.\
       Barcodes were introduced at day 0 and cell lineage relationships were traced by\
       identifying progeny from their barcodes in scRNAseq of aliquots of the same population taken at several timepoints.',
    },
    {
        icon: 'assets/icons/tabula-muris-thumbnail.png',
        link: '/dataset?name=tabula_muris/10k&viz=spring',
        name: 'CZI Tabula muris',
        summary: 'Analysis of 10K mouse cells from 20 organs and tissues.',
    },
    {
        icon: 'assets/icons/example_tabularmuris_spring-tsne-anatomogram.png',
        link: '/dataset?name=tabula_muris/10k&viz=spring&viz=tfjs-tsne&viz=anatomogram',
        name: 'Tabula Muris - SPRING vs tSNE with Anatomogram',
        summary: 'Example comparison of data reduction techniques SPRING and tSNE\
    (of top 30 PCA components), on RNAseq profiles from 10000 cells\
    from the CZI Tabula muris dataset. Also includes anatomogram visualization for selection of tissue types.',
    },
    {
        icon: 'assets/icons/example_HPC_spring-tsne-anatomogram.png',
        link: '/dataset?name=hpc/full&viz=spring&viz=tfjs-tsne&viz=anatomogram',
        name: 'HPC - SPRING vs tSNE with Anatomogram',
        summary: 'Example interaction between SPRING, tSNE and Anatomogram visualization on a small dataset.',
    },
];
var anatomogram = {
    authors: ['Alfonso Muoz-Pomer Fuentes'],
    citations: [],
    compatibility: [],
    detailedSummary: '',
    examples: [springExamples[2]],
    listAsOriginal: true,
    name: 'Anatomogram',
    relevantData: 'scRNA-seq',
    repo: { lastUpdate: '', link: 'https://github.com/ebi-gene-expression-group/anatomogram', version: '' },
    summary: 'Interactive anatomical diagram.',
};
var spring = {
    authors: ['Caleb Weinreb', 'Samuel Wolock', 'Allon Klein'],
    citations: [
        {
            fullCitation: 'Weinreb, Caleb, Samuel Wolock, and Allon M. Klein.\
      "SPRING: A kinetic interface for visualizing high dimensional single-cell expression data."\
      Bioinformatics 34.7 (2017): 1246-1248.',
            link: 'https://www.ncbi.nlm.nih.gov/pubmed/29228172',
        },
    ],
    compatibility: ['live tSNE', 'UMAP', 'PCA'],
    detailedSummary: 'SPRING is a tool for uncovering high-dimensional structure in single-cell gene expression data.\
   SPRING takes a (gene X cell) table of expression measurements and outputs a k-nearest-neighbor graph\
   rendered using a force directed layout.\
   Users can overlay prior information, including gene expression values, gene-set scores, cell cluster labels and sample IDs.\
   Users can also upload custom coordinates that have been generated using an outside program such as tSNE.',
    examples: springExamples,
    listAsOriginal: false,
    name: 'SPRING',
    relevantData: 'scRNA-seq',
    repo: {
        lastUpdate: '2018.03.12',
        link: 'https://github.com/AllonKleinLab/SPRING_dev',
        version: '2.0',
    },
    summary: 'SPRING is a tool for uncovering high-dimensional structure in single-cell expression data.',
};
var tfjsTsne = {
    authors: ['Yannick Assogba'],
    citations: [],
    compatibility: [],
    detailedSummary: '',
    examples: [springExamples[2], springExamples[3]],
    listAsOriginal: true,
    name: 'tfjs-tsne',
    relevantData: 'scRNA-seq',
    repo: { lastUpdate: '', link: 'https://github.com/tensorflow/tfjs-tsne', version: '' },
    summary: 'Improved tSNE implementation that runs in the browser.',
};
exports.VizData = {
    anatomogram: anatomogram,
    spring: spring,
    'tfjs-tsne': tfjsTsne,
    tfjsTsne: tfjsTsne,
};
exports.Stories = [
    {
        authors: ['Caleb Weinreb', 'Samuel Wolock', 'Allon Klein'],
        description: 'Analysis of 33,473 hematopoietic progenitor cells as they differentiate over 6 days.\
       Barcodes were introduced at day 0 and cell lineage relationships were traced by\
       identifying progeny from their barcodes in scRNAseq of aliquots of the same population taken at several timepoints.',
        icon: 'assets/icons/example_hpc_sf2-spring.png',
        link: '/dataset?name=hpc_sf2/full&viz=spring',
        title: 'Trajectory analysis of differentiating HPCs',
    },
    {
        authors: ['Drew Diamantoukos', 'Nicholas Gauthier'],
        description: 'Analysis of single cell transcriptomics of 20 mouse organs\
    from the tabula muris project.',
        icon: 'assets/icons/example_tabularmuris_spring-tsne-anatomogram.png',
        link: '/dataset?name=tabula_muris/10k&viz=spring&viz=tfjs-tsne&viz=anatomogram',
        title: 'Dimensionality-reduction analysis of tabula muris',
    },
];
exports.userDatasets = [
    {
        authors: ['Caleb Weinreb', 'Samuel Wolock', 'Allon klein'],
        links: {
            analysis: '',
            detail: '',
        },
        name: 'Differentiating hematopoietic cells',
        summary: 'Hematopoietic cells were subjected to barcoding and\
aliquots were subjected to scRNAseq as they underwent\
differentiation.',
    },
    {
        authors: ['The Tabula Muris Consortium'],
        links: {
            analysis: '',
            detail: '',
        },
        name: 'Tabula muris - scRNAseq of 20 mouse organs',
        summary: 'A compendium of single-cell transcriptomic data from the\
  model organism Mus musculus that comprises more than\
  100,000 cells from 20 organs and tissues',
    },
];
exports.DatasetData = {
    'hpc/full': {
        description: 'Analysis of the RNAseq proles from 4790 hematopoietic progenitor cells',
        enabled: true,
        fullName: 'Hematopoietic progenitor cells',
        serverNeeded: false,
    },
    'hpc_sf2/full': {
        description: 'Analysis of 33,473 the transcriptional prole of hematopoietic\
    progenitor cells as they dierentiate over 6 days',
        enabled: true,
        fullName: 'Hematopoietic progenitor cells',
        serverNeeded: false,
    },
    'tabula_muris/10k': {
        description: 'A subset pf 10,000 randomly sampled cells taken from the full\
  tabula_muris dataset (20 organs and tissues from Mus musculus)',
        enabled: true,
        fullName: 'Tabula muris',
        serverNeeded: false,
    },
    'tabula_muris/full': {
        description: 'A compendium of single-cell transcriptomic data from the\
  model organism Mus musculus that comprises more than\
  100,000 cells from 20 organs and tissues',
        enabled: false,
        fullName: 'Tabula muris',
        serverNeeded: true,
    },
    'tabula_muris/lung': {
        description: 'Analysis of the RNAseq proles from 4790 hematopoietic\
  progenitor cells',
        enabled: false,
        fullName: 'Tabula muris',
        serverNeeded: true,
    },
};


/***/ }),

/***/ "./src/data/event/ChellChartEvent.ts":
/*!*******************************************!*\
  !*** ./src/data/event/ChellChartEvent.ts ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var data_1 = __webpack_require__(/*! ~chell-viz~/data */ "./src/data/index.ts");
var ChellChartEvent = /** @class */ (function () {
    function ChellChartEvent(
    // tslint:disable-next-line:no-reserved-keywords
    type, chartPiece, selectedPoints, plotlyEvent) {
        if (selectedPoints === void 0) { selectedPoints = []; }
        if (plotlyEvent === void 0) { plotlyEvent = {}; }
        this.type = type;
        this.chartPiece = chartPiece;
        this.selectedPoints = selectedPoints;
        this.plotlyEvent = plotlyEvent;
    }
    ChellChartEvent.prototype.isAxis = function () {
        return this.chartPiece === data_1.CHELL_CHART_PIECE.AXIS;
    };
    return ChellChartEvent;
}());
exports.ChellChartEvent = ChellChartEvent;


/***/ }),

/***/ "./src/data/event/index.ts":
/*!*********************************!*\
  !*** ./src/data/event/index.ts ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./ChellChartEvent */ "./src/data/event/ChellChartEvent.ts"));


/***/ }),

/***/ "./src/data/index.ts":
/*!***************************!*\
  !*** ./src/data/index.ts ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./AminoAcid */ "./src/data/AminoAcid.ts"));
__export(__webpack_require__(/*! ./Chell1DSection */ "./src/data/Chell1DSection.ts"));
__export(__webpack_require__(/*! ./ChellConfig */ "./src/data/ChellConfig.ts"));
__export(__webpack_require__(/*! ./ChellData */ "./src/data/ChellData.ts"));
__export(__webpack_require__(/*! ./ChellPDB */ "./src/data/ChellPDB.ts"));
__export(__webpack_require__(/*! ./CouplingContainer */ "./src/data/CouplingContainer.ts"));
__export(__webpack_require__(/*! ./PlotlyData */ "./src/data/PlotlyData.ts"));
__export(__webpack_require__(/*! ./Protein */ "./src/data/Protein.ts"));
__export(__webpack_require__(/*! ./TintedChell1DSection */ "./src/data/TintedChell1DSection.ts"));
__export(__webpack_require__(/*! ./VizData */ "./src/data/VizData.ts"));
__export(__webpack_require__(/*! ./event */ "./src/data/event/index.ts"));


/***/ }),

/***/ "./src/helper/ColorMapper.ts":
/*!***********************************!*\
  !*** ./src/helper/ColorMapper.ts ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Class to allow a mapping between a type and a color.
 *
 * @export
 */
var ColorMapper = /** @class */ (function () {
    function ColorMapper(colors) {
        if (colors === void 0) { colors = ColorMapper.DEFAULT_COLORS; }
        this.colors = colors;
        /**
         * Used to associate keys with a Color.
         */
        this.colorMap = new Map();
    }
    /**
     * Get the color for the provided key - if the key isn't stored, it will be added using the set of colors for this mapper.
     */
    ColorMapper.prototype.getColorFor = function (key) {
        if (!this.colorMap.has(key)) {
            this.addColorToMapper(key);
        }
        return this.colorMap.get(key);
    };
    /**
     * Method to allow a user to just add an entry to the colorMapper.
     *
     * @param key Key to store.
     * @param [color] Allows a color to be explicitly set for this key.
     * @param [addToColors] Flag to allow/disallow color to be added to set of colors used by this ColorMapper.
     */
    ColorMapper.prototype.addEntry = function (key, color, addToColors) {
        if (addToColors === void 0) { addToColors = true; }
        if (!this.colorMap.has(key)) {
            this.addColorToMapper(key, color, addToColors);
        }
    };
    /**
     * Sets the entry for the internal ColorMapper Map.
     * @param key Key to add
     * @param [color] Explicit color to use if provided.
     * @param [addToColors] Flag to allow/disallow color to be added to set of colors used by this ColorMapper.
     */
    ColorMapper.prototype.addColorToMapper = function (key, color, addToColors) {
        this.colorMap.set(key, color ? color : this.colors[this.colorMap.size % this.colors.length]);
        if (color && addToColors && !this.colors.includes(color)) {
            this.colors.push(color);
        }
    };
    ColorMapper.DEFAULT_COLORS = [
        'red',
        'green',
        'blue',
        'orange',
        'purple',
        'teal',
        'pink',
        'yellow',
        'violet',
        'olive',
        'brown',
    ];
    return ColorMapper;
}());
exports.ColorMapper = ColorMapper;


/***/ }),

/***/ "./src/helper/CouplingMapper.ts":
/*!**************************************!*\
  !*** ./src/helper/CouplingMapper.ts ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var generateDefaultHeaderIndices = function (items) { return ({
    A_i: items.length - 2,
    A_j: items.length - 1,
    cn: 2,
    dist: 3,
    i: 0,
    j: 1,
}); };
// tslint:disable-next-line:export-name
exports.getCouplingHeaderIndices = function (items, areHeadersPresent) {
    if (!areHeadersPresent) {
        return generateDefaultHeaderIndices(items);
    }
    else {
        var result_1 = {};
        items.filter(function (item) { return item.length >= 1; }).map(function (header) {
            // Trim to remove whitespace, newlines, carriage returns, etc.
            result_1[header.trim()] = items.indexOf(header);
        });
        return result_1;
    }
};


/***/ }),

/***/ "./src/helper/DataHelper.ts":
/*!**********************************!*\
  !*** ./src/helper/DataHelper.ts ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __values = (this && this.__values) || function (o) {
    var m = typeof Symbol === "function" && o[Symbol.iterator], i = 0;
    if (m) return m.call(o);
    return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
};
var _this = this;
Object.defineProperty(exports, "__esModule", { value: true });
var NGL = __webpack_require__(/*! ngl */ "./node_modules/ngl/dist/ngl.esm.js");
var data_1 = __webpack_require__(/*! ~chell-viz~/data */ "./src/data/index.ts");
var helper_1 = __webpack_require__(/*! ~chell-viz~/helper */ "./src/helper/index.ts");
exports.fetchAppropriateData = function (viz, dataDir) { return __awaiter(_this, void 0, void 0, function () {
    return __generator(this, function (_a) {
        switch (viz) {
            case data_1.VIZ_TYPE['T-SNE']:
            case data_1.VIZ_TYPE['T-SNE-FRAME']:
                return [2 /*return*/, exports.fetchTSneCoordinateData(dataDir)];
            case data_1.VIZ_TYPE['TENSOR-T-SNE']:
                return [2 /*return*/, exports.fetchTensorTSneCoordinateData(dataDir)];
            case data_1.VIZ_TYPE.SPRING:
                return [2 /*return*/, exports.fetchSpringData(dataDir)];
            case data_1.VIZ_TYPE.NGL:
                return [2 /*return*/, exports.fetchNGLDataFromDirectory(dataDir)];
            case data_1.VIZ_TYPE.CONTACT_MAP:
            case data_1.VIZ_TYPE.INFO_PANEL:
                return [2 /*return*/, exports.fetchContactMapData(dataDir)];
            default:
                return [2 /*return*/, Promise.reject({ error: "Currently no appropriate data getter for " + viz })];
        }
        return [2 /*return*/];
    });
}); };
exports.fetchAppropriateDataFromFile = function (viz, file) { return __awaiter(_this, void 0, void 0, function () {
    var _a, _b, _c;
    return __generator(this, function (_d) {
        switch (_d.label) {
            case 0:
                _a = viz;
                switch (_a) {
                    case data_1.VIZ_TYPE.NGL: return [3 /*break*/, 1];
                    case data_1.VIZ_TYPE.CONTACT_MAP: return [3 /*break*/, 2];
                }
                return [3 /*break*/, 4];
            case 1: return [2 /*return*/, exports.fetchNGLDataFromFile(file)];
            case 2:
                _b = {};
                _c = exports.getCouplingScoresData;
                return [4 /*yield*/, helper_1.readFileAsText(file)];
            case 3: return [2 /*return*/, (_b.couplingScores = _c.apply(void 0, [_d.sent()]), _b)];
            case 4: return [2 /*return*/, Promise.reject({ error: "Currently no appropriate data getter for " + viz + " files" })];
        }
    });
}); };
exports.fetchSpringData = function (dataDir) { return __awaiter(_this, void 0, void 0, function () {
    var catColorData, nodes, categories;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0: return [4 /*yield*/, fetchCategoricalColorData(dataDir + "/categorical_coloring_data.json")];
            case 1:
                catColorData = _a.sent();
                nodes = new Array();
                categories = Object.keys(catColorData);
                catColorData[categories[0]].label_list.forEach(function (label, index) {
                    nodes.push({
                        labelForCategory: categories.reduce(function (prev, category) {
                            var _a;
                            return (__assign({}, prev, (_a = {}, _a[category] = catColorData[category].label_list[index], _a)));
                        }, {}),
                        number: index,
                    });
                });
                return [2 /*return*/, { nodes: nodes }];
        }
    });
}); };
var fetchCategoricalColorData = function (file) { return __awaiter(_this, void 0, void 0, function () {
    var e_1, _a, e_2, _b, input, result, _c, _d, key, colorData, output, label_colors, _e, _f, labelColorKey, hex;
    return __generator(this, function (_g) {
        switch (_g.label) {
            case 0: return [4 /*yield*/, helper_1.fetchJSONFile(file)];
            case 1:
                input = (_g.sent());
                result = {};
                try {
                    for (_c = __values(Object.keys(input)), _d = _c.next(); !_d.done; _d = _c.next()) {
                        key = _d.value;
                        colorData = input[key];
                        if (!colorData.label_colors || !colorData.label_list) {
                            throw new Error("Unable to parse color data - does it have keys named 'label_colors' and 'label_list'");
                        }
                        output = {
                            label_colors: {},
                            label_list: colorData.label_list,
                        };
                        label_colors = input[Object.keys(input)[0]].label_colors;
                        try {
                            // The input file might specify hex values as either 0xrrggbb or #rrggbb, so we need to convert the input to a consistent output format.
                            for (_e = __values(Object.keys(label_colors)), _f = _e.next(); !_f.done; _f = _e.next()) {
                                labelColorKey = _f.value;
                                hex = label_colors[labelColorKey];
                                if (typeof hex === 'number') {
                                    output.label_colors[labelColorKey] = hex;
                                }
                                else if (hex.charAt(0) === '#') {
                                    output.label_colors[labelColorKey] = Number.parseInt("0x" + hex.slice(1), 16);
                                }
                                else {
                                    output.label_colors[labelColorKey] = Number.parseInt(hex, 16);
                                }
                            }
                        }
                        catch (e_2_1) { e_2 = { error: e_2_1 }; }
                        finally {
                            try {
                                if (_f && !_f.done && (_b = _e.return)) _b.call(_e);
                            }
                            finally { if (e_2) throw e_2.error; }
                        }
                        result[key] = output;
                    }
                }
                catch (e_1_1) { e_1 = { error: e_1_1 }; }
                finally {
                    try {
                        if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
                    }
                    finally { if (e_1) throw e_1.error; }
                }
                return [2 /*return*/, result];
        }
    });
}); };
exports.fetchSpringCoordinateData = function (file) { return __awaiter(_this, void 0, void 0, function () {
    var coordinateText, coordinates, rows;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0: return [4 /*yield*/, helper_1.fetchCSVFile(file)];
            case 1:
                coordinateText = _a.sent();
                coordinates = [];
                rows = coordinateText ? coordinateText.split('\n') : [];
                rows.forEach(function (entry, index, array) {
                    var items = entry.split(',');
                    if (items.length >= 3) {
                        var xx = parseFloat(items[1].trim());
                        var yy = parseFloat(items[2].trim());
                        var nn = parseInt(items[0].trim(), 10);
                        coordinates[nn] = [xx, yy];
                    }
                    else if (entry.localeCompare('') !== 0) {
                        throw new Error("Unable to parse coordinate data - Row " + index + " does not have at least 3 columns!");
                    }
                });
                return [2 /*return*/, coordinates];
        }
    });
}); };
exports.fetchTSneCoordinateData = function (dataDir) { return __awaiter(_this, void 0, void 0, function () {
    var coordText, result;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0: return [4 /*yield*/, helper_1.fetchCSVFile(dataDir + "/tsne_output.csv")];
            case 1:
                coordText = _a.sent();
                result = [];
                coordText.split('\n').forEach(function (entry) {
                    if (entry.length > 0) {
                        var items = entry.split(',');
                        var coordinates = [parseFloat(items[0]), parseFloat(items[1])];
                        result.push(coordinates);
                    }
                });
                return [2 /*return*/, result];
        }
    });
}); };
exports.fetchTensorTSneCoordinateDataFromFile = function (fileLocation) { return __awaiter(_this, void 0, void 0, function () {
    var e_3, _a, coordText, matrix, _b, _c, row;
    return __generator(this, function (_d) {
        switch (_d.label) {
            case 0: return [4 /*yield*/, helper_1.fetchCSVFile(fileLocation)];
            case 1:
                coordText = _d.sent();
                matrix = new Array();
                try {
                    for (_b = __values(coordText.split('\n')), _c = _b.next(); !_c.done; _c = _b.next()) {
                        row = _c.value;
                        if (row.length >= 1) {
                            matrix.push(row.split(',').map(parseFloat));
                        }
                    }
                }
                catch (e_3_1) { e_3 = { error: e_3_1 }; }
                finally {
                    try {
                        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                    }
                    finally { if (e_3) throw e_3.error; }
                }
                return [2 /*return*/, matrix];
        }
    });
}); };
exports.fetchTensorTSneCoordinateData = function (dataDir) { return __awaiter(_this, void 0, void 0, function () {
    return __generator(this, function (_a) {
        return [2 /*return*/, exports.fetchTensorTSneCoordinateDataFromFile(dataDir + "/tsne_matrix.csv")];
    });
}); };
exports.fetchGraphData = function (file) { return __awaiter(_this, void 0, void 0, function () {
    var data;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0: return [4 /*yield*/, helper_1.fetchJSONFile(file)];
            case 1:
                data = (_a.sent());
                if (!data.nodes || !data.links) {
                    throw new Error("Unable to parse graph data - does it have keys named 'nodes' and 'links'");
                }
                return [2 /*return*/, data];
        }
    });
}); };
exports.fetchNGLDataFromDirectory = function (dir) { return __awaiter(_this, void 0, void 0, function () {
    var file;
    return __generator(this, function (_a) {
        if (dir.length === 0) {
            return [2 /*return*/, Promise.reject('Empty path.')];
        }
        file = dir + "/protein.pdb";
        return [2 /*return*/, exports.fetchNGLDataFromFile(file)];
    });
}); };
exports.fetchNGLDataFromFile = function (file, params) {
    if (params === void 0) { params = {}; }
    return __awaiter(_this, void 0, void 0, function () { return __generator(this, function (_a) {
        switch (_a.label) {
            case 0: return [4 /*yield*/, NGL.autoLoad(file, params)];
            case 1: return [2 /*return*/, (_a.sent())];
        }
    }); });
};
exports.fetchContactMapData = function (dir) { return __awaiter(_this, void 0, void 0, function () {
    var contactMapFiles, promiseResults, pdbData;
    var _this = this;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                if (dir.length === 0) {
                    return [2 /*return*/, Promise.reject('Empty path.')];
                }
                contactMapFiles = ['coupling_scores.csv', 'residue_mapping.csv'];
                return [4 /*yield*/, Promise.all(contactMapFiles.map(function (file) { return __awaiter(_this, void 0, void 0, function () { return __generator(this, function (_a) {
                        return [2 /*return*/, helper_1.fetchCSVFile(dir + "/" + file)];
                    }); }); }))];
            case 1:
                promiseResults = _a.sent();
                return [4 /*yield*/, data_1.ChellPDB.createPDB(dir + "/protein.pdb")];
            case 2:
                pdbData = _a.sent();
                return [2 /*return*/, {
                        couplingScores: exports.getCouplingScoresData(promiseResults[0], helper_1.generateResidueMapping(promiseResults[1])),
                        pdbData: pdbData,
                        secondaryStructures: [],
                    }];
        }
    });
}); };
/**
 * Parses a coupling_scores.csv file to generate the appropriate data structure.
 *
 * !Important!
 * Currently 12 fields are assumed to be part of a single coupling score.
 * As such, any rows with less will be ignored.
 *
 * @param line The csv file as a single string.
 * @param residueMapping Maps the coupling_score.csv residue number to the residue number for the PDB.
 * @returns Array of CouplingScores suitable for chell-viz consumption.
 */
exports.getCouplingScoresData = function (line, residueMapping) {
    if (residueMapping === void 0) { residueMapping = []; }
    var headerRow = line.split('\n')[0].split(',');
    var isHeaderPresent = isCouplingHeaderPresent(headerRow);
    var headerIndices = helper_1.getCouplingHeaderIndices(headerRow, isHeaderPresent);
    var couplingScores = new data_1.CouplingContainer();
    line
        .split('\n')
        .slice(isHeaderPresent ? 1 : 0)
        .filter(function (row) { return row.split(',').length >= 2; })
        .map(function (row) {
        var items = row.split(',');
        var score = getCouplingScoreFromCSVRow(items, headerIndices);
        if (residueMapping.length >= 1) {
            var mappingIndexI = residueMapping.findIndex(function (mapping) { return mapping.couplingsResno === score.i; });
            var mappingIndexJ = residueMapping.findIndex(function (mapping) { return mapping.couplingsResno === score.j; });
            couplingScores.addCouplingScore(__assign({}, score, { A_i: residueMapping[mappingIndexI].pdbResCode, A_j: residueMapping[mappingIndexJ].pdbResCode, i: residueMapping[mappingIndexI].pdbResno, j: residueMapping[mappingIndexJ].pdbResno }));
        }
        else {
            couplingScores.addCouplingScore(score);
        }
    });
    return couplingScores;
};
var isCouplingHeaderPresent = function (headerRow) {
    return ['cn', 'dist', 'i', 'j'].filter(function (row) { return headerRow.includes(row); }).length >= 1;
};
var getCouplingScoreFromCSVRow = function (row, headerIndices) {
    return Object.entries(headerIndices).reduce(function (prev, headerName) {
        var _a;
        var couplingKey = headerName[0];
        var couplingKeyIndex = headerName[1];
        return __assign({}, prev, (_a = {}, _a[couplingKey] = isNaN(Number(row[couplingKeyIndex])) ? row[couplingKeyIndex] : Number(row[couplingKeyIndex]), _a));
    }, { i: -1, j: -1 });
};
exports.augmentCouplingScoresWithResidueMapping = function (couplingScores, residueMapping) {
    if (residueMapping === void 0) { residueMapping = []; }
    var e_4, _a;
    var result = new data_1.CouplingContainer();
    var _loop_1 = function (score) {
        var mappedIndexI = residueMapping.findIndex(function (mapping) { return mapping.couplingsResno === score.i; });
        var mappedIndexJ = residueMapping.findIndex(function (mapping) { return mapping.couplingsResno === score.j; });
        result.addCouplingScore({
            A_i: residueMapping[mappedIndexI].pdbResCode,
            A_j: residueMapping[mappedIndexJ].pdbResCode,
            cn: score.cn,
            dist: score.dist,
            i: residueMapping[mappedIndexI].pdbResno,
            j: residueMapping[mappedIndexJ].pdbResno,
        });
    };
    try {
        for (var couplingScores_1 = __values(couplingScores), couplingScores_1_1 = couplingScores_1.next(); !couplingScores_1_1.done; couplingScores_1_1 = couplingScores_1.next()) {
            var score = couplingScores_1_1.value;
            _loop_1(score);
        }
    }
    catch (e_4_1) { e_4 = { error: e_4_1 }; }
    finally {
        try {
            if (couplingScores_1_1 && !couplingScores_1_1.done && (_a = couplingScores_1.return)) _a.call(couplingScores_1);
        }
        finally { if (e_4) throw e_4.error; }
    }
    return result;
};
/**
 * Parses a distance_map.csv file to generate the appropriate secondary structure mapping.
 *
 * !Important!
 * The first line in the csv will be ignored as it is assumed to be a csv header.
 *
 * !Important!
 * Currently 3 fields are assumed to be part of a single entry, with the second and third actually being relevant.
 * As such, any other rows will be ignored.
 *
 * @param line The csv file as a single string.
 * @returns Array of SecondaryStructure mappings suitable for chell-viz consumption.
 */
exports.getSecondaryStructureData = function (line) {
    return line
        .split('\n')
        .slice(1)
        .filter(function (row) { return row.split(',').length >= 3; })
        .map(function (row) {
        var items = row.split(',');
        return {
            resno: parseFloat(items[1]),
            structId: items[2],
        };
    });
};
/*
TODO Currently not being used by Spring. Remove? Use in future Spring work?
export const fetchColorData = async (file: string) => {
  const colorText: string = await fetchCSVFile(file);
  const dict: { [k: string]: any } = {};
  colorText.split('\n').forEach((entry, index, array) => {
    if (entry.length > 0) {
      const items = entry.split(',');
      const gene = items[0];
      const expArray: any[] = [];
      items.forEach((e, i, a) => {
        if (i > 0) {
          expArray.push(parseFloat(e));
        }
      });
      dict[gene] = expArray;
    }
  });
  return dict;
};
*/


/***/ }),

/***/ "./src/helper/FetchHelper.ts":
/*!***********************************!*\
  !*** ./src/helper/FetchHelper.ts ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var _this = this;
Object.defineProperty(exports, "__esModule", { value: true });
exports.fetchCSVFile = function (filename) { return __awaiter(_this, void 0, void 0, function () {
    var response;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0: return [4 /*yield*/, fetch(filename)];
            case 1:
                response = _a.sent();
                if (response.ok) {
                    return [2 /*return*/, response.text()];
                }
                else {
                    throw new Error(genErrorMsg('CSV', response));
                }
                return [2 /*return*/];
        }
    });
}); };
exports.fetchJSONFile = function (filename) { return __awaiter(_this, void 0, void 0, function () {
    var response;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0: return [4 /*yield*/, fetch(filename)];
            case 1:
                response = _a.sent();
                if (response.ok) {
                    return [2 /*return*/, response.json()];
                }
                else {
                    throw new Error(genErrorMsg('JSON', response));
                }
                return [2 /*return*/];
        }
    });
}); };
var genErrorMsg = function (fileType, response) {
    return "Chell-viz error fetching " + fileType + " File!\nStatus: " + response.status + "\nMessage: " + response.statusText + "\n";
};
// https://blog.shovonhasan.com/using-promises-with-filereader/
exports.readFileAsText = function (inputFile) { return __awaiter(_this, void 0, void 0, function () {
    var temporaryFileReader;
    return __generator(this, function (_a) {
        temporaryFileReader = new FileReader();
        return [2 /*return*/, new Promise(function (resolve, reject) {
                temporaryFileReader.onerror = function () {
                    temporaryFileReader.abort();
                    reject('Problem parsing input file.');
                };
                temporaryFileReader.onload = function () {
                    resolve(temporaryFileReader.result);
                };
                temporaryFileReader.readAsText(inputFile);
            })];
    });
}); };


/***/ }),

/***/ "./src/helper/NGLHelper.ts":
/*!*********************************!*\
  !*** ./src/helper/NGLHelper.ts ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.defaultRepParams = {
    color: 'red',
    labelBackground: true,
    labelBackgroundColor: 'lightgrey',
    labelBackgroundMargin: 0.75,
    labelBorder: true,
    labelBorderColor: 'white',
    labelBorderWidth: 0.3,
    labelColor: 'black',
    labelSize: 5,
    labelUnit: 'angstrom',
    labelZOffset: 35,
};
/**
 * Draws a line between two residues in NGL.
 *
 * @param structureComponent The NGL Structure for which these residues belong to.
 * @param selection The [NGL Selection](http://nglviewer.org/ngl/api/manual/selection-language.html) defining the residues.
 */
exports.createDistanceRepresentation = function (structureComponent, selection, params) {
    if (params === void 0) { params = {}; }
    return structureComponent.addRepresentation('distance', __assign({}, exports.defaultRepParams, params, { atomPair: Array.isArray(selection) ? [selection] : [selection.split(',')] }));
};
/**
 * Marks a set of residues with a ball+stick representation in NGL.
 *
 * @param structureComponent The NGL Structure for which these residues belong to.
 * @param residues The residues to mark.
 */
exports.createBallStickRepresentation = function (structureComponent, residues) {
    return structureComponent.addRepresentation('ball+stick', {
        sele: residues.join(', '),
    });
};
/**
 * Highlights a secondary structure in NGL.
 *
 * @param structureComponent The NGL Structure for which these residues belong to.
 * @param section The secondary structure section to highlight.
 * @param [radiusScale=5] How large to make the ribbon highlight.
 * @param [color='pink'] The color of the ribbon highlight.
 */
exports.createSecStructRepresentation = function (structureComponent, section, radiusScale, color) {
    if (radiusScale === void 0) { radiusScale = 2; }
    if (color === void 0) { color = '#feb83f'; }
    var rep = structureComponent.addRepresentation('cartoon', {
        color: color,
        radiusScale: radiusScale,
        sele: section.start + "-" + section.end,
    });
    rep.setParameters({ wireframe: true });
    return rep;
};


/***/ }),

/***/ "./src/helper/PlotlyHelper.ts":
/*!************************************!*\
  !*** ./src/helper/PlotlyHelper.ts ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spread = (this && this.__spread) || function () {
    for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));
    return ar;
};
Object.defineProperty(exports, "__esModule", { value: true });
var data_1 = __webpack_require__(/*! ~chell-viz~/data */ "./src/data/index.ts");
/**
 * Generate data in the expected format for a WebGL Scatter plot.
 *
 * @param entry A unit of Plotly data containing points, color, name, and any extras.
 * @param mirrorPoints Should we mirror the points on the x/y axis?
 * @returns Data suitable for consumption by Plotly.
 */
exports.generateScatterGLData = function (entry, mirrorPoints) {
    if (mirrorPoints === void 0) { mirrorPoints = false; }
    return (__assign({}, exports.generateScatterData(entry, mirrorPoints), { type: data_1.PLOTLY_CHART_TYPE.scattergl }));
};
/**
 * Generate data in the expected format for a Scatter plot.
 *
 * @param entry A unit of Plotly data containing points, color, name, and any extras.
 * @param mirrorPoints Should we mirror the points on the x/y axis?
 * @returns Data suitable for consumption by Plotly.
 */
exports.generateScatterData = function (entry, mirrorPoints) {
    if (mirrorPoints === void 0) { mirrorPoints = false; }
    var marker = entry.marker, points = entry.points, hoverinfo = entry.hoverinfo, subtitle = entry.subtitle, name = entry.name, text = entry.text;
    var xValues = points.map(function (data) { return data.i; });
    var yValues = points.map(function (data) { return data.j; });
    var zValues = points.map(function (data) { return (data.dist ? data.dist : -1); });
    var textValues = text ? (Array.isArray(text) ? text : [text]) : [];
    return {
        hoverinfo: hoverinfo ? hoverinfo : 'x+y+z',
        marker: __assign({ color: derivePlotlyColor(mirrorPoints, zValues, entry), size: entry.nodeSize }, marker),
        mode: 'markers',
        name: name + " " + subtitle,
        text: mirrorPoints
            ? __spread(textValues, textValues.map(
            // Given a coordinate '(x, y)', create '(y, x)' - needed because we have custom hover labels.
            function (coord) {
                return "(" + coord
                    .substr(1, coord.length - 2)
                    .split(', ')
                    .reverse()
                    .join(', ') + ")";
            })) : textValues,
        type: data_1.PLOTLY_CHART_TYPE.scatter,
        x: mirrorPoints ? __spread(xValues, yValues) : xValues,
        y: mirrorPoints ? __spread(yValues, xValues) : yValues,
        z: mirrorPoints ? __spread(zValues, zValues) : zValues,
    };
};
var derivePlotlyColor = function (mirrorPoints, zValues, entry) {
    var totalColors = mirrorPoints ? zValues.length * 2 : zValues.length;
    var result = new Array(totalColors);
    if (entry.marker && typeof entry.marker.color === 'string') {
        return result.fill(entry.marker.color);
    }
    else {
        var zStrings = zValues.map(function (val) { return val.toString(); });
        return mirrorPoints ? __spread(zStrings, zStrings) : zStrings;
    }
};
exports.generateFloat32ArrayFromContacts = function (array) {
    var result = new Float32Array(array.length * 2);
    array.forEach(function (item, index) {
        result[index * 2] = item.i;
        result[index * 2 + 1] = item.j;
    });
    return result;
};
/**
 * Generate data in the expected format for a Plotly PointCloud.
 *
 * @param entry A unit of Plotly data containing points, color, and any extras.
 * @param mirrorPoints Should we mirror the points on the x/y axis?
 * @returns Data suitable for consumption by Plotly.
 */
exports.generatePointCloudData = function (entry, mirrorPoints) {
    if (mirrorPoints === void 0) { mirrorPoints = false; }
    var points = entry.points;
    var coords = exports.generateFloat32ArrayFromContacts(points);
    return {
        marker: __assign({}, entry.marker, { sizemax: entry.nodeSize * 2, sizemin: entry.nodeSize }),
        mode: 'markers',
        type: data_1.PLOTLY_CHART_TYPE.pointcloud,
        xy: mirrorPoints
            ? new Float32Array(__spread(Array.from(coords), Array.from(coords)
                .slice()
                .reverse()))
            : coords,
    };
};


/***/ }),

/***/ "./src/helper/ResidueMapper.ts":
/*!*************************************!*\
  !*** ./src/helper/ResidueMapper.ts ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __values = (this && this.__values) || function (o) {
    var m = typeof Symbol === "function" && o[Symbol.iterator], i = 0;
    if (m) return m.call(o);
    return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
};
Object.defineProperty(exports, "__esModule", { value: true });
var UNI_PROT_RESNO_HEADER = 'up_index';
var UNI_PROT_RESNAME_HEADER = 'up_residue';
var PDB_RESNO_HEADER = 'pdb_index';
var PDB_RESNAME_HEADER = 'pdb_residue';
var EV_SERVER_COUPLING_HEADER = 'id';
var EV_SERVER_STRUCTURE_HEADER = 'coord_id';
var EV_SERVER_STRUCTURE_CODE_HEADER = 'one_letter_code';
var EVFOLD_EXPECTED_HEADERS = [UNI_PROT_RESNO_HEADER, UNI_PROT_RESNAME_HEADER, PDB_RESNO_HEADER, PDB_RESNAME_HEADER];
var EVSERVER_EXPECTED_HEADERS = [
    EV_SERVER_COUPLING_HEADER,
    EV_SERVER_STRUCTURE_HEADER,
    EV_SERVER_STRUCTURE_CODE_HEADER,
];
/**
 * Determines the mapping of residues from a UniProt file to a PDB, given a indextableplus file.
 *
 * @description This file is, semantically, a csv with 4 headers:
 *
 * up_index - UniProt residue number.
 *
 * up_residue - UniProt residue name.
 *
 * pdb_index - PDB residue number.
 *
 * pdb_residue - PDB residue name.
 *
 * @param text The contents of a indextableplus file.
 * @returns Array of all residue mappings.
 */
exports.generateResidueMapping = function (text) {
    var tabOrCommaRegex = /\t|,/;
    var headers = text.split('\n')[0].split(tabOrCommaRegex);
    var isEvServer = isEvServerJob(headers);
    var headerMap = getResidueMappingHeaders(headers, isEvServer);
    var couplingsResnoIndex = isEvServer ? headerMap[EV_SERVER_COUPLING_HEADER] : headerMap[UNI_PROT_RESNO_HEADER];
    var structureResnoIndex = isEvServer ? headerMap[EV_SERVER_STRUCTURE_HEADER] : headerMap[PDB_RESNO_HEADER];
    var structureResCodeIndex = isEvServer ? headerMap[EV_SERVER_STRUCTURE_CODE_HEADER] : headerMap[PDB_RESNAME_HEADER];
    return text
        .split('\n')
        .slice(1)
        .reduce(function (result, line) {
        var splitLine = line.split(tabOrCommaRegex);
        if (splitLine.length >= EVFOLD_EXPECTED_HEADERS.length) {
            result.push({
                couplingsResCode: isEvServer
                    ? splitLine[structureResCodeIndex]
                    : splitLine[headerMap[UNI_PROT_RESNAME_HEADER]],
                couplingsResno: parseInt(splitLine[couplingsResnoIndex], 10),
                pdbResCode: splitLine[structureResCodeIndex],
                pdbResno: parseInt(splitLine[structureResnoIndex], 10),
            });
        }
        return result;
    }, new Array());
};
var getResidueMappingHeaders = function (headers, isEvServer) {
    var headerMap = {};
    var expectedHeaders = isEvServer ? EVSERVER_EXPECTED_HEADERS : EVFOLD_EXPECTED_HEADERS;
    if (headers.length >= EVFOLD_EXPECTED_HEADERS.length) {
        expectedHeaders.map(function (header) {
            if (!headers.includes(header)) {
                throw new Error("Missing error " + header + " in residue mapping file!");
            }
            headerMap[header] = headers.indexOf(header);
        });
    }
    return headerMap;
};
var isEvServerJob = function (headers) {
    var e_1, _a;
    try {
        for (var EVSERVER_EXPECTED_HEADERS_1 = __values(EVSERVER_EXPECTED_HEADERS), EVSERVER_EXPECTED_HEADERS_1_1 = EVSERVER_EXPECTED_HEADERS_1.next(); !EVSERVER_EXPECTED_HEADERS_1_1.done; EVSERVER_EXPECTED_HEADERS_1_1 = EVSERVER_EXPECTED_HEADERS_1.next()) {
            var header = EVSERVER_EXPECTED_HEADERS_1_1.value;
            if (!headers.includes(header)) {
                return false;
            }
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (EVSERVER_EXPECTED_HEADERS_1_1 && !EVSERVER_EXPECTED_HEADERS_1_1.done && (_a = EVSERVER_EXPECTED_HEADERS_1.return)) _a.call(EVSERVER_EXPECTED_HEADERS_1);
        }
        finally { if (e_1) throw e_1.error; }
    }
    return true;
};


/***/ }),

/***/ "./src/helper/StringHelper.ts":
/*!************************************!*\
  !*** ./src/helper/StringHelper.ts ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
// tslint:disable-next-line:export-name
exports.capitalizeFirstLetter = function (text) {
    return "" + text.substr(0, 1).toLocaleUpperCase() + text.substr(1).toLocaleLowerCase();
};


/***/ }),

/***/ "./src/helper/index.ts":
/*!*****************************!*\
  !*** ./src/helper/index.ts ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./ColorMapper */ "./src/helper/ColorMapper.ts"));
__export(__webpack_require__(/*! ./CouplingMapper */ "./src/helper/CouplingMapper.ts"));
__export(__webpack_require__(/*! ./DataHelper */ "./src/helper/DataHelper.ts"));
__export(__webpack_require__(/*! ./FetchHelper */ "./src/helper/FetchHelper.ts"));
__export(__webpack_require__(/*! ./NGLHelper */ "./src/helper/NGLHelper.ts"));
__export(__webpack_require__(/*! ./PlotlyHelper */ "./src/helper/PlotlyHelper.ts"));
__export(__webpack_require__(/*! ./ResidueMapper */ "./src/helper/ResidueMapper.ts"));
__export(__webpack_require__(/*! ./StringHelper */ "./src/helper/StringHelper.ts"));


/***/ }),

/***/ "./src/hoc/ContextConsumerComposer.tsx":
/*!*********************************************!*\
  !*** ./src/hoc/ContextConsumerComposer.tsx ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var React = __webpack_require__(/*! react */ "./node_modules/react/index.js");
var ContextConsumerComposer = /** @class */ (function (_super) {
    __extends(ContextConsumerComposer, _super);
    function ContextConsumerComposer() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    ContextConsumerComposer.prototype.render = function () {
        var _a = this.props, children = _a.children, components = _a.components;
        return renderRecursive(children, components);
    };
    return ContextConsumerComposer;
}(React.Component));
exports.ContextConsumerComposer = ContextConsumerComposer;
/**
 * Recursively build up elements from props.components and accumulate `results` along the way.
 */
var renderRecursive = function (render, remaining, results) {
    if (results === void 0) { results = []; }
    // Once components is exhausted, we can render out the results array.
    if (!remaining[0]) {
        return render(results);
    }
    // Continue recursion for remaining items.
    // results.concat([value]) ensures [...results, value] instead of [...results, ...value]
    function nextRender(value) {
        return renderRecursive(render, remaining.slice(1), results.concat([value]));
    }
    var Item = remaining[0];
    // When it is an element, enhance the element's props with the render prop.
    return React.cloneElement(React.createElement(Item, null, nextRender), { displayName: Item.displayName });
};


/***/ }),

/***/ "./src/hoc/index.ts":
/*!**************************!*\
  !*** ./src/hoc/index.ts ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./ContextConsumerComposer */ "./src/hoc/ContextConsumerComposer.tsx"));


/***/ }),

/***/ "./src/index.ts":
/*!**********************!*\
  !*** ./src/index.ts ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./component */ "./src/component/index.ts"));
__export(__webpack_require__(/*! ./container */ "./src/container/index.ts"));
__export(__webpack_require__(/*! ./context */ "./src/context/index.ts"));
__export(__webpack_require__(/*! ./data */ "./src/data/index.ts"));
__export(__webpack_require__(/*! ./helper */ "./src/helper/index.ts"));
__export(__webpack_require__(/*! ./hoc */ "./src/hoc/index.ts"));
__export(__webpack_require__(/*! ./page */ "./src/page/index.ts"));
__export(__webpack_require__(/*! ./ChellVizApp */ "./src/ChellVizApp.tsx"));


/***/ }),

/***/ "./src/page/DatasetPage.tsx":
/*!**********************************!*\
  !*** ./src/page/DatasetPage.tsx ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var immutable_1 = __webpack_require__(/*! immutable */ "./node_modules/immutable/dist/immutable.js");
var React = __webpack_require__(/*! react */ "./node_modules/react/index.js");
var semantic_ui_react_1 = __webpack_require__(/*! semantic-ui-react */ "./node_modules/semantic-ui-react/dist/es/index.js");
var container_1 = __webpack_require__(/*! ~chell-viz~/container */ "./src/container/index.ts");
var data_1 = __webpack_require__(/*! ~chell-viz~/data */ "./src/data/index.ts");
var DatasetPage = /** @class */ (function (_super) {
    __extends(DatasetPage, _super);
    function DatasetPage(props) {
        var _this = _super.call(this, props) || this;
        _this.state = {
            datasetLocation: '',
            visualizations: immutable_1.List(),
        };
        return _this;
    }
    DatasetPage.prototype.componentDidMount = function () {
        if (this.props.location) {
            this.setupSearchParameters(this.props.location.search);
        }
    };
    DatasetPage.prototype.componentDidUpdate = function (prevProps) {
        if (this.props.location && this.props.location !== prevProps.location) {
            this.setupSearchParameters(this.props.location.search);
        }
    };
    DatasetPage.prototype.render = function () {
        var _this = this;
        var _a = this.state, visualizations = _a.visualizations, datasetLocation = _a.datasetLocation;
        return (React.createElement("div", { style: { padding: '20px' } },
            React.createElement(semantic_ui_react_1.Grid, { centered: true, stackable: true, stretched: false, padded: true, columns: 2 }, datasetLocation.length >= 1 &&
                visualizations.map(function (visualization, index) { return (React.createElement(semantic_ui_react_1.Grid.Column, { key: "dataset-visualization-" + index, style: { width: 'auto' } }, _this.renderVisualization(visualization, datasetLocation))); }))));
    };
    DatasetPage.prototype.setupSearchParameters = function (query) {
        var params = new URLSearchParams(query);
        // tslint:disable-next-line:no-backbone-get-set-outside-model
        var datasetLocation = params.get('name');
        var visualizations = immutable_1.fromJS(params.getAll('viz'));
        this.setState({
            datasetLocation: datasetLocation ? datasetLocation : '',
            visualizations: visualizations,
        });
    };
    DatasetPage.prototype.renderVisualization = function (viz, datasetLocation) {
        var isFullPage = this.state.visualizations.size === 1;
        switch (viz) {
            case data_1.VizData.spring.name.toLocaleLowerCase():
                return React.createElement(container_1.SpringContainer, { datasetLocation: datasetLocation, isFullPage: isFullPage });
            case data_1.VizData.tfjsTsne.name.toLocaleLowerCase():
                return React.createElement(container_1.TensorTContainer, { datasetLocation: datasetLocation, isFullPage: isFullPage });
            case data_1.VizData.anatomogram.name.toLocaleLowerCase():
                return React.createElement(container_1.AnatomogramContainer, { species: datasetLocation.includes('hpc') ? 'homo_sapiens' : 'mus_musculus' });
            default:
                return React.createElement(semantic_ui_react_1.Message, { error: true }, "Currently unsupported visualization '" + viz + "'");
        }
    };
    return DatasetPage;
}(React.Component));
exports.DatasetPage = DatasetPage;


/***/ }),

/***/ "./src/page/LandingPage.tsx":
/*!**********************************!*\
  !*** ./src/page/LandingPage.tsx ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var React = __webpack_require__(/*! react */ "./node_modules/react/index.js");
var react_router_dom_1 = __webpack_require__(/*! react-router-dom */ "./node_modules/react-router-dom/es/index.js");
var semantic_ui_react_1 = __webpack_require__(/*! semantic-ui-react */ "./node_modules/semantic-ui-react/dist/es/index.js");
var data_1 = __webpack_require__(/*! ~chell-viz~/data */ "./src/data/index.ts");
var LandingPage = /** @class */ (function (_super) {
    __extends(LandingPage, _super);
    function LandingPage(props) {
        return _super.call(this, props) || this;
    }
    LandingPage.prototype.render = function () {
        return (React.createElement(semantic_ui_react_1.Container, { fluid: false },
            React.createElement(semantic_ui_react_1.Segment, { basic: true, padded: 'very' },
                React.createElement(semantic_ui_react_1.Grid, { centered: true, padded: true, relaxed: true },
                    this.renderFeaturedStories(),
                    this.renderFeaturedVisualizations(),
                    this.renderFeaturedDatasets()))));
    };
    LandingPage.prototype.renderSingleVisualization = function (viz) {
        return (React.createElement(semantic_ui_react_1.Grid.Row, { columns: 3 },
            React.createElement(semantic_ui_react_1.Grid.Column, { width: 2 },
                React.createElement("img", { src: "assets/icons/" + viz.name.toLocaleLowerCase() + "-thumbnail.png", style: { height: '90px', width: '90px' }, alt: "viz " + viz.name + " icon" })),
            React.createElement(semantic_ui_react_1.Grid.Column, { textAlign: 'left', width: 8 },
                React.createElement(semantic_ui_react_1.Header, null, viz.name),
                viz.summary,
                React.createElement("p", null,
                    React.createElement("span", { style: { fontWeight: 'bold' } },
                        viz.listAsOriginal ? 'Original authors' : 'Authors',
                        ": "),
                    viz.authors.length === 2 ? viz.authors[0] + " and " + viz.authors[1] : viz.authors.join(', ')),
                React.createElement("br", null)),
            React.createElement(semantic_ui_react_1.Grid.Column, { width: 2 },
                React.createElement(semantic_ui_react_1.Grid.Row, null,
                    React.createElement(semantic_ui_react_1.Button, { basic: true },
                        React.createElement(react_router_dom_1.Link, { to: { pathname: '/visualizations/', search: "?name=" + viz.name.toLocaleLowerCase() } }, "details"))),
                React.createElement(semantic_ui_react_1.Grid.Row, null,
                    React.createElement(semantic_ui_react_1.Button, { basic: true },
                        React.createElement(react_router_dom_1.Link, { to: { pathname: '/dataset', search: "?viz=" + viz.name.toLocaleLowerCase() } }, "launch"))))));
    };
    LandingPage.prototype.renderFeaturedDatasets = function () {
        return (React.createElement(React.Fragment, null,
            React.createElement(semantic_ui_react_1.Grid.Row, { centered: true },
                React.createElement(semantic_ui_react_1.Grid.Column, { width: 12 },
                    React.createElement(semantic_ui_react_1.Header, { floated: 'left' }, "Featured Datasets"),
                    React.createElement(semantic_ui_react_1.Divider, { section: true }))),
            React.createElement(semantic_ui_react_1.Grid.Row, { columns: 2, divided: true },
                this.renderHCADatasets(),
                this.renderUserSharedDatasets()),
            React.createElement(semantic_ui_react_1.Grid.Row, { centered: false },
                React.createElement(semantic_ui_react_1.Grid.Column, { width: 12 },
                    React.createElement(react_router_dom_1.Link, { style: { color: 'blue', float: 'right' }, to: 'datasets' }, "more datasets...")))));
    };
    LandingPage.prototype.renderFeaturedStories = function () {
        return (React.createElement(React.Fragment, null,
            React.createElement(semantic_ui_react_1.Grid.Row, { centered: false },
                React.createElement(semantic_ui_react_1.Grid.Column, { width: 12 },
                    React.createElement(semantic_ui_react_1.Header, { floated: 'left' }, "Featured Stories"),
                    React.createElement(semantic_ui_react_1.Divider, { section: true }))),
            this.renderSingleFeaturedStory(data_1.Stories[0]),
            this.renderSingleFeaturedStory(data_1.Stories[1]),
            React.createElement(semantic_ui_react_1.Grid.Row, { centered: false },
                React.createElement(semantic_ui_react_1.Grid.Column, { width: 12 },
                    React.createElement(react_router_dom_1.Link, { style: { color: 'blue', float: 'right' }, to: 'stories' }, "more stories...")))));
    };
    LandingPage.prototype.renderFeaturedVisualizations = function () {
        return (React.createElement(React.Fragment, null,
            React.createElement(semantic_ui_react_1.Grid.Row, { centered: false },
                React.createElement(semantic_ui_react_1.Grid.Column, { width: 12 },
                    React.createElement(semantic_ui_react_1.Header, { floated: 'left' }, "Featured Visualizations"),
                    React.createElement(semantic_ui_react_1.Divider, { section: true }))),
            this.renderSingleVisualization(data_1.VizData.spring),
            this.renderSingleVisualization(data_1.VizData.tfjsTsne),
            React.createElement(semantic_ui_react_1.Grid.Row, { centered: false },
                React.createElement(semantic_ui_react_1.Grid.Column, { width: 12 },
                    React.createElement(react_router_dom_1.Link, { style: { color: 'blue', float: 'right' }, to: 'visualizations' }, "more visualizations...")))));
    };
    LandingPage.prototype.renderSingleFeaturedStory = function (story) {
        return (React.createElement(semantic_ui_react_1.Grid.Row, { columns: 3 },
            React.createElement(semantic_ui_react_1.Grid.Column, { width: 2 },
                React.createElement("img", { src: story.icon, style: { height: '90px', width: '90px' }, alt: "story " + story.title + " icon" })),
            React.createElement(semantic_ui_react_1.Grid.Column, { textAlign: 'left', width: 8 },
                React.createElement(semantic_ui_react_1.Header, null, story.title),
                React.createElement("p", null,
                    React.createElement("span", { style: { fontWeight: 'bold' } }, "Description: "),
                    story.description),
                React.createElement("p", null,
                    React.createElement("span", { style: { fontWeight: 'bold' } }, "Analysis authors: "),
                    story.authors.length === 2 ? story.authors[0] + " and " + story.authors[1] : story.authors.join(', ')),
                React.createElement("br", null)),
            React.createElement(semantic_ui_react_1.Grid.Column, { width: 2 },
                React.createElement(semantic_ui_react_1.Button, { basic: true },
                    React.createElement(react_router_dom_1.Link, { to: story.link }, "launch")))));
    };
    LandingPage.prototype.renderHCADatasets = function () {
        return (React.createElement(semantic_ui_react_1.Grid.Column, { width: 3 },
            React.createElement(semantic_ui_react_1.Grid.Row, null,
                React.createElement("img", { src: 'assets/icons/hca-logo.png', style: { width: '150px', height: '250px' }, alt: 'human cell atlas logo' }),
                React.createElement(semantic_ui_react_1.Grid.Row, null,
                    React.createElement("a", { href: 'https://preview.data.humancellatlas.org/' }, "Search HCA datasets ...")))));
    };
    LandingPage.prototype.renderSingleUserSharedDatasets = function (dataset) {
        return (React.createElement(semantic_ui_react_1.Grid.Row, { columns: 2 },
            React.createElement(semantic_ui_react_1.Grid.Column, { floated: 'left' },
                React.createElement(semantic_ui_react_1.Header, null, dataset.name),
                React.createElement("p", null,
                    dataset.summary,
                    React.createElement("br", null),
                    React.createElement("span", { style: { fontWeight: 'bold' } }, "Authors: "),
                    dataset.authors.join(', '))),
            React.createElement(semantic_ui_react_1.Grid.Column, { floated: 'right' },
                React.createElement(semantic_ui_react_1.Button, { basic: true, floated: 'right' },
                    React.createElement(react_router_dom_1.Link, { to: dataset.links.detail }, "details")),
                React.createElement(semantic_ui_react_1.Button, { basic: true, floated: 'right' },
                    React.createElement(react_router_dom_1.Link, { to: dataset.links.analysis }, "analyze")))));
    };
    LandingPage.prototype.renderUserSharedDatasets = function () {
        return (React.createElement(semantic_ui_react_1.Grid.Column, { stretched: true, textAlign: 'left', width: 8 },
            React.createElement(semantic_ui_react_1.Grid.Row, { textAlign: 'center' },
                React.createElement(semantic_ui_react_1.Header, { as: 'h2', textAlign: 'center' }, "User shared")),
            React.createElement("br", null),
            React.createElement(semantic_ui_react_1.Grid.Row, null, this.renderSingleUserSharedDatasets(data_1.userDatasets[0])),
            React.createElement(semantic_ui_react_1.Grid.Row, null, this.renderSingleUserSharedDatasets(data_1.userDatasets[1]))));
    };
    return LandingPage;
}(React.Component));
exports.LandingPage = LandingPage;


/***/ }),

/***/ "./src/page/StoriesPage.tsx":
/*!**********************************!*\
  !*** ./src/page/StoriesPage.tsx ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var React = __webpack_require__(/*! react */ "./node_modules/react/index.js");
var react_router_dom_1 = __webpack_require__(/*! react-router-dom */ "./node_modules/react-router-dom/es/index.js");
var semantic_ui_react_1 = __webpack_require__(/*! semantic-ui-react */ "./node_modules/semantic-ui-react/dist/es/index.js");
var data_1 = __webpack_require__(/*! ~chell-viz~/data */ "./src/data/index.ts");
var StoriesPage = /** @class */ (function (_super) {
    __extends(StoriesPage, _super);
    function StoriesPage(props) {
        return _super.call(this, props) || this;
    }
    StoriesPage.prototype.render = function () {
        var _this = this;
        return (React.createElement(semantic_ui_react_1.Grid, { centered: true, divided: 'vertically', padded: true, relaxed: false }, data_1.Stories.map(function (story, index) { return (React.createElement(React.Fragment, { key: "story-" + index }, _this.renderSingleFeaturedStory(story))); })));
    };
    StoriesPage.prototype.renderSingleFeaturedStory = function (story) {
        return (React.createElement(semantic_ui_react_1.Grid.Row, { columns: 3 },
            React.createElement(semantic_ui_react_1.Grid.Column, null,
                React.createElement("img", { src: story.icon, style: { height: '90px', width: '90px' }, alt: "story " + story.title + " icon" })),
            React.createElement(semantic_ui_react_1.Grid.Column, { textAlign: 'left' },
                React.createElement(semantic_ui_react_1.Header, null, story.title),
                React.createElement("p", null,
                    React.createElement("span", { style: { fontWeight: 'bold' } }, "Description: "),
                    story.description),
                React.createElement("p", null,
                    React.createElement("span", { style: { fontWeight: 'bold' } }, "Analysis authors: "),
                    story.authors.length === 2 ? story.authors[0] + " and " + story.authors[1] : story.authors.join(', ')),
                React.createElement("br", null)),
            React.createElement(semantic_ui_react_1.Grid.Column, null,
                React.createElement(semantic_ui_react_1.Button, { basic: true },
                    React.createElement(react_router_dom_1.Link, { to: story.link }, "launch")))));
    };
    return StoriesPage;
}(React.Component));
exports.StoriesPage = StoriesPage;


/***/ }),

/***/ "./src/page/VisualizationsPage.tsx":
/*!*****************************************!*\
  !*** ./src/page/VisualizationsPage.tsx ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var React = __webpack_require__(/*! react */ "./node_modules/react/index.js");
var react_router_dom_1 = __webpack_require__(/*! react-router-dom */ "./node_modules/react-router-dom/es/index.js");
var semantic_ui_react_1 = __webpack_require__(/*! semantic-ui-react */ "./node_modules/semantic-ui-react/dist/es/index.js");
var data_1 = __webpack_require__(/*! ~chell-viz~/data */ "./src/data/index.ts");
var VisualizationsPage = /** @class */ (function (_super) {
    __extends(VisualizationsPage, _super);
    function VisualizationsPage(props) {
        return _super.call(this, props) || this;
    }
    VisualizationsPage.prototype.render = function () {
        return (React.createElement(semantic_ui_react_1.List, { divided: true },
            React.createElement(semantic_ui_react_1.List.Item, null, this.renderVisualizationItem(data_1.VizData.spring)),
            React.createElement(semantic_ui_react_1.List.Item, null, this.renderVisualizationItem(data_1.VizData.tfjsTsne)),
            React.createElement(semantic_ui_react_1.List.Item, null, this.renderVisualizationItem(data_1.VizData.anatomogram))));
    };
    VisualizationsPage.prototype.renderVisualizationItem = function (viz) {
        return (React.createElement(semantic_ui_react_1.Grid, { centered: true, columns: 3, padded: true, relaxed: true },
            React.createElement(semantic_ui_react_1.Grid.Column, null,
                React.createElement("img", { src: "assets/icons/" + viz.name.toLocaleLowerCase() + "-thumbnail.png", alt: "icon for " + viz.name, style: { height: '100px' } })),
            React.createElement(semantic_ui_react_1.Grid.Column, { textAlign: 'left' },
                React.createElement(semantic_ui_react_1.Header, { as: 'h2' }, viz.name),
                React.createElement(semantic_ui_react_1.List, null,
                    React.createElement(semantic_ui_react_1.List.Item, null, "" + (viz.listAsOriginal ? 'original: ' : '') + viz.authors.join(', ')),
                    React.createElement(semantic_ui_react_1.List.Item, null, viz.summary),
                    React.createElement(semantic_ui_react_1.List.Item, null, "relevant data: " + viz.relevantData))),
            React.createElement(semantic_ui_react_1.Grid.Column, { stretched: true },
                React.createElement(semantic_ui_react_1.Grid.Row, null,
                    React.createElement(semantic_ui_react_1.Button, { basic: true },
                        React.createElement(react_router_dom_1.Link, { to: { pathname: '/visualizations/', search: "?name=" + viz.name.toLocaleLowerCase() } }, "details"))),
                React.createElement(semantic_ui_react_1.Grid.Row, null,
                    React.createElement(semantic_ui_react_1.Button, { basic: true },
                        React.createElement(react_router_dom_1.Link, { to: { pathname: '/dataset', search: "?viz=" + viz.name.toLocaleLowerCase() } }, "launch"))))));
    };
    return VisualizationsPage;
}(React.Component));
exports.VisualizationsPage = VisualizationsPage;


/***/ }),

/***/ "./src/page/VizOverviewPage.tsx":
/*!**************************************!*\
  !*** ./src/page/VizOverviewPage.tsx ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var React = __webpack_require__(/*! react */ "./node_modules/react/index.js");
var semantic_ui_react_1 = __webpack_require__(/*! semantic-ui-react */ "./node_modules/semantic-ui-react/dist/es/index.js");
var react_router_dom_1 = __webpack_require__(/*! react-router-dom */ "./node_modules/react-router-dom/es/index.js");
var data_1 = __webpack_require__(/*! ~chell-viz~/data */ "./src/data/index.ts");
var VizOverviewPage = /** @class */ (function (_super) {
    __extends(VizOverviewPage, _super);
    function VizOverviewPage(props) {
        var _this = _super.call(this, props) || this;
        _this.state = {
            currentViz: null,
        };
        return _this;
    }
    VizOverviewPage.prototype.componentDidMount = function () {
        this.setupCurrentViz();
    };
    VizOverviewPage.prototype.componentDidUpdate = function (prevProps) {
        if (this.props.location !== prevProps.location) {
            this.setupCurrentViz();
        }
    };
    VizOverviewPage.prototype.render = function () {
        return (this.state.currentViz && (React.createElement(semantic_ui_react_1.Container, null,
            this.renderOverview(this.state.currentViz),
            this.renderExamples(this.state.currentViz.examples))));
    };
    VizOverviewPage.prototype.renderOverview = function (viz) {
        return (React.createElement(semantic_ui_react_1.Grid, { centered: true, columns: 2 },
            React.createElement(semantic_ui_react_1.Grid.Column, { width: 2 },
                React.createElement("img", { alt: "icon for " + viz.name, src: "assets/icons/" + viz.name.toLocaleLowerCase() + "-icon.png", style: { height: '150px', padding: '20px' } })),
            React.createElement(semantic_ui_react_1.Grid.Column, { textAlign: 'left' },
                React.createElement(semantic_ui_react_1.Header, { as: 'h1' },
                    viz.name,
                    React.createElement(semantic_ui_react_1.Header.Subheader, null, viz.authors.join(', '))),
                React.createElement(React.Fragment, null,
                    React.createElement("p", null, viz.detailedSummary),
                    React.createElement(semantic_ui_react_1.List, null,
                        React.createElement(semantic_ui_react_1.List.Item, null,
                            "applicable data: ",
                            viz.relevantData),
                        React.createElement(semantic_ui_react_1.List.Item, null,
                            "compatible with: ",
                            viz.compatibility.join(', ')),
                        React.createElement(semantic_ui_react_1.List.Item, null,
                            "citation(s):",
                            ' ',
                            viz.citations.map(function (citation, index) { return (React.createElement(React.Fragment, { key: viz.name.toLocaleLowerCase() + "-citation-" + index },
                                citation.fullCitation,
                                " (",
                                React.createElement("a", { href: citation.link }, "link"),
                                ")")); })),
                        React.createElement(semantic_ui_react_1.List.Item, null,
                            "version: ",
                            viz.repo.version,
                            " (last updated ",
                            viz.repo.lastUpdate,
                            "),",
                            React.createElement("a", { href: viz.repo.link }, " github link")),
                        React.createElement(semantic_ui_react_1.List.Item, null,
                            React.createElement(semantic_ui_react_1.Grid.Column, { floated: 'right' },
                                React.createElement(semantic_ui_react_1.Button, { basic: true, icon: true, labelPosition: 'right' },
                                    React.createElement(react_router_dom_1.Link, { to: { pathname: '/dataset', search: "?viz=" + viz.name.toLocaleLowerCase() } }, "launch " + viz.name),
                                    React.createElement(semantic_ui_react_1.Icon, { name: 'external alternate' })))))))));
    };
    VizOverviewPage.prototype.renderExamples = function (examples) {
        var _this = this;
        var panels = [
            {
                content: {
                    content: (React.createElement(React.Fragment, null,
                        React.createElement(semantic_ui_react_1.Divider, null),
                        React.createElement(semantic_ui_react_1.Grid, { centered: true, columns: 1, container: true, divided: 'vertically', style: { padding: '10px 0' } }, examples.map(function (example, index) { return (React.createElement(semantic_ui_react_1.Grid.Row, { columns: 2, key: "viz-example-" + index }, _this.renderExampleEntry(example))); })))),
                },
                key: 'examples',
                title: 'example stories',
            },
            {
                content: 'coming soon!',
                key: 'learn',
                title: 'learn',
            },
        ];
        return React.createElement(semantic_ui_react_1.Accordion, { panels: panels, defaultActiveIndex: 0 });
    };
    VizOverviewPage.prototype.renderExampleEntry = function (example) {
        return (React.createElement(React.Fragment, null,
            React.createElement(semantic_ui_react_1.Grid.Column, { width: 2 },
                React.createElement("img", { src: example.icon, alt: example.name + " icon", style: { height: '75px', width: '75px' } })),
            React.createElement(semantic_ui_react_1.Grid.Column, { textAlign: 'left', width: 8 },
                React.createElement(semantic_ui_react_1.Header, null, example.name),
                React.createElement("p", null, example.summary)),
            React.createElement(semantic_ui_react_1.Grid.Column, { floated: 'right' },
                React.createElement(semantic_ui_react_1.Button, { basic: true, icon: true, labelPosition: 'right' },
                    React.createElement(react_router_dom_1.Link, { to: example.link }, 'launch example'),
                    React.createElement(semantic_ui_react_1.Icon, { name: 'external alternate' })))));
    };
    VizOverviewPage.prototype.setupCurrentViz = function () {
        var params = new URLSearchParams(this.props.location ? this.props.location.search : '');
        // tslint:disable-next-line:no-backbone-get-set-outside-model
        var vizName = params.get('name');
        if (vizName === data_1.VizData.spring.name.toLocaleLowerCase()) {
            this.setState({
                currentViz: data_1.VizData.spring,
            });
        }
        else if (vizName === data_1.VizData.tfjsTsne.name.toLocaleLowerCase()) {
            this.setState({
                currentViz: data_1.VizData.tfjsTsne,
            });
        }
        else if (vizName === data_1.VizData.anatomogram.name.toLocaleLowerCase()) {
            this.setState({
                currentViz: data_1.VizData.anatomogram,
            });
        }
    };
    return VizOverviewPage;
}(React.Component));
exports.VizOverviewPage = VizOverviewPage;


/***/ }),

/***/ "./src/page/index.ts":
/*!***************************!*\
  !*** ./src/page/index.ts ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./VisualizationsPage */ "./src/page/VisualizationsPage.tsx"));
__export(__webpack_require__(/*! ./DatasetPage */ "./src/page/DatasetPage.tsx"));
__export(__webpack_require__(/*! ./LandingPage */ "./src/page/LandingPage.tsx"));
__export(__webpack_require__(/*! ./StoriesPage */ "./src/page/StoriesPage.tsx"));
__export(__webpack_require__(/*! ./VizOverviewPage */ "./src/page/VizOverviewPage.tsx"));


/***/ }),

/***/ 0:
/*!**********************!*\
  !*** util (ignored) ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports) {

/* (ignored) */

/***/ }),

/***/ 1:
/*!**********************!*\
  !*** util (ignored) ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports) {

/* (ignored) */

/***/ }),

/***/ 2:
/*!************************!*\
  !*** buffer (ignored) ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports) {

/* (ignored) */

/***/ }),

/***/ 3:
/*!************************!*\
  !*** crypto (ignored) ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports) {

/* (ignored) */

/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYW5hdG9tb2dyYW0vbGliL2ltZyBzeW5jIF5cXC5cXC8uKnNlbGVjdGVkXFwucG5nJCIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYW5hdG9tb2dyYW0vbGliL3N2ZyBzeW5jIF5cXC5cXC8uKlxcLnN2ZyQiLCJ3ZWJwYWNrOi8vLy4vc3JjL0NoZWxsVml6QXBwLnRzeCIsIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50L0NvbnRhY3RNYXAudHN4Iiwid2VicGFjazovLy8uL3NyYy9jb21wb25lbnQvRmVhdHVyZVZpZXdlci50c3giLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbXBvbmVudC9JbmZvUGFuZWwudHN4Iiwid2VicGFjazovLy8uL3NyYy9jb21wb25lbnQvTkdMQ29tcG9uZW50LnRzeCIsIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50L1ByZWRpY3RlZENvbnRhY3RNYXAudHN4Iiwid2VicGFjazovLy8uL3NyYy9jb21wb25lbnQvVEZyYW1lQ29tcG9uZW50LnRzeCIsIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50L1RlbnNvclRDb21wb25lbnQudHN4Iiwid2VicGFjazovLy8uL3NyYy9jb21wb25lbnQvVml6U2VsZWN0b3JQYW5lbC50c3giLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbXBvbmVudC9jaGFydC9BdXhpbGlhcnlBeGlzLnRzIiwid2VicGFjazovLy8uL3NyYy9jb21wb25lbnQvY2hhcnQvQ29udGFjdE1hcENoYXJ0LnRzeCIsIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50L2NoYXJ0L1Bsb3RseUNoYXJ0LnRzeCIsIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50L2NoYXJ0L1NlY29uZGFyeVN0cnVjdHVyZUF4aXMudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbXBvbmVudC9jaGFydC9pbmRleC50cyIsIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50L2luZGV4LnRzIiwid2VicGFjazovLy8uL3NyYy9jb21wb25lbnQvd2lkZ2V0L0NhdGVnb3J5U2VsZWN0b3IudHN4Iiwid2VicGFjazovLy8uL3NyYy9jb21wb25lbnQvd2lkZ2V0L0NoZWxsUmFkaW9Hcm91cC50c3giLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbXBvbmVudC93aWRnZXQvQ2hlbGxTbGlkZXIudHN4Iiwid2VicGFjazovLy8uL3NyYy9jb21wb25lbnQvd2lkZ2V0L0NoZWxsVG9vbHRpcC50c3giLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbXBvbmVudC93aWRnZXQvQ29tcG9uZW50Q2FyZC50c3giLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbXBvbmVudC93aWRnZXQvU2V0dGluZ3NQYW5lbC50c3giLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbXBvbmVudC93aWRnZXQvaW5kZXgudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbnRhaW5lci9BbmF0b21vZ3JhbUNvbnRhaW5lci50c3giLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbnRhaW5lci9Qcm90ZWluRmVhdHVyZVZpZXdlci50c3giLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbnRhaW5lci9TaXRlSGVhZGVyLnRzeCIsIndlYnBhY2s6Ly8vLi9zcmMvY29udGFpbmVyL1NwcmluZ0NvbnRhaW5lci50c3giLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbnRhaW5lci9UZW5zb3JUQ29udGFpbmVyLnRzeCIsIndlYnBhY2s6Ly8vLi9zcmMvY29udGFpbmVyL1ZpelBhbmVsQ29udGFpbmVyLnRzeCIsIndlYnBhY2s6Ly8vLi9zcmMvY29udGFpbmVyL2luZGV4LnRzIiwid2VicGFjazovLy8uL3NyYy9jb250ZXh0L0NoZWxsQ29udGV4dFByb3ZpZGVyLnRzeCIsIndlYnBhY2s6Ly8vLi9zcmMvY29udGV4dC9Db3VwbGluZ0NvbnRleHQudHN4Iiwid2VicGFjazovLy8uL3NyYy9jb250ZXh0L0dlbmVyaWNDb250ZXh0UHJvdmlkZXIudHN4Iiwid2VicGFjazovLy8uL3NyYy9jb250ZXh0L1Jlc2lkdWVDb250ZXh0LnRzeCIsIndlYnBhY2s6Ly8vLi9zcmMvY29udGV4dC9TZWNvbmRhcnlTdHJ1Y3R1cmVDb250ZXh0LnRzeCIsIndlYnBhY2s6Ly8vLi9zcmMvY29udGV4dC9TcHJpbmdDb250ZXh0LnRzeCIsIndlYnBhY2s6Ly8vLi9zcmMvY29udGV4dC9pbmRleC50cyIsIndlYnBhY2s6Ly8vLi9zcmMvZGF0YS9BbWlub0FjaWQudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2RhdGEvQ2hlbGwxRFNlY3Rpb24udHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2RhdGEvQ2hlbGxDb25maWcudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2RhdGEvQ2hlbGxEYXRhLnRzIiwid2VicGFjazovLy8uL3NyYy9kYXRhL0NoZWxsUERCLnRzIiwid2VicGFjazovLy8uL3NyYy9kYXRhL0NvdXBsaW5nQ29udGFpbmVyLnRzIiwid2VicGFjazovLy8uL3NyYy9kYXRhL1Bsb3RseURhdGEudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2RhdGEvUHJvdGVpbi50cyIsIndlYnBhY2s6Ly8vLi9zcmMvZGF0YS9UaW50ZWRDaGVsbDFEU2VjdGlvbi50cyIsIndlYnBhY2s6Ly8vLi9zcmMvZGF0YS9WaXpEYXRhLnRzIiwid2VicGFjazovLy8uL3NyYy9kYXRhL2V2ZW50L0NoZWxsQ2hhcnRFdmVudC50cyIsIndlYnBhY2s6Ly8vLi9zcmMvZGF0YS9ldmVudC9pbmRleC50cyIsIndlYnBhY2s6Ly8vLi9zcmMvZGF0YS9pbmRleC50cyIsIndlYnBhY2s6Ly8vLi9zcmMvaGVscGVyL0NvbG9yTWFwcGVyLnRzIiwid2VicGFjazovLy8uL3NyYy9oZWxwZXIvQ291cGxpbmdNYXBwZXIudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2hlbHBlci9EYXRhSGVscGVyLnRzIiwid2VicGFjazovLy8uL3NyYy9oZWxwZXIvRmV0Y2hIZWxwZXIudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2hlbHBlci9OR0xIZWxwZXIudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2hlbHBlci9QbG90bHlIZWxwZXIudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2hlbHBlci9SZXNpZHVlTWFwcGVyLnRzIiwid2VicGFjazovLy8uL3NyYy9oZWxwZXIvU3RyaW5nSGVscGVyLnRzIiwid2VicGFjazovLy8uL3NyYy9oZWxwZXIvaW5kZXgudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2hvYy9Db250ZXh0Q29uc3VtZXJDb21wb3Nlci50c3giLCJ3ZWJwYWNrOi8vLy4vc3JjL2hvYy9pbmRleC50cyIsIndlYnBhY2s6Ly8vLi9zcmMvaW5kZXgudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3BhZ2UvRGF0YXNldFBhZ2UudHN4Iiwid2VicGFjazovLy8uL3NyYy9wYWdlL0xhbmRpbmdQYWdlLnRzeCIsIndlYnBhY2s6Ly8vLi9zcmMvcGFnZS9TdG9yaWVzUGFnZS50c3giLCJ3ZWJwYWNrOi8vLy4vc3JjL3BhZ2UvVmlzdWFsaXphdGlvbnNQYWdlLnRzeCIsIndlYnBhY2s6Ly8vLi9zcmMvcGFnZS9WaXpPdmVydmlld1BhZ2UudHN4Iiwid2VicGFjazovLy8uL3NyYy9wYWdlL2luZGV4LnRzIiwid2VicGFjazovLy91dGlsIChpZ25vcmVkKSIsIndlYnBhY2s6Ly8vdXRpbCAoaWdub3JlZCk/YzMxYSIsIndlYnBhY2s6Ly8vYnVmZmVyIChpZ25vcmVkKSIsIndlYnBhY2s6Ly8vY3J5cHRvIChpZ25vcmVkKSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUc7Ozs7Ozs7Ozs7O0FDaENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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RUFBRSxLQUFLLEVBQUUsQ0FBQztBQUNqRyxJQUFNLEdBQUcsR0FBZSxFQUFFLFFBQVEsRUFBRSxZQUFZLEVBQUUsZ0JBQWdCLEVBQUUsR0FBRyxFQUFFLGVBQWUsRUFBRSxLQUFLLEVBQUUsQ0FBQztBQUNsRyxJQUFNLEdBQUcsR0FBZSxFQUFFLFFBQVEsRUFBRSxTQUFTLEVBQUUsZ0JBQWdCLEVBQUUsR0FBRyxFQUFFLGVBQWUsRUFBRSxLQUFLLEVBQUUsQ0FBQztBQUMvRixJQUFNLEdBQUcsR0FBZSxFQUFFLFFBQVEsRUFBRSxRQUFRLEVBQUUsZ0JBQWdCLEVBQUUsR0FBRyxFQUFFLGVBQWUsRUFBRSxLQUFLLEVBQUUsQ0FBQztBQUM5RixJQUFNLEdBQUcsR0FBZSxFQUFFLFFBQVEsRUFBRSxZQUFZLEVBQUUsZ0JBQWdCLEVBQUUsR0FBRyxFQUFFLGVBQWUsRUFBRSxLQUFLLEVBQUUsQ0FBQztBQUNsRyxJQUFNLEdBQUcsR0FBZSxFQUFFLFFBQVEsRUFBRSxlQUFlLEVBQUUsZ0JBQWdCLEVBQUUsR0FBRyxFQUFFLGVBQWUsRUFBRSxLQUFLLEVBQUUsQ0FBQztBQUNyRyxJQUFNLEdBQUcsR0FBZSxFQUFFLFFBQVEsRUFBRSxTQUFTLEVBQUUsZ0JBQWdCLEVBQUUsR0FBRyxFQUFFLGVBQWUsRUFBRSxLQUFLLEVBQUUsQ0FBQztBQUMvRixJQUFNLEdBQUcsR0FBZSxFQUFFLFFBQVEsRUFBRSxRQUFRLEVBQUUsZ0JBQWdCLEVBQUUsR0FBRyxFQUFFLGVBQWUsRUFBRSxLQUFLLEVBQUUsQ0FBQztBQUM5RixJQUFNLEdBQUcsR0FBZSxFQUFFLFFBQVEsRUFBRSxXQUFXLEVBQUUsZ0JBQWdCLEVBQUUsR0FBRyxFQUFFLGVBQWUsRUFBRSxLQUFLLEVBQUUsQ0FBQztBQUNqRyxJQUFNLEdBQUcsR0FBZSxFQUFFLFFBQVEsRUFBRSxZQUFZLEVBQUUsZ0JBQWdCLEVBQUUsR0FBRyxFQUFFLGVBQWUsRUFBRSxLQUFLLEVBQUUsQ0FBQztBQUNsRyxJQUFNLEdBQUcsR0FBZSxFQUFFLFFBQVEsRUFBRSxVQUFVLEVBQUUsZ0JBQWdCLEVBQUUsR0FBRyxFQUFFLGVBQWUsRUFBRSxLQUFLLEVBQUUsQ0FBQztBQUNoRyxJQUFNLEdBQUcsR0FBZSxFQUFFLFFBQVEsRUFBRSxRQUFRLEVBQUUsZ0JBQWdCLEVBQUUsR0FBRyxFQUFFLGVBQWUsRUFBRSxLQUFLLEVBQUUsQ0FBQztBQUU5RiwwQ0FBMEM7QUFDN0IseUNBQWlDLEdBQTJEO0lBQ3ZHLENBQUMsRUFBRSxHQUFHO0lBQ04sQ0FBQyxFQUFFLEdBQUc7SUFDTixDQUFDLEVBQUUsR0FBRztJQUNOLENBQUMsRUFBRSxHQUFHO0lBQ04sQ0FBQyxFQUFFLEdBQUc7SUFDTixDQUFDLEVBQUUsR0FBRztJQUNOLENBQUMsRUFBRSxHQUFHO0lBQ04sQ0FBQyxFQUFFLEdBQUc7SUFDTixDQUFDLEVBQUUsR0FBRztJQUNOLENBQUMsRUFBRSxHQUFHO0lBQ04sQ0FBQyxFQUFFLEdBQUc7SUFDTixDQUFDLEVBQUUsR0FBRztJQUNOLENBQUMsRUFBRSxHQUFHO0lBQ04sQ0FBQyxFQUFFLEdBQUc7SUFDTixDQUFDLEVBQUUsR0FBRztJQUNOLENBQUMsRUFBRSxHQUFHO0lBQ04sQ0FBQyxFQUFFLEdBQUc7SUFDTixDQUFDLEVBQUUsR0FBRztJQUNOLENBQUMsRUFBRSxHQUFHO0lBQ04sQ0FBQyxFQUFFLEdBQUc7Q0FDUCxDQUFDO0FBQ0YseUNBQXlDO0FBRTVCLHdDQUFnQyxHQUEwRDtJQUNyRyxHQUFHLEVBQUUsR0FBRztJQUNSLEdBQUcsRUFBRSxHQUFHO0lBQ1IsR0FBRyxFQUFFLEdBQUc7SUFDUixHQUFHLEVBQUUsR0FBRztJQUNSLEdBQUcsRUFBRSxHQUFHO0lBQ1IsR0FBRyxFQUFFLEdBQUc7SUFDUixHQUFHLEVBQUUsR0FBRztJQUNSLEdBQUcsRUFBRSxHQUFHO0lBQ1IsR0FBRyxFQUFFLEdBQUc7SUFDUixHQUFHLEVBQUUsR0FBRztJQUNSLEdBQUcsRUFBRSxHQUFHO0lBQ1IsR0FBRyxFQUFFLEdBQUc7SUFDUixHQUFHLEVBQUUsR0FBRztJQUNSLEdBQUcsRUFBRSxHQUFHO0lBQ1IsR0FBRyxFQUFFLEdBQUc7SUFDUixHQUFHLEVBQUUsR0FBRztJQUNSLEdBQUcsRUFBRSxHQUFHO0lBQ1IsR0FBRyxFQUFFLEdBQUc7SUFDUixHQUFHLEVBQUUsR0FBRztJQUNSLEdBQUcsRUFBRSxHQUFHO0NBQ1QsQ0FBQztBQUVXLG1CQUFXLEdBQWlCO0lBQ3ZDLEdBQUc7SUFDSCxHQUFHO0lBQ0gsR0FBRztJQUNILEdBQUc7SUFDSCxHQUFHO0lBQ0gsR0FBRztJQUNILEdBQUc7SUFDSCxHQUFHO0lBQ0gsR0FBRztJQUNILEdBQUc7SUFDSCxHQUFHO0lBQ0gsR0FBRztJQUNILEdBQUc7SUFDSCxHQUFHO0lBQ0gsR0FBRztJQUNILEdBQUc7SUFDSCxHQUFHO0lBQ0gsR0FBRztJQUNILEdBQUc7SUFDSCxHQUFHO0NBQ0osQ0FBQztBQVFXLGlDQUF5QixHQUFHLFVBQUMsT0FBaUIsRUFBRSxjQUFpQztJQUM1RixJQUFNLFdBQVcsR0FBRyxPQUFPLENBQUMsUUFBUSxDQUFDO0lBQ3JDLElBQU0sZ0JBQWdCLEdBQUcsY0FBYyxDQUFDLFFBQVEsQ0FBQztJQUNqRCxJQUFNLFVBQVUsR0FBRywyQkFBbUIsQ0FBQyxXQUFXLEVBQUUsZ0JBQWdCLENBQUMsQ0FBQztJQUV0RSxJQUFJLFVBQVUsQ0FBQyxNQUFNLEtBQUssQ0FBQyxFQUFFO1FBQzNCLE9BQU8sT0FBTyxDQUFDLDZCQUE2QixDQUFDLGNBQWMsQ0FBQyxDQUFDO0tBQzlEO0lBRUQsT0FBTyxVQUFVLENBQUM7QUFDcEIsQ0FBQyxDQUFDO0FBRVcsMkJBQW1CLEdBQUcsVUFBQyxhQUFxQixFQUFFLGNBQXNCO0lBQy9FLElBQU0sVUFBVSxHQUFHLElBQUksS0FBSyxFQUEwQixDQUFDO0lBQ3ZELElBQUksYUFBYSxDQUFDLE1BQU0sS0FBSyxjQUFjLENBQUMsTUFBTSxFQUFFO1FBQ2xELEtBQUssSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxhQUFhLENBQUMsTUFBTSxFQUFFLEVBQUUsQ0FBQyxFQUFFO1lBQzdDLElBQU0saUJBQWlCLEdBQUcsYUFBYSxDQUFDLENBQUMsQ0FBa0MsQ0FBQztZQUM1RSxJQUFNLFlBQVksR0FBRyxjQUFjLENBQUMsQ0FBQyxDQUFrQyxDQUFDO1lBQ3hFLElBQUksaUJBQWlCLEtBQUssWUFBWSxFQUFFO2dCQUN0QyxVQUFVLENBQUMsSUFBSSxDQUFDO29CQUNkLGNBQWMsRUFBRSx5Q0FBaUMsQ0FBQyxpQkFBaUIsQ0FBQztvQkFDcEUsS0FBSyxFQUFFLENBQUM7b0JBQ1IsZUFBZSxFQUFFLHlDQUFpQyxDQUFDLFlBQVksQ0FBQztpQkFDakUsQ0FBQyxDQUFDO2FBQ0o7U0FDRjtLQUNGO0lBRUQsT0FBTyxVQUFVLENBQUM7QUFDcEIsQ0FBQyxDQUFDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDbkxGOzs7Ozs7R0FNRztBQUNIO0lBZ0JFLHdCQUE0QixLQUFRLEVBQUUsS0FBYSxFQUFFLEdBQW1CO1FBQW5CLGlDQUFtQjtRQUE1QyxVQUFLLEdBQUwsS0FBSyxDQUFHO1FBZjFCLGVBQVUsR0FBVyxDQUFDLENBQUM7UUFDdkIsaUJBQVksR0FBVyxDQUFDLENBQUM7UUFlakMsSUFBSSxDQUFDLFVBQVUsR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDLEdBQUcsRUFBRSxLQUFLLENBQUMsQ0FBQztRQUN2QyxJQUFJLENBQUMsWUFBWSxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsS0FBSyxFQUFFLEdBQUcsQ0FBQyxDQUFDO0lBQzNDLENBQUM7SUFmRCxzQkFBVywrQkFBRzthQUFkO1lBQ0UsT0FBTyxJQUFJLENBQUMsVUFBVSxDQUFDO1FBQ3pCLENBQUM7OztPQUFBO0lBRUQsc0JBQVcsa0NBQU07YUFBakI7WUFDRSxPQUFPLElBQUksQ0FBQyxVQUFVLEdBQUcsSUFBSSxDQUFDLFlBQVksR0FBRyxDQUFDLENBQUM7UUFDakQsQ0FBQzs7O09BQUE7SUFFRCxzQkFBVyxpQ0FBSzthQUFoQjtZQUNFLE9BQU8sSUFBSSxDQUFDLFlBQVksQ0FBQztRQUMzQixDQUFDOzs7T0FBQTtJQU9NLGlDQUFRLEdBQWY7UUFBZ0IsZ0JBQW1CO2FBQW5CLFVBQW1CLEVBQW5CLHFCQUFtQixFQUFuQixJQUFtQjtZQUFuQiwyQkFBbUI7Ozs7WUFDakMsS0FBb0IsOEJBQU0saUZBQUU7Z0JBQXZCLElBQU0sS0FBSztnQkFDZCxJQUFJLEtBQUssR0FBRyxJQUFJLENBQUMsWUFBWSxJQUFJLEtBQUssR0FBRyxJQUFJLENBQUMsVUFBVSxJQUFJLEtBQUssS0FBSyxTQUFTLEVBQUU7b0JBQy9FLE9BQU8sS0FBSyxDQUFDO2lCQUNkO2FBQ0Y7Ozs7Ozs7OztRQUVELE9BQU8sSUFBSSxDQUFDO0lBQ2QsQ0FBQztJQUVNLG9DQUFXLEdBQWxCLFVBQW1CLE1BQWM7UUFDL0IsSUFBSSxNQUFNLEdBQUcsSUFBSSxDQUFDLFVBQVUsRUFBRTtZQUM1QixJQUFJLENBQUMsWUFBWSxHQUFHLElBQUksQ0FBQyxVQUFVLENBQUM7WUFDcEMsSUFBSSxDQUFDLFVBQVUsR0FBRyxNQUFNLENBQUM7U0FDMUI7YUFBTTtZQUNMLElBQUksQ0FBQyxZQUFZLEdBQUcsTUFBTSxDQUFDO1NBQzVCO0lBQ0gsQ0FBQztJQUVNLGtDQUFTLEdBQWhCLFVBQWlCLE1BQWM7UUFDN0IsSUFBSSxNQUFNLEdBQUcsSUFBSSxDQUFDLFlBQVksRUFBRTtZQUM5QixJQUFJLENBQUMsVUFBVSxHQUFHLElBQUksQ0FBQyxZQUFZLENBQUM7WUFDcEMsSUFBSSxDQUFDLFlBQVksR0FBRyxNQUFNLENBQUM7U0FDNUI7YUFBTTtZQUNMLElBQUksQ0FBQyxVQUFVLEdBQUcsTUFBTSxDQUFDO1NBQzFCO0lBQ0gsQ0FBQztJQUNILHFCQUFDO0FBQUQsQ0FBQztBQWhEWSx3Q0FBYzs7Ozs7Ozs7Ozs7Ozs7O0FDTDNCLElBQVksNEJBS1g7QUFMRCxXQUFZLDRCQUE0QjtJQUN0QyxpREFBaUI7SUFDakIsK0NBQWU7SUFDZiwrQ0FBZTtJQUNmLGlEQUFpQjtBQUNuQixDQUFDLEVBTFcsNEJBQTRCLEdBQTVCLG9DQUE0QixLQUE1QixvQ0FBNEIsUUFLdkM7Ozs7Ozs7Ozs7Ozs7OztBQ3VCRCxJQUFZLFFBUVg7QUFSRCxXQUFZLFFBQVE7SUFDbEIsdUNBQTJCO0lBQzNCLHFDQUF5QjtJQUN6Qix1QkFBVztJQUNYLDZCQUFpQjtJQUNqQix5Q0FBK0I7SUFDL0IsMkJBQWlCO0lBQ2pCLHVDQUE2QjtBQUMvQixDQUFDLEVBUlcsUUFBUSxHQUFSLGdCQUFRLEtBQVIsZ0JBQVEsUUFRbkI7QUE4QkQsSUFBWSwwQkFHWDtBQUhELFdBQVksMEJBQTBCO0lBQ3BDLGlEQUFtQjtJQUNuQixrREFBZTtBQUNqQixDQUFDLEVBSFcsMEJBQTBCLEdBQTFCLGtDQUEwQixLQUExQixrQ0FBMEIsUUFHckM7QUFlRCxJQUFZLHlCQVNYO0FBVEQsV0FBWSx5QkFBeUI7SUFDbkMsNENBQWlCO0lBQ2pCLDhDQUFtQjtJQUNuQiwyQ0FBZ0I7SUFDaEIsdURBQTRCO0lBQzVCLDZDQUFrQjtJQUNsQiw4Q0FBbUI7SUFDbkIsdUNBQVk7SUFDWix1Q0FBWTtBQUNkLENBQUMsRUFUVyx5QkFBeUIsR0FBekIsaUNBQXlCLEtBQXpCLGlDQUF5QixRQVNwQztBQVVELElBQVksc0JBUVg7QUFSRCxXQUFZLHNCQUFzQjtJQUNoQywrRUFBVTtJQUNWLHFFQUFLO0lBQ0wsbUZBQVk7SUFDWixxRUFBSztJQUNMLDJFQUFRO0lBQ1IsNkVBQVM7SUFDVCx5RUFBTztBQUNULENBQUMsRUFSVyxzQkFBc0IsR0FBdEIsOEJBQXNCLEtBQXRCLDhCQUFzQixRQVFqQztBQUVELElBQVksaUJBR1g7QUFIRCxXQUFZLGlCQUFpQjtJQUMzQix5REFBSTtJQUNKLDJEQUFLO0FBQ1AsQ0FBQyxFQUhXLGlCQUFpQixHQUFqQix5QkFBaUIsS0FBakIseUJBQWlCLFFBRzVCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ3RIRCwrRUFBMkI7QUFFM0IsZ0ZBWTBCO0FBRTFCOzs7O0dBSUc7QUFDSDtJQXFIRTtRQUhVLGFBQVEsR0FBVyxFQUFFLENBQUM7UUFDdEIsWUFBTyxHQUFrQixJQUFJLEdBQUcsQ0FBQyxTQUFTLEVBQUUsQ0FBQztJQUVoQyxDQUFDO0lBbEhWLHVCQUFjLEdBQTVCO1FBQ0UsT0FBTyxJQUFJLFFBQVEsRUFBRSxDQUFDO0lBQ3hCLENBQUM7SUFFRDs7OztPQUlHO0lBQ2lCLGtCQUFTLEdBQTdCLFVBQThCLElBQXdCO1FBQXhCLGdDQUF3Qjs7Ozs7O3dCQUM5QyxNQUFNLEdBQUcsSUFBSSxRQUFRLEVBQUUsQ0FBQzt3QkFDOUIsV0FBTTt3QkFBWSxxQkFBTSxHQUFHLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQzs7d0JBQTFDLEdBQU8sT0FBTyxHQUFHLENBQUMsU0FBd0IsQ0FBa0IsQ0FBQzt3QkFDN0QsTUFBTSxDQUFDLFFBQVEsR0FBRyxPQUFPLElBQUksS0FBSyxRQUFRLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQzt3QkFFOUQsc0JBQU8sTUFBTSxFQUFDOzs7O0tBQ2Y7SUFFYSw2QkFBb0IsR0FBbEMsVUFBbUMsT0FBc0I7UUFDdkQsSUFBTSxNQUFNLEdBQUcsSUFBSSxRQUFRLEVBQUUsQ0FBQztRQUM5QixNQUFNLENBQUMsT0FBTyxHQUFHLE9BQU8sQ0FBQztRQUV6QixPQUFPLE1BQU0sQ0FBQztJQUNoQixDQUFDO0lBSUQsc0JBQVcsd0NBQWtCO2FBQTdCO1lBQUEsaUJBc0JDO1lBckJDLElBQUksQ0FBQyxJQUFJLENBQUMsV0FBVyxFQUFFO2dCQUNyQixJQUFNLFFBQU0sR0FBRyxJQUFJLHdCQUFpQixFQUFFLENBQUM7Z0JBQ3ZDLElBQUksQ0FBQyxPQUFPLENBQUMsV0FBVyxDQUFDLHNCQUFZO29CQUNuQyxJQUFJLFlBQVksQ0FBQyxTQUFTLEVBQUUsRUFBRTt3QkFDNUIsSUFBTSxHQUFDLEdBQUcsWUFBWSxDQUFDLEtBQUssQ0FBQzt3QkFDN0IsS0FBSSxDQUFDLE9BQU8sQ0FBQyxXQUFXLENBQUMsc0JBQVk7NEJBQ25DLElBQU0sQ0FBQyxHQUFHLFlBQVksQ0FBQyxLQUFLLENBQUM7NEJBQzdCLElBQUksWUFBWSxDQUFDLFNBQVMsRUFBRSxJQUFJLEdBQUMsS0FBSyxDQUFDLEVBQUU7Z0NBQ3ZDLFFBQU0sQ0FBQyxnQkFBZ0IsQ0FBQztvQ0FDdEIsSUFBSSxFQUFFLEtBQUksQ0FBQyx5QkFBeUIsQ0FBQyxHQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsSUFBSTtvQ0FDL0MsQ0FBQztvQ0FDRCxDQUFDO2lDQUNGLENBQUMsQ0FBQzs2QkFDSjt3QkFDSCxDQUFDLENBQUMsQ0FBQztxQkFDSjtnQkFDSCxDQUFDLENBQUMsQ0FBQztnQkFDSCxJQUFJLENBQUMsV0FBVyxHQUFHLFFBQU0sQ0FBQzthQUMzQjtZQUVELE9BQU8sSUFBSSxDQUFDLFdBQVcsQ0FBQztRQUMxQixDQUFDOzs7T0FBQTtJQUVELHNCQUFXLGtDQUFZO2FBQXZCO1lBQ0UsT0FBTyxJQUFJLENBQUMsT0FBTyxDQUFDO1FBQ3RCLENBQUM7OztPQUFBO0lBRUQsc0JBQVcsd0NBQWtCO2FBQTdCO1lBQ0UsSUFBTSxNQUFNLEdBQUcsSUFBSSxLQUFLLEVBQTJCLENBQUM7WUFDcEQsSUFBSSxDQUFDLE9BQU8sQ0FBQyxXQUFXLENBQUMsaUJBQU87Z0JBQzlCLElBQUksT0FBTyxDQUFDLFNBQVMsRUFBRSxFQUFFO29CQUN2QixJQUFJLFFBQVEsR0FBRyxHQUErQixDQUFDO29CQUMvQyxJQUFJLE9BQU8sQ0FBQyxPQUFPLEVBQUUsRUFBRTt3QkFDckIsUUFBUSxHQUFHLEdBQUcsQ0FBQztxQkFDaEI7eUJBQU0sSUFBSSxPQUFPLENBQUMsT0FBTyxFQUFFLEVBQUU7d0JBQzVCLFFBQVEsR0FBRyxHQUFHLENBQUM7cUJBQ2hCO3lCQUFNLElBQUksT0FBTyxDQUFDLE1BQU0sRUFBRSxFQUFFO3dCQUMzQixPQUFPO3FCQUNSO29CQUNELE1BQU0sQ0FBQyxJQUFJLENBQUMsRUFBRSxLQUFLLEVBQUUsT0FBTyxDQUFDLEtBQUssRUFBRSxRQUFRLFlBQUUsQ0FBQyxDQUFDO2lCQUNqRDtZQUNILENBQUMsQ0FBQyxDQUFDO1lBRUgsT0FBTyxNQUFNLENBQUM7UUFDaEIsQ0FBQzs7O09BQUE7SUFFRCxzQkFBVyxnREFBMEI7YUFBckM7WUFDRSxJQUFNLE1BQU0sR0FBRyxJQUFJLEtBQUssRUFBaUMsQ0FBQztZQUMxRCxJQUFJLENBQUMsT0FBTyxDQUFDLFdBQVcsQ0FBQyxpQkFBTztnQkFDOUIsSUFBSSxPQUFPLENBQUMsU0FBUyxFQUFFLEVBQUU7b0JBQ2YsbUNBQVUsQ0FBYTtvQkFDL0IsT0FBTyxDQUFDLE1BQU0sQ0FBQyxVQUFVLENBQUMsRUFBRTt3QkFDMUIsTUFBTSxDQUFDLElBQUksQ0FBQyxJQUFJLEtBQUssRUFBK0IsQ0FBQyxDQUFDO3FCQUN2RDtvQkFFRCxJQUFJLFFBQVEsR0FBRyxHQUErQixDQUFDO29CQUMvQyxJQUFJLE9BQU8sQ0FBQyxPQUFPLEVBQUUsRUFBRTt3QkFDckIsUUFBUSxHQUFHLEdBQUcsQ0FBQztxQkFDaEI7eUJBQU0sSUFBSSxPQUFPLENBQUMsT0FBTyxFQUFFLEVBQUU7d0JBQzVCLFFBQVEsR0FBRyxHQUFHLENBQUM7cUJBQ2hCO29CQUVELElBQUksTUFBTSxDQUFDLFVBQVUsQ0FBQyxDQUFDLE1BQU0sSUFBSSxDQUFDLElBQUksTUFBTSxDQUFDLFVBQVUsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxVQUFVLENBQUMsQ0FBQyxNQUFNLEdBQUcsQ0FBQyxDQUFDLENBQUMsS0FBSyxLQUFLLFFBQVEsRUFBRTt3QkFDMUcsTUFBTSxDQUFDLFVBQVUsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxVQUFVLENBQUMsQ0FBQyxNQUFNLEdBQUcsQ0FBQyxDQUFDLENBQUMsU0FBUyxDQUFDLE9BQU8sQ0FBQyxLQUFLLENBQUMsQ0FBQztxQkFDNUU7eUJBQU07d0JBQ0wsTUFBTSxDQUFDLFVBQVUsQ0FBQyxDQUFDLElBQUksQ0FBQyxJQUFJLHFCQUFjLENBQUMsUUFBUSxFQUFFLE9BQU8sQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDO3FCQUN0RTtpQkFDRjtZQUNILENBQUMsQ0FBQyxDQUFDO1lBRUgsT0FBTyxNQUFNLENBQUM7UUFDaEIsQ0FBQzs7O09BQUE7SUFFRCxzQkFBVywwQkFBSTthQUFmO1lBQ0UsSUFBTSxTQUFTLEdBQUcsSUFBSSxDQUFDLFFBQVEsQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLENBQUM7WUFDM0MsSUFBTSxRQUFRLEdBQUcsU0FBUyxDQUFDLFNBQVMsQ0FBQyxNQUFNLEdBQUcsQ0FBQyxDQUFDLENBQUM7WUFFakQsT0FBTyxRQUFRLENBQUMsS0FBSyxDQUFDLENBQUMsRUFBRSxRQUFRLENBQUMsV0FBVyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7UUFDdEQsQ0FBQzs7O09BQUE7SUFFRCxzQkFBVyw4QkFBUTthQUFuQjtZQUNFLE9BQU8sSUFBSSxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxXQUFXLEVBQUUsQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQztRQUNqRSxDQUFDOzs7T0FBQTtJQU9NLDhCQUFXLEdBQWxCLFVBQW1CLFFBQTZDO1FBQzlELElBQUksQ0FBQyxPQUFPLENBQUMsV0FBVyxDQUFDLFFBQVEsQ0FBQyxDQUFDO0lBQ3JDLENBQUM7SUFFRDs7Ozs7O09BTUc7SUFDSSw2Q0FBMEIsR0FBakMsVUFBa0MsY0FBZ0MsRUFBRSxpQkFBNkM7UUFBakgsaUJBMENDO1FBekNDLElBQU0sTUFBTSxHQUFHLElBQUksd0JBQWlCLENBQUMsY0FBYyxDQUFDLENBQUM7UUFDckQsSUFBTSxPQUFPLEdBQUcsSUFBSSxDQUFDLE9BQU8sQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxpQkFBaUIsQ0FBQyxDQUFDO1FBRXRFLElBQU0sT0FBTyxHQUVULEVBQUUsQ0FBQztRQUVQLElBQUksQ0FBQyxPQUFPLENBQUMsV0FBVyxDQUFDLHNCQUFZO1lBQ25DLEtBQUksQ0FBQyxPQUFPLENBQUMsV0FBVyxDQUFDLHNCQUFZO2dCQUNuQyxJQUFJLFlBQVksQ0FBQyxTQUFTLEVBQUUsSUFBSSxZQUFZLENBQUMsU0FBUyxFQUFFLEVBQUU7b0JBQ3hELElBQUksaUJBQWlCLEtBQUssaUNBQTBCLENBQUMsT0FBTyxFQUFFO3dCQUM1RCxJQUFNLHVCQUF1QixHQUFHLEtBQUksQ0FBQyw2QkFBNkIsQ0FBQyxZQUFZLENBQUMsS0FBSyxFQUFFLE9BQU8sQ0FBQyxDQUFDO3dCQUNoRyxJQUFNLHdCQUF3QixHQUFHLEtBQUksQ0FBQyw2QkFBNkIsQ0FBQyxZQUFZLENBQUMsS0FBSyxFQUFFLE9BQU8sQ0FBQyxDQUFDO3dCQUNqRyxNQUFNLENBQUMsZ0JBQWdCLENBQUM7NEJBQ3RCLElBQUksRUFBRSxLQUFJLENBQUMsT0FBTztpQ0FDZixZQUFZLENBQUMsdUJBQXVCLENBQUM7aUNBQ3JDLFVBQVUsQ0FBQyxLQUFJLENBQUMsT0FBTyxDQUFDLFlBQVksQ0FBQyx3QkFBd0IsQ0FBQyxDQUFDOzRCQUNsRSxDQUFDLEVBQUUsWUFBWSxDQUFDLEtBQUs7NEJBQ3JCLENBQUMsRUFBRSxZQUFZLENBQUMsS0FBSzt5QkFDdEIsQ0FBQyxDQUFDO3FCQUNKO3lCQUFNO3dCQUNMLElBQU0sR0FBRyxHQUFNLElBQUksQ0FBQyxHQUFHLENBQUMsWUFBWSxDQUFDLEtBQUssRUFBRSxZQUFZLENBQUMsS0FBSyxDQUFDLFNBQUksSUFBSSxDQUFDLEdBQUcsQ0FDekUsWUFBWSxDQUFDLEtBQUssRUFDbEIsWUFBWSxDQUFDLEtBQUssQ0FDakIsQ0FBQzt3QkFDSixJQUFJLENBQUMsT0FBTyxDQUFDLEdBQUcsQ0FBQyxFQUFFOzRCQUNqQixPQUFPLENBQUMsR0FBRyxDQUFDLEdBQUcsS0FBSSxDQUFDLCtCQUErQixDQUFDLFlBQVksQ0FBQyxLQUFLLEVBQUUsWUFBWSxDQUFDLEtBQUssQ0FBQyxDQUFDLElBQUksQ0FBQzt5QkFDbEc7d0JBRUQsTUFBTSxDQUFDLGdCQUFnQixDQUFDOzRCQUN0QixJQUFJLEVBQUUsT0FBTyxDQUFDLEdBQUcsQ0FBQzs0QkFDbEIsQ0FBQyxFQUFFLFlBQVksQ0FBQyxLQUFLOzRCQUNyQixDQUFDLEVBQUUsWUFBWSxDQUFDLEtBQUs7eUJBQ3RCLENBQUMsQ0FBQztxQkFDSjtpQkFDRjtZQUNILENBQUMsQ0FBQyxDQUFDO1FBQ0wsQ0FBQyxDQUFDLENBQUM7UUFDSCxJQUFJLENBQUMsV0FBVyxHQUFHLE1BQU0sQ0FBQztRQUUxQixPQUFPLElBQUksQ0FBQyxXQUFXLENBQUM7SUFDMUIsQ0FBQztJQUVEOzs7Ozs7T0FNRztJQUNJLGdEQUE2QixHQUFwQyxVQUFxQyxZQUFvQixFQUFFLE9BQWU7UUFDaEUsNENBQVksQ0FBa0I7UUFDdEMsSUFBTSxVQUFVLEdBQUcsWUFBWSxDQUFDLFVBQVUsQ0FBQyxZQUFZLENBQUMsQ0FBQztRQUN6RCxJQUFNLFNBQVMsR0FBRyxZQUFZLENBQUMsU0FBUyxDQUFDLFlBQVksQ0FBQyxDQUFDO1FBRXZELElBQUksTUFBTSxHQUFHLFVBQVUsQ0FBQztRQUN4QixPQUFPLFlBQVksQ0FBQyxhQUFhLENBQUMsTUFBTSxDQUFDLEtBQUssT0FBTyxJQUFJLE1BQU0sR0FBRyxVQUFVLEdBQUcsU0FBUyxFQUFFO1lBQ3hGLE1BQU0sRUFBRSxDQUFDO1NBQ1Y7UUFFRCxPQUFPLE1BQU0sQ0FBQztJQUNoQixDQUFDO0lBRUQ7Ozs7OztPQU1HO0lBQ0ksNENBQXlCLEdBQWhDLFVBQWlDLE1BQWMsRUFBRSxNQUFjO1FBQzdELE9BQU8sSUFBSSxDQUFDLCtCQUErQixDQUN6QyxJQUFJLENBQUMsT0FBTyxDQUFDLFlBQVksQ0FBQyxLQUFLLENBQUMsT0FBTyxDQUFDLE1BQU0sQ0FBQyxFQUMvQyxJQUFJLENBQUMsT0FBTyxDQUFDLFlBQVksQ0FBQyxLQUFLLENBQUMsT0FBTyxDQUFDLE1BQU0sQ0FBQyxDQUNoRCxDQUFDO0lBQ0osQ0FBQztJQUVNLGdEQUE2QixHQUFwQyxVQUFxQyxRQUEyQjtRQUM5RCxJQUFNLE1BQU0sR0FBRyxJQUFJLEtBQUssRUFBMEIsQ0FBQztRQUNuRCxJQUFJLENBQUMsV0FBVyxDQUFDLGlCQUFPO1lBQ3RCLElBQU0sVUFBVSxHQUFHLE9BQU8sQ0FBQyxPQUFPLENBQUMsV0FBVyxFQUFrQyxDQUFDO1lBQ2pGLElBQU0saUJBQWlCLEdBQUcsUUFBUSxDQUFDLHFCQUFxQixDQUFDLE9BQU8sQ0FBQyxLQUFLLENBQUMsQ0FBQztZQUN4RSxJQUNFLGlCQUFpQjtnQkFDakIsdUNBQWdDLENBQUMsVUFBVSxDQUFDO29CQUMxQyx3Q0FBaUMsQ0FBQyxpQkFBaUIsQ0FBQyxnQkFBZ0IsQ0FBQyxFQUN2RTtnQkFDQSxNQUFNLENBQUMsSUFBSSxDQUFDO29CQUNWLGNBQWMsRUFBRSx3Q0FBaUMsQ0FBQyxpQkFBaUIsQ0FBQyxnQkFBZ0IsQ0FBQztvQkFDckYsS0FBSyxFQUFFLE9BQU8sQ0FBQyxLQUFLO29CQUNwQixlQUFlLEVBQUUsdUNBQWdDLENBQUMsVUFBVSxDQUFDO2lCQUM5RCxDQUFDLENBQUM7YUFDSjtRQUNILENBQUMsQ0FBQyxDQUFDO1FBRUgsT0FBTyxNQUFNLENBQUM7SUFDaEIsQ0FBQztJQUVEOzs7Ozs7T0FNRztJQUNPLGtEQUErQixHQUF6QyxVQUEwQyxNQUFjLEVBQUUsTUFBYztRQUM5RCw0Q0FBWSxDQUFrQjtRQUN0QyxJQUFNLGFBQWEsR0FBRyxZQUFZLENBQUMsU0FBUyxDQUFDLE1BQU0sQ0FBQyxDQUFDO1FBQ3JELElBQU0sY0FBYyxHQUFHLFlBQVksQ0FBQyxTQUFTLENBQUMsTUFBTSxDQUFDLENBQUM7UUFDdEQsSUFBTSxjQUFjLEdBQUcsWUFBWSxDQUFDLFVBQVUsQ0FBQyxNQUFNLENBQUMsQ0FBQztRQUN2RCxJQUFNLGVBQWUsR0FBRyxZQUFZLENBQUMsVUFBVSxDQUFDLE1BQU0sQ0FBQyxDQUFDO1FBRXhELElBQUksTUFBTSxHQUFHO1lBQ1gsVUFBVSxFQUFFLENBQUMsQ0FBQztZQUNkLFVBQVUsRUFBRSxDQUFDLENBQUM7WUFDZCxJQUFJLEVBQUUsTUFBTSxDQUFDLGdCQUFnQjtTQUM5QixDQUFDO1FBQ0YsS0FBSyxJQUFJLFlBQVksR0FBRyxDQUFDLEVBQUUsWUFBWSxHQUFHLGFBQWEsRUFBRSxFQUFFLFlBQVksRUFBRTtZQUN2RSxLQUFLLElBQUksYUFBYSxHQUFHLENBQUMsRUFBRSxhQUFhLEdBQUcsY0FBYyxFQUFFLEVBQUUsYUFBYSxFQUFFO2dCQUMzRSxJQUFNLFVBQVUsR0FBRyxjQUFjLEdBQUcsWUFBWSxDQUFDO2dCQUNqRCxJQUFNLFVBQVUsR0FBRyxlQUFlLEdBQUcsYUFBYSxDQUFDO2dCQUNuRCxJQUFNLElBQUksR0FBRyxJQUFJLENBQUMsT0FBTyxDQUFDLFlBQVksQ0FBQyxVQUFVLENBQUMsQ0FBQyxVQUFVLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxZQUFZLENBQUMsVUFBVSxDQUFDLENBQUMsQ0FBQztnQkFDckcsSUFBSSxJQUFJLEdBQUcsTUFBTSxDQUFDLElBQUksRUFBRTtvQkFDdEIsTUFBTSxHQUFHO3dCQUNQLFVBQVU7d0JBQ1YsVUFBVTt3QkFDVixJQUFJO3FCQUNMLENBQUM7aUJBQ0g7YUFDRjtTQUNGO1FBRUQsT0FBTyxNQUFNLENBQUM7SUFDaEIsQ0FBQztJQXZRc0IsMEJBQWlCLEdBQUcsTUFBTSxDQUFDO0lBd1FwRCxlQUFDO0NBQUE7QUF6UVksNEJBQVE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ3JCckIsZ0ZBQWlHO0FBRWpHOzs7Ozs7R0FNRztBQUNIO0lBaUJFLDJCQUFtQixNQUE2Qjs7UUFBN0Isb0NBQTZCO1FBQWhELGlCQUlDO1FBcEJTLGFBQVEsR0FBdUIsSUFBSSxLQUFLLEVBQW9CLENBQUM7UUFFdkUsdURBQXVEO1FBQzdDLHdCQUFtQixHQUFXLENBQUMsQ0FBQztRQUVoQyxlQUFVLEdBQUc7WUFDckIsR0FBRyxFQUFFLEVBQUU7WUFDUCxHQUFHLEVBQUUsQ0FBQztTQUNQLENBQUM7UUFFRixnQ0FBZ0M7UUFDeEIsZUFBVSxHQUFHLENBQUMsQ0FBQztRQUV2QixnQ0FBZ0M7UUFDeEIsZUFBVSxHQUFHLENBQUMsQ0FBQztRQTRKdkI7O1dBRUc7UUFDSSxxQkFBZ0IsR0FBRyxVQUFDLFFBQWdCLEVBQUUsU0FBaUI7WUFDNUQsSUFBTSxHQUFHLEdBQUcsS0FBSSxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLFFBQVEsRUFBRSxTQUFTLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQztZQUU3RCxPQUFPLEdBQUcsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsUUFBUSxFQUFFLFNBQVMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxTQUFTLENBQUM7UUFDbEUsQ0FBQyxDQUFDO1FBRUssYUFBUSxHQUFHLFVBQUMsUUFBZ0IsRUFBRSxTQUFpQjtZQUNwRCxZQUFJLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsUUFBUSxFQUFFLFNBQVMsQ0FBQyxHQUFHLENBQUMsQ0FBQztnQkFDaEQsS0FBSSxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLFFBQVEsRUFBRSxTQUFTLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLFFBQVEsRUFBRSxTQUFTLENBQUMsR0FBRyxDQUFDLENBQUMsS0FBSyxTQUFTO1FBRGpHLENBQ2lHLENBQUM7O1lBcEtsRyxLQUFvQiw4QkFBTSxpRkFBRTtnQkFBdkIsSUFBTSxLQUFLO2dCQUNkLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxLQUFLLENBQUMsQ0FBQzthQUM5Qjs7Ozs7Ozs7O0lBQ0gsQ0FBQztJQUVELHNCQUFXLDBDQUFXO2FBQXRCO1lBQ0UsT0FBTyxJQUFJLENBQUMsUUFBUSxDQUFDO1FBQ3ZCLENBQUM7OztPQUFBO0lBRUQsc0JBQVcsMENBQVc7YUFBdEI7WUFDRSxPQUFPLElBQUksQ0FBQyxVQUFVLENBQUMsR0FBRyxHQUFHLElBQUksQ0FBQyxVQUFVLENBQUMsR0FBRyxHQUFHLENBQUMsQ0FBQztRQUN2RCxDQUFDOzs7T0FBQTtJQUVELHNCQUFXLDZDQUFjO2FBQXpCO1lBQ0UsT0FBTyxLQUFLLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLElBQUksQ0FBQyxVQUFDLENBQUMsRUFBRSxDQUFDO2dCQUNoQyxJQUFJLENBQUMsQ0FBQyxFQUFFLElBQUksQ0FBQyxDQUFDLEVBQUUsRUFBRTtvQkFDaEIsT0FBTyxDQUFDLENBQUMsRUFBRSxHQUFHLENBQUMsQ0FBQyxFQUFFLENBQUM7aUJBQ3BCO3FCQUFNLElBQUksQ0FBQyxDQUFDLEVBQUUsSUFBSSxDQUFDLENBQUMsQ0FBQyxFQUFFLEVBQUU7b0JBQ3hCLE9BQU8sQ0FBQyxDQUFDLENBQUM7aUJBQ1g7cUJBQU0sSUFBSSxDQUFDLENBQUMsQ0FBQyxFQUFFLElBQUksQ0FBQyxDQUFDLEVBQUUsRUFBRTtvQkFDeEIsT0FBTyxDQUFDLENBQUM7aUJBQ1Y7Z0JBRUQsT0FBTyxDQUFDLENBQUM7WUFDWCxDQUFDLENBQUMsQ0FBQztRQUNMLENBQUM7OztPQUFBO0lBRUQsc0JBQVcsZ0RBQWlCO2FBQTVCO1lBQ0UsT0FBTyxJQUFJLENBQUMsVUFBVSxDQUFDO1FBQ3pCLENBQUM7OztPQUFBO0lBRUQsc0JBQVcsdUNBQVE7YUFBbkI7WUFDRSxJQUFJLE1BQU0sR0FBRyxFQUFFLENBQUM7WUFDaEIsS0FBSyxJQUFJLENBQUMsR0FBRyxJQUFJLENBQUMsVUFBVSxDQUFDLEdBQUcsRUFBRSxDQUFDLElBQUksSUFBSSxDQUFDLFVBQVUsQ0FBQyxHQUFHLEVBQUUsRUFBRSxDQUFDLEVBQUU7Z0JBQy9ELElBQU0sU0FBUyxHQUFHLElBQUksQ0FBQyxxQkFBcUIsQ0FBQyxDQUFDLENBQUMsQ0FBQztnQkFDaEQsSUFBSSxTQUFTLEVBQUU7b0JBQ2IsTUFBTSxJQUFJLFNBQVMsQ0FBQyxnQkFBZ0IsQ0FBQztpQkFDdEM7YUFDRjtZQUVELE9BQU8sTUFBTSxDQUFDO1FBQ2hCLENBQUM7OztPQUFBO0lBRUQsc0JBQVcsNENBQWE7YUFBeEI7WUFDRSxPQUFPLElBQUksQ0FBQyxtQkFBbUIsQ0FBQztRQUNsQyxDQUFDOzs7T0FBQTtJQUVNLDRCQUFDLE1BQU0sQ0FBQyxRQUFRLENBQUMsR0FBeEI7UUFDRSxPQUFPLElBQUksQ0FBQztJQUNkLENBQUM7SUFFRDs7OztPQUlHO0lBQ0ksNENBQWdCLEdBQXZCLFVBQXdCLEtBQXFCO1FBQ25DLG1CQUFHLEVBQUUsZUFBRyxFQUFFLFdBQUMsRUFBRSxXQUFDLENBQVc7UUFFakMsSUFBTSxlQUFlLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDO1FBQzNDLElBQU0sZUFBZSxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQztRQUUzQyxJQUFNLFNBQVMsR0FBRyxlQUFlLEdBQUcsQ0FBQyxLQUFLLENBQUMsQ0FBQztRQUU1QyxJQUFJLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxlQUFlLENBQUMsRUFBRTtZQUNuQyxJQUFJLENBQUMsUUFBUSxDQUFDLGVBQWUsQ0FBQyxHQUFHLElBQUksS0FBSyxFQUFrQixDQUFDO1NBQzlEO1FBQ0QsSUFBSSxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsZUFBZSxDQUFDLENBQUMsZUFBZSxDQUFDLEVBQUU7WUFDcEQsSUFBSSxDQUFDLG1CQUFtQixFQUFFLENBQUM7U0FDNUI7UUFDRCxJQUFJLENBQUMsUUFBUSxDQUFDLGVBQWUsQ0FBQyxDQUFDLGVBQWUsQ0FBQyxnQkFDMUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxlQUFlLENBQUMsQ0FBQyxlQUFlLENBQUMsRUFDL0MsS0FBSyxDQUNULENBQUM7UUFFRixJQUFJLFNBQVMsRUFBRTtZQUNiLElBQUksQ0FBQyxRQUFRLENBQUMsZUFBZSxDQUFDLENBQUMsZUFBZSxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQztZQUN0RCxJQUFJLENBQUMsUUFBUSxDQUFDLGVBQWUsQ0FBQyxDQUFDLGVBQWUsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUM7WUFDdEQsSUFBSSxHQUFHLElBQUksR0FBRyxFQUFFO2dCQUNkLElBQUksQ0FBQyxRQUFRLENBQUMsZUFBZSxDQUFDLENBQUMsZUFBZSxDQUFDLENBQUMsR0FBRyxHQUFHLEdBQUcsQ0FBQztnQkFDMUQsSUFBSSxDQUFDLFFBQVEsQ0FBQyxlQUFlLENBQUMsQ0FBQyxlQUFlLENBQUMsQ0FBQyxHQUFHLEdBQUcsR0FBRyxDQUFDO2FBQzNEO1NBQ0Y7UUFFRCxJQUFJLENBQUMsVUFBVSxHQUFHO1lBQ2hCLEdBQUcsRUFBRSxJQUFJLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxVQUFVLENBQUMsR0FBRyxFQUFFLGVBQWUsR0FBRyxDQUFDLENBQUM7WUFDdkQsR0FBRyxFQUFFLElBQUksQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLFVBQVUsQ0FBQyxHQUFHLEVBQUUsZUFBZSxHQUFHLENBQUMsQ0FBQztTQUN4RCxDQUFDO0lBQ0osQ0FBQztJQUVNLGlEQUFxQixHQUE1QixVQUE2QixLQUFhOztRQUN4QyxJQUFJLEtBQUssR0FBRyxJQUFJLENBQUMsV0FBVyxHQUFHLENBQUMsRUFBRTtZQUNoQyxPQUFPLFNBQVMsQ0FBQztTQUNsQjs7WUFDRCxLQUEyQixzQkFBSSxDQUFDLFdBQVcsNkNBQUU7Z0JBQXhDLElBQU0sWUFBWTtnQkFDckIsSUFBSSxZQUFZLEVBQUU7O3dCQUNoQixLQUEyQiwwQ0FBWSwrR0FBRTs0QkFBcEMsSUFBTSxZQUFZOzRCQUNyQixJQUFJLFlBQVksSUFBSSxZQUFZLENBQUMsQ0FBQyxLQUFLLEtBQUssSUFBSSxZQUFZLENBQUMsR0FBRyxFQUFFO2dDQUNoRSxPQUFPLHdDQUFpQyxDQUFDLFlBQVksQ0FBQyxHQUFHLENBQUMsQ0FBQzs2QkFDNUQ7aUNBQU0sSUFBSSxZQUFZLElBQUksWUFBWSxDQUFDLENBQUMsS0FBSyxLQUFLLElBQUksWUFBWSxDQUFDLEdBQUcsRUFBRTtnQ0FDdkUsT0FBTyx3Q0FBaUMsQ0FBQyxZQUFZLENBQUMsR0FBRyxDQUFDLENBQUM7NkJBQzVEO3lCQUNGOzs7Ozs7Ozs7aUJBQ0Y7YUFDRjs7Ozs7Ozs7O1FBRUQsT0FBTyxTQUFTLENBQUM7SUFDbkIsQ0FBQztJQUVEOzs7Ozs7T0FNRztJQUNJLCtDQUFtQixHQUExQixVQUEyQixVQUFzQixFQUFFLGdCQUFvQjtRQUE1QywyQ0FBc0I7UUFBRSx1REFBb0I7O1FBQ3JFLElBQU0sTUFBTSxHQUFHLElBQUksS0FBSyxFQUFrQixDQUFDOztZQUMzQyxLQUFvQixzQkFBSSw2Q0FBRTtnQkFBckIsSUFBTSxLQUFLO2dCQUNkLElBQUksS0FBSyxDQUFDLElBQUksSUFBSSxLQUFLLENBQUMsSUFBSSxJQUFJLFVBQVUsSUFBSSxJQUFJLENBQUMsR0FBRyxDQUFDLEtBQUssQ0FBQyxDQUFDLEdBQUcsS0FBSyxDQUFDLENBQUMsQ0FBQyxJQUFJLGdCQUFnQixFQUFFO29CQUM3RixNQUFNLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDO2lCQUNwQjthQUNGOzs7Ozs7Ozs7UUFFRCxPQUFPLE1BQU0sQ0FBQztJQUNoQixDQUFDO0lBRUQ7Ozs7Ozs7T0FPRztJQUNJLGdEQUFvQixHQUEzQixVQUE0QixzQkFBOEIsRUFBRSxnQkFBb0IsRUFBRSx5QkFBNkI7UUFBbkQsdURBQW9CO1FBQUUseUVBQTZCOztRQUM3RyxJQUFNLE1BQU0sR0FBRztZQUNiLE9BQU8sRUFBRSxJQUFJLEtBQUssRUFBa0I7WUFDcEMsU0FBUyxFQUFFLElBQUksS0FBSyxFQUFrQjtTQUN2QyxDQUFDOztZQUVGLEtBQXNCLHNCQUFJLENBQUMsY0FBYztpQkFDdEMsTUFBTSxDQUFDLGVBQUssSUFBSSxXQUFJLENBQUMsR0FBRyxDQUFDLEtBQUssQ0FBQyxDQUFDLEdBQUcsS0FBSyxDQUFDLENBQUMsQ0FBQyxJQUFJLGdCQUFnQixFQUEvQyxDQUErQyxDQUFDO2lCQUNoRSxLQUFLLENBQUMsQ0FBQyxFQUFFLHNCQUFzQixDQUFDLDZDQUFFO2dCQUZoQyxJQUFNLE9BQU87Z0JBR2hCLElBQUksT0FBTyxDQUFDLElBQUksSUFBSSxPQUFPLENBQUMsSUFBSSxHQUFHLHlCQUF5QixFQUFFO29CQUM1RCxNQUFNLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsQ0FBQztpQkFDOUI7Z0JBQ0QsTUFBTSxDQUFDLFNBQVMsQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLENBQUM7YUFDaEM7Ozs7Ozs7OztRQUVELE9BQU8sTUFBTSxDQUFDO0lBQ2hCLENBQUM7SUFlTSxnQ0FBSSxHQUFYO1FBQ0UsS0FBSyxJQUFJLENBQUMsR0FBRyxJQUFJLENBQUMsVUFBVSxFQUFFLENBQUMsR0FBRyxJQUFJLENBQUMsUUFBUSxDQUFDLE1BQU0sRUFBRSxFQUFFLENBQUMsRUFBRTtZQUMzRCxJQUFJLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDLEVBQUU7Z0JBQ3BCLEtBQUssSUFBSSxDQUFDLEdBQUcsSUFBSSxDQUFDLFVBQVUsRUFBRSxDQUFDLEdBQUcsSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUMsQ0FBQyxNQUFNLEVBQUUsRUFBRSxDQUFDLEVBQUU7b0JBQzlELElBQU0sS0FBSyxHQUFHLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7b0JBQ2xDLElBQUksS0FBSyxFQUFFO3dCQUNULElBQUksQ0FBQyxVQUFVLEdBQUcsQ0FBQyxDQUFDO3dCQUNwQixJQUFJLENBQUMsVUFBVSxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUM7d0JBRXhCLE9BQU87NEJBQ0wsSUFBSSxFQUFFLEtBQUs7NEJBQ1gsS0FBSyxFQUFFLEtBQUs7eUJBQ2IsQ0FBQztxQkFDSDtpQkFDRjtnQkFDRCxJQUFJLENBQUMsVUFBVSxHQUFHLENBQUMsQ0FBQzthQUNyQjtTQUNGO1FBRUQsSUFBSSxDQUFDLFVBQVUsR0FBRyxDQUFDLENBQUM7UUFDcEIsSUFBSSxDQUFDLFVBQVUsR0FBRyxDQUFDLENBQUM7UUFFcEIsT0FBTztZQUNMLElBQUksRUFBRSxJQUFJO1lBQ1YsS0FBSyxFQUFFLElBQVc7U0FDbkIsQ0FBQztJQUNKLENBQUM7SUFFTSx5Q0FBYSxHQUFwQixVQUFxQixDQUFTLEVBQUUsQ0FBUyxFQUFFLEtBQStDO1FBQ3hGLElBQUksQ0FBQyxnQkFBZ0IsWUFBRyxDQUFDLEtBQUUsQ0FBQyxPQUFLLEtBQUssRUFBRyxDQUFDO0lBQzVDLENBQUM7SUFDSCx3QkFBQztBQUFELENBQUM7QUF2TlksOENBQWlCOzs7Ozs7Ozs7Ozs7Ozs7QUNQOUIsSUFBWSxpQkFXWDtBQVhELFdBQVksaUJBQWlCO0lBQzNCLGlFQUFpRTtJQUNqRSxnQ0FBYTtJQUNiLG1FQUFtRTtJQUNuRSw4Q0FBMkI7SUFDM0IsZ0ZBQWdGO0lBQ2hGLHdDQUFxQjtJQUNyQix5RkFBeUY7SUFDekYsNENBQXlCO0lBQ3pCLDZFQUE2RTtJQUM3RSw0Q0FBeUI7QUFDM0IsQ0FBQyxFQVhXLGlCQUFpQixHQUFqQix5QkFBaUIsS0FBakIseUJBQWlCLFFBVzVCOzs7Ozs7Ozs7Ozs7OztBQ2JELGlCQUFpQjtBQUNqQixzREFBc0Q7O0FBaUx0RCxJQUFZLG9CQVdYO0FBWEQsV0FBWSxvQkFBb0I7SUFDOUIscUVBQVM7SUFDVCxtRUFBUTtJQUNSLHVFQUFVO0lBQ1YsNkVBQWE7SUFDYiw2REFBSztJQUNMLDZEQUFLO0lBQ0wsMkVBQVk7SUFDWiwrRkFBc0I7SUFDdEIscUVBQVM7SUFDVCw2RUFBYTtBQUNmLENBQUMsRUFYVyxvQkFBb0IsR0FBcEIsNEJBQW9CLEtBQXBCLDRCQUFvQixRQVcvQjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQzNMRCxnRkFBa0Q7QUFFbEQ7Ozs7O0dBS0c7QUFDSDtJQUE2Qyx3Q0FBaUI7SUFPNUQsOEJBQTRCLEtBQVEsRUFBRSxLQUFhLEVBQUUsR0FBbUIsRUFBRSxLQUF1QjtRQUE1QyxpQ0FBbUI7UUFBRSx3Q0FBdUI7UUFBakcsWUFDRSxrQkFBTSxLQUFLLEVBQUUsS0FBSyxFQUFFLEdBQUcsQ0FBQyxTQUV6QjtRQUgyQixXQUFLLEdBQUwsS0FBSyxDQUFHO1FBTjFCLGtCQUFZLEdBQVUsUUFBUSxDQUFDO1FBUXZDLEtBQUksQ0FBQyxZQUFZLEdBQUcsS0FBSyxDQUFDOztJQUM1QixDQUFDO0lBUEQsc0JBQVcsdUNBQUs7YUFBaEI7WUFDRSxPQUFPLElBQUksQ0FBQyxZQUFZLENBQUM7UUFDM0IsQ0FBQzs7O09BQUE7SUFPTSwwQ0FBVyxHQUFsQixVQUFtQixLQUFZO1FBQzdCLElBQUksQ0FBQyxZQUFZLEdBQUcsS0FBSyxDQUFDO0lBQzVCLENBQUM7SUFDSCwyQkFBQztBQUFELENBQUMsQ0FmNEMscUJBQWMsR0FlMUQ7QUFmWSxvREFBb0I7Ozs7Ozs7Ozs7Ozs7OztBQ29CakMsSUFBTSxjQUFjLEdBQUc7SUFDckI7UUFDRSxJQUFJLEVBQUUseUNBQXlDO1FBQy9DLElBQUksRUFBRSx1Q0FBdUM7UUFDN0MsSUFBSSxFQUFFLHNDQUFzQztRQUM1QyxPQUFPLEVBQ0w7OzJIQUVxSDtLQUN4SDtJQUNEO1FBQ0UsSUFBSSxFQUFFLHlDQUF5QztRQUMvQyxJQUFJLEVBQUUsMkNBQTJDO1FBQ2pELElBQUksRUFBRSxrQkFBa0I7UUFDeEIsT0FBTyxFQUFFLHlEQUF5RDtLQUNuRTtJQUNEO1FBQ0UsSUFBSSxFQUFFLCtEQUErRDtRQUNyRSxJQUFJLEVBQUUseUVBQXlFO1FBQy9FLElBQUksRUFBRSxnREFBZ0Q7UUFDdEQsT0FBTyxFQUNMOzs4R0FFd0c7S0FDM0c7SUFDRDtRQUNFLElBQUksRUFBRSxzREFBc0Q7UUFDNUQsSUFBSSxFQUFFLGlFQUFpRTtRQUN2RSxJQUFJLEVBQUUsdUNBQXVDO1FBQzdDLE9BQU8sRUFBRSw0RkFBNEY7S0FDdEc7Q0FDRixDQUFDO0FBRUYsSUFBTSxXQUFXLEdBQXFCO0lBQ3BDLE9BQU8sRUFBRSxDQUFDLDZCQUE2QixDQUFDO0lBQ3hDLFNBQVMsRUFBRSxFQUFFO0lBQ2IsYUFBYSxFQUFFLEVBQUU7SUFDakIsZUFBZSxFQUFFLEVBQUU7SUFDbkIsUUFBUSxFQUFFLENBQUMsY0FBYyxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBQzdCLGNBQWMsRUFBRSxJQUFJO0lBQ3BCLElBQUksRUFBRSxhQUFhO0lBQ25CLFlBQVksRUFBRSxXQUFXO0lBQ3pCLElBQUksRUFBRSxFQUFFLFVBQVUsRUFBRSxFQUFFLEVBQUUsSUFBSSxFQUFFLDBEQUEwRCxFQUFFLE9BQU8sRUFBRSxFQUFFLEVBQUU7SUFDdkcsT0FBTyxFQUFFLGlDQUFpQztDQUMzQyxDQUFDO0FBRUYsSUFBTSxNQUFNLEdBQXFCO0lBQy9CLE9BQU8sRUFBRSxDQUFDLGVBQWUsRUFBRSxlQUFlLEVBQUUsYUFBYSxDQUFDO0lBQzFELFNBQVMsRUFBRTtRQUNUO1lBQ0UsWUFBWSxFQUNWOzs2Q0FFcUM7WUFDdkMsSUFBSSxFQUFFLDhDQUE4QztTQUNyRDtLQUNGO0lBQ0QsYUFBYSxFQUFFLENBQUMsV0FBVyxFQUFFLE1BQU0sRUFBRSxLQUFLLENBQUM7SUFDM0MsZUFBZSxFQUNiOzs7OzRHQUl3RztJQUMxRyxRQUFRLEVBQUUsY0FBYztJQUN4QixjQUFjLEVBQUUsS0FBSztJQUNyQixJQUFJLEVBQUUsUUFBUTtJQUNkLFlBQVksRUFBRSxXQUFXO0lBQ3pCLElBQUksRUFBRTtRQUNKLFVBQVUsRUFBRSxZQUFZO1FBQ3hCLElBQUksRUFBRSw2Q0FBNkM7UUFDbkQsT0FBTyxFQUFFLEtBQUs7S0FDZjtJQUNELE9BQU8sRUFBRSw0RkFBNEY7Q0FDdEcsQ0FBQztBQUVGLElBQU0sUUFBUSxHQUFxQjtJQUNqQyxPQUFPLEVBQUUsQ0FBQyxpQkFBaUIsQ0FBQztJQUM1QixTQUFTLEVBQUUsRUFBRTtJQUNiLGFBQWEsRUFBRSxFQUFFO0lBQ2pCLGVBQWUsRUFBRSxFQUFFO0lBQ25CLFFBQVEsRUFBRSxDQUFDLGNBQWMsQ0FBQyxDQUFDLENBQUMsRUFBRSxjQUFjLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFDaEQsY0FBYyxFQUFFLElBQUk7SUFDcEIsSUFBSSxFQUFFLFdBQVc7SUFDakIsWUFBWSxFQUFFLFdBQVc7SUFDekIsSUFBSSxFQUFFLEVBQUUsVUFBVSxFQUFFLEVBQUUsRUFBRSxJQUFJLEVBQUUseUNBQXlDLEVBQUUsT0FBTyxFQUFFLEVBQUUsRUFBRTtJQUN0RixPQUFPLEVBQUUsd0RBQXdEO0NBQ2xFLENBQUM7QUFFVyxlQUFPLEdBQXdDO0lBQzFELFdBQVc7SUFDWCxNQUFNO0lBQ04sV0FBVyxFQUFFLFFBQVE7SUFDckIsUUFBUTtDQUNULENBQUM7QUFVVyxlQUFPLEdBQWE7SUFDL0I7UUFDRSxPQUFPLEVBQUUsQ0FBQyxlQUFlLEVBQUUsZUFBZSxFQUFFLGFBQWEsQ0FBQztRQUMxRCxXQUFXLEVBQ1Q7OzJIQUVxSDtRQUN2SCxJQUFJLEVBQUUseUNBQXlDO1FBQy9DLElBQUksRUFBRSx1Q0FBdUM7UUFDN0MsS0FBSyxFQUFFLDZDQUE2QztLQUNyRDtJQUNEO1FBQ0UsT0FBTyxFQUFFLENBQUMsbUJBQW1CLEVBQUUsbUJBQW1CLENBQUM7UUFDbkQsV0FBVyxFQUFFO21DQUNrQjtRQUMvQixJQUFJLEVBQUUsK0RBQStEO1FBQ3JFLElBQUksRUFBRSx5RUFBeUU7UUFDL0UsS0FBSyxFQUFFLG1EQUFtRDtLQUMzRDtDQUNGLENBQUM7QUFZVyxvQkFBWSxHQUFtQjtJQUMxQztRQUNFLE9BQU8sRUFBRSxDQUFDLGVBQWUsRUFBRSxlQUFlLEVBQUUsYUFBYSxDQUFDO1FBQzFELEtBQUssRUFBRTtZQUNMLFFBQVEsRUFBRSxFQUFFO1lBQ1osTUFBTSxFQUFFLEVBQUU7U0FDWDtRQUNELElBQUksRUFBRSxxQ0FBcUM7UUFDM0MsT0FBTyxFQUNMOztpQkFFVztLQUNkO0lBQ0Q7UUFDRSxPQUFPLEVBQUUsQ0FBQyw2QkFBNkIsQ0FBQztRQUN4QyxLQUFLLEVBQUU7WUFDTCxRQUFRLEVBQUUsRUFBRTtZQUNaLE1BQU0sRUFBRSxFQUFFO1NBQ1g7UUFDRCxJQUFJLEVBQUUsNENBQTRDO1FBQ2xELE9BQU8sRUFDTDs7MkNBRXFDO0tBQ3hDO0NBQ0YsQ0FBQztBQVNXLG1CQUFXLEdBQXlDO0lBQy9ELFVBQVUsRUFBRTtRQUNWLFdBQVcsRUFBRSx3RUFBd0U7UUFDckYsT0FBTyxFQUFFLElBQUk7UUFDYixRQUFRLEVBQUUsZ0NBQWdDO1FBQzFDLFlBQVksRUFBRSxLQUFLO0tBQ3BCO0lBQ0QsY0FBYyxFQUFFO1FBQ2QsV0FBVyxFQUNUO3FEQUMrQztRQUNqRCxPQUFPLEVBQUUsSUFBSTtRQUNiLFFBQVEsRUFBRSxnQ0FBZ0M7UUFDMUMsWUFBWSxFQUFFLEtBQUs7S0FDcEI7SUFDRCxrQkFBa0IsRUFBRTtRQUNsQixXQUFXLEVBQ1Q7aUVBQzJEO1FBQzdELE9BQU8sRUFBRSxJQUFJO1FBQ2IsUUFBUSxFQUFFLGNBQWM7UUFDeEIsWUFBWSxFQUFFLEtBQUs7S0FDcEI7SUFDRCxtQkFBbUIsRUFBRTtRQUNuQixXQUFXLEVBQ1Q7OzJDQUVxQztRQUN2QyxPQUFPLEVBQUUsS0FBSztRQUNkLFFBQVEsRUFBRSxjQUFjO1FBQ3hCLFlBQVksRUFBRSxJQUFJO0tBQ25CO0lBQ0QsbUJBQW1CLEVBQUU7UUFDbkIsV0FBVyxFQUFFO21CQUNFO1FBQ2YsT0FBTyxFQUFFLEtBQUs7UUFDZCxRQUFRLEVBQUUsY0FBYztRQUN4QixZQUFZLEVBQUUsSUFBSTtLQUNuQjtDQUNGLENBQUM7Ozs7Ozs7Ozs7Ozs7OztBQzlPRixnRkFBNkU7QUFFN0U7SUFDRTtJQUNFLGdEQUFnRDtJQUN2QyxJQUE0QixFQUM1QixVQUE4QixFQUM5QixjQUE2QixFQUM3QixXQUFxRjtRQURyRixvREFBNkI7UUFDN0IsOENBQXFGO1FBSHJGLFNBQUksR0FBSixJQUFJLENBQXdCO1FBQzVCLGVBQVUsR0FBVixVQUFVLENBQW9CO1FBQzlCLG1CQUFjLEdBQWQsY0FBYyxDQUFlO1FBQzdCLGdCQUFXLEdBQVgsV0FBVyxDQUEwRTtJQUM3RixDQUFDO0lBRUcsZ0NBQU0sR0FBYjtRQUNFLE9BQU8sSUFBSSxDQUFDLFVBQVUsS0FBSyx3QkFBaUIsQ0FBQyxJQUFJLENBQUM7SUFDcEQsQ0FBQztJQUNILHNCQUFDO0FBQUQsQ0FBQztBQVpZLDBDQUFlOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNGNUIsOEZBQWtDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNBbEMsNEVBQTRCO0FBQzVCLHNGQUFpQztBQUNqQyxnRkFBOEI7QUFDOUIsNEVBQTRCO0FBQzVCLDBFQUEyQjtBQUMzQiw0RkFBb0M7QUFDcEMsOEVBQTZCO0FBQzdCLHdFQUEwQjtBQUUxQixrR0FBdUM7QUFDdkMsd0VBQTBCO0FBRTFCLDBFQUF3Qjs7Ozs7Ozs7Ozs7Ozs7O0FDVHhCOzs7O0dBSUc7QUFDSDtJQW9CRSxxQkFBNEIsTUFBNEM7UUFBNUMsa0NBQWtCLFdBQVcsQ0FBQyxjQUFjO1FBQTVDLFdBQU0sR0FBTixNQUFNLENBQXNDO1FBTHhFOztXQUVHO1FBQ08sYUFBUSxHQUFrQixJQUFJLEdBQUcsRUFBWSxDQUFDO0lBRW1CLENBQUM7SUFFNUU7O09BRUc7SUFDSSxpQ0FBVyxHQUFsQixVQUFtQixHQUFNO1FBQ3ZCLElBQUksQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsRUFBRTtZQUMzQixJQUFJLENBQUMsZ0JBQWdCLENBQUMsR0FBRyxDQUFDLENBQUM7U0FDNUI7UUFFRCxPQUFPLElBQUksQ0FBQyxRQUFRLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBVSxDQUFDO0lBQ3pDLENBQUM7SUFFRDs7Ozs7O09BTUc7SUFDSSw4QkFBUSxHQUFmLFVBQWdCLEdBQU0sRUFBRSxLQUFhLEVBQUUsV0FBMkI7UUFBM0IsZ0RBQTJCO1FBQ2hFLElBQUksQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsRUFBRTtZQUMzQixJQUFJLENBQUMsZ0JBQWdCLENBQUMsR0FBRyxFQUFFLEtBQUssRUFBRSxXQUFXLENBQUMsQ0FBQztTQUNoRDtJQUNILENBQUM7SUFFRDs7Ozs7T0FLRztJQUNPLHNDQUFnQixHQUExQixVQUEyQixHQUFNLEVBQUUsS0FBYSxFQUFFLFdBQXFCO1FBQ3JFLElBQUksQ0FBQyxRQUFRLENBQUMsR0FBRyxDQUFDLEdBQUcsRUFBRSxLQUFLLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLElBQUksR0FBRyxJQUFJLENBQUMsTUFBTSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUM7UUFDN0YsSUFBSSxLQUFLLElBQUksV0FBVyxJQUFJLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxRQUFRLENBQUMsS0FBSyxDQUFDLEVBQUU7WUFDeEQsSUFBSSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUM7U0FDekI7SUFDSCxDQUFDO0lBeERhLDBCQUFjLEdBQXFCO1FBQy9DLEtBQUs7UUFDTCxPQUFPO1FBQ1AsTUFBTTtRQUNOLFFBQVE7UUFDUixRQUFRO1FBQ1IsTUFBTTtRQUNOLE1BQU07UUFDTixRQUFRO1FBQ1IsUUFBUTtRQUNSLE9BQU87UUFDUCxPQUFPO0tBQ1IsQ0FBQztJQTZDSixrQkFBQztDQUFBO0FBMURZLGtDQUFXOzs7Ozs7Ozs7Ozs7Ozs7QUNSeEIsSUFBTSw0QkFBNEIsR0FBRyxVQUFDLEtBQWUsSUFBZ0MsUUFBQztJQUNwRixHQUFHLEVBQUUsS0FBSyxDQUFDLE1BQU0sR0FBRyxDQUFDO0lBQ3JCLEdBQUcsRUFBRSxLQUFLLENBQUMsTUFBTSxHQUFHLENBQUM7SUFDckIsRUFBRSxFQUFFLENBQUM7SUFDTCxJQUFJLEVBQUUsQ0FBQztJQUNQLENBQUMsRUFBRSxDQUFDO0lBQ0osQ0FBQyxFQUFFLENBQUM7Q0FDTCxDQUFDLEVBUG1GLENBT25GLENBQUM7QUFFSCx1Q0FBdUM7QUFDMUIsZ0NBQXdCLEdBQUcsVUFBQyxLQUFlLEVBQUUsaUJBQTBCO0lBQ2xGLElBQUksQ0FBQyxpQkFBaUIsRUFBRTtRQUN0QixPQUFPLDRCQUE0QixDQUFDLEtBQUssQ0FBQyxDQUFDO0tBQzVDO1NBQU07UUFDTCxJQUFNLFFBQU0sR0FBOEIsRUFBRSxDQUFDO1FBQzdDLEtBQUssQ0FBQyxNQUFNLENBQUMsY0FBSSxJQUFJLFdBQUksQ0FBQyxNQUFNLElBQUksQ0FBQyxFQUFoQixDQUFnQixDQUFDLENBQUMsR0FBRyxDQUFDLGdCQUFNO1lBQy9DLDhEQUE4RDtZQUM5RCxRQUFNLENBQUMsTUFBTSxDQUFDLElBQUksRUFBRSxDQUFDLEdBQUcsS0FBSyxDQUFDLE9BQU8sQ0FBQyxNQUFNLENBQUMsQ0FBQztRQUNoRCxDQUFDLENBQUMsQ0FBQztRQUVILE9BQU8sUUFBTSxDQUFDO0tBQ2Y7QUFDSCxDQUFDLENBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUN0QkYsaUJBZ1VBOztBQWhVQSwrRUFBMkI7QUFFM0IsZ0ZBVzBCO0FBQzFCLHNGQU80QjtBQUVmLDRCQUFvQixHQUFHLFVBQU8sR0FBYSxFQUFFLE9BQWU7O1FBQ3ZFLFFBQVEsR0FBRyxFQUFFO1lBQ1gsS0FBSyxlQUFRLENBQUMsT0FBTyxDQUFDLENBQUM7WUFDdkIsS0FBSyxlQUFRLENBQUMsYUFBYSxDQUFDO2dCQUMxQixzQkFBTywrQkFBdUIsQ0FBQyxPQUFPLENBQUMsRUFBQztZQUMxQyxLQUFLLGVBQVEsQ0FBQyxjQUFjLENBQUM7Z0JBQzNCLHNCQUFPLHFDQUE2QixDQUFDLE9BQU8sQ0FBQyxFQUFDO1lBQ2hELEtBQUssZUFBUSxDQUFDLE1BQU07Z0JBQ2xCLHNCQUFPLHVCQUFlLENBQUMsT0FBTyxDQUFDLEVBQUM7WUFDbEMsS0FBSyxlQUFRLENBQUMsR0FBRztnQkFDZixzQkFBTyxpQ0FBeUIsQ0FBQyxPQUFPLENBQUMsRUFBQztZQUM1QyxLQUFLLGVBQVEsQ0FBQyxXQUFXLENBQUM7WUFDMUIsS0FBSyxlQUFRLENBQUMsVUFBVTtnQkFDdEIsc0JBQU8sMkJBQW1CLENBQUMsT0FBTyxDQUFDLEVBQUM7WUFDdEM7Z0JBQ0Usc0JBQU8sT0FBTyxDQUFDLE1BQU0sQ0FBQyxFQUFFLEtBQUssRUFBRSw4Q0FBNEMsR0FBSyxFQUFFLENBQUMsRUFBQztTQUN2Rjs7O0tBQ0YsQ0FBQztBQUVXLG9DQUE0QixHQUFHLFVBQU8sR0FBYSxFQUFFLElBQVU7Ozs7O2dCQUNsRSxRQUFHOzt5QkFDSixlQUFRLENBQUMsR0FBRyxDQUFDLENBQWIsd0JBQVk7eUJBRVosZUFBUSxDQUFDLFdBQVcsQ0FBQyxDQUFyQix3QkFBb0I7OztvQkFEdkIsc0JBQU8sNEJBQW9CLENBQUMsSUFBSSxDQUFDLEVBQUM7OztnQkFFVCxrQ0FBcUI7Z0JBQUMscUJBQU0sdUJBQWMsQ0FBQyxJQUFJLENBQUM7b0JBQXpFLHVCQUFTLGlCQUFjLEdBQUUsa0JBQXNCLFNBQTBCLEVBQUMsT0FBRztvQkFFN0Usc0JBQU8sT0FBTyxDQUFDLE1BQU0sQ0FBQyxFQUFFLEtBQUssRUFBRSw4Q0FBNEMsR0FBRyxXQUFRLEVBQUUsQ0FBQyxFQUFDOzs7S0FFL0YsQ0FBQztBQUVXLHVCQUFlLEdBQUcsVUFBTyxPQUFlOzs7O29CQUM5QixxQkFBTSx5QkFBeUIsQ0FBSSxPQUFPLG9DQUFpQyxDQUFDOztnQkFBM0YsWUFBWSxHQUFHLFNBQTRFO2dCQUUzRixLQUFLLEdBQUcsSUFBSSxLQUFLLEVBQWUsQ0FBQztnQkFDakMsVUFBVSxHQUFHLE1BQU0sQ0FBQyxJQUFJLENBQUMsWUFBWSxDQUFDLENBQUM7Z0JBRTdDLFlBQVksQ0FBQyxVQUFVLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxVQUFVLENBQUMsT0FBTyxDQUFDLFVBQUMsS0FBSyxFQUFFLEtBQUs7b0JBQzFELEtBQUssQ0FBQyxJQUFJLENBQUM7d0JBQ1QsZ0JBQWdCLEVBQUUsVUFBVSxDQUFDLE1BQU0sQ0FDakMsVUFBQyxJQUFJLEVBQUUsUUFBUTs7NEJBQUsscUJBQU0sSUFBSSxlQUFHLFFBQVEsSUFBRyxZQUFZLENBQUMsUUFBUSxDQUFDLENBQUMsVUFBVSxDQUFDLEtBQUssQ0FBQyxPQUFHO3dCQUFuRSxDQUFtRSxFQUN2RixFQUFFLENBQ0g7d0JBQ0QsTUFBTSxFQUFFLEtBQUs7cUJBQ2QsQ0FBQyxDQUFDO2dCQUNMLENBQUMsQ0FBQyxDQUFDO2dCQUVILHNCQUFPLEVBQUUsS0FBSyxTQUFFLEVBQUM7OztLQUNsQixDQUFDO0FBRUYsSUFBTSx5QkFBeUIsR0FBRyxVQUFPLElBQVk7Ozs7b0JBQ3BDLHFCQUFNLHNCQUFhLENBQUMsSUFBSSxDQUFDOztnQkFBbEMsS0FBSyxHQUFHLENBQUMsU0FBeUIsQ0FBcUM7Z0JBQ3ZFLE1BQU0sR0FBbUQsRUFBRSxDQUFDOztvQkFDbEUsS0FBa0Isb0JBQU0sQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLDZDQUFFO3dCQUEzQixHQUFHO3dCQUNOLFNBQVMsR0FBRyxLQUFLLENBQUMsR0FBRyxDQUFDLENBQUM7d0JBQzdCLElBQUksQ0FBQyxTQUFTLENBQUMsWUFBWSxJQUFJLENBQUMsU0FBUyxDQUFDLFVBQVUsRUFBRTs0QkFDcEQsTUFBTSxJQUFJLEtBQUssQ0FBQyxzRkFBc0YsQ0FBQyxDQUFDO3lCQUN6Rzt3QkFDSyxNQUFNLEdBQWdDOzRCQUMxQyxZQUFZLEVBQUUsRUFBRTs0QkFDaEIsVUFBVSxFQUFFLFNBQVMsQ0FBQyxVQUFVO3lCQUNqQyxDQUFDO3dCQUVNLFlBQVksR0FBSyxLQUFLLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxhQUFqQyxDQUFrQzs7NEJBRXRELHdJQUF3STs0QkFDeEksS0FBNEIsb0JBQU0sQ0FBQyxJQUFJLENBQUMsWUFBWSxDQUFDLDZDQUFFO2dDQUE1QyxhQUFhO2dDQUNoQixHQUFHLEdBQUcsWUFBWSxDQUFDLGFBQWEsQ0FBQyxDQUFDO2dDQUN4QyxJQUFJLE9BQU8sR0FBRyxLQUFLLFFBQVEsRUFBRTtvQ0FDM0IsTUFBTSxDQUFDLFlBQVksQ0FBQyxhQUFhLENBQUMsR0FBRyxHQUFHLENBQUM7aUNBQzFDO3FDQUFNLElBQUksR0FBRyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsS0FBSyxHQUFHLEVBQUU7b0NBQ2hDLE1BQU0sQ0FBQyxZQUFZLENBQUMsYUFBYSxDQUFDLEdBQUcsTUFBTSxDQUFDLFFBQVEsQ0FBQyxPQUFLLEdBQUcsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFHLEVBQUUsRUFBRSxDQUFDLENBQUM7aUNBQy9FO3FDQUFNO29DQUNMLE1BQU0sQ0FBQyxZQUFZLENBQUMsYUFBYSxDQUFDLEdBQUcsTUFBTSxDQUFDLFFBQVEsQ0FBQyxHQUFHLEVBQUUsRUFBRSxDQUFDLENBQUM7aUNBQy9EOzZCQUNGOzs7Ozs7Ozs7d0JBRUQsTUFBTSxDQUFDLEdBQUcsQ0FBQyxHQUFHLE1BQU0sQ0FBQztxQkFDdEI7Ozs7Ozs7OztnQkFFRCxzQkFBTyxNQUFNLEVBQUM7OztLQUNmLENBQUM7QUFFVyxpQ0FBeUIsR0FBRyxVQUFPLElBQVk7Ozs7b0JBQzNCLHFCQUFNLHFCQUFZLENBQUMsSUFBSSxDQUFDOztnQkFBakQsY0FBYyxHQUFXLFNBQXdCO2dCQUVqRCxXQUFXLEdBQWUsRUFBRSxDQUFDO2dCQUM3QixJQUFJLEdBQUcsY0FBYyxDQUFDLENBQUMsQ0FBQyxjQUFjLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUM7Z0JBQzlELElBQUksQ0FBQyxPQUFPLENBQUMsVUFBQyxLQUFLLEVBQUUsS0FBSyxFQUFFLEtBQUs7b0JBQy9CLElBQU0sS0FBSyxHQUFHLEtBQUssQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLENBQUM7b0JBQy9CLElBQUksS0FBSyxDQUFDLE1BQU0sSUFBSSxDQUFDLEVBQUU7d0JBQ3JCLElBQU0sRUFBRSxHQUFHLFVBQVUsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxFQUFFLENBQUMsQ0FBQzt3QkFDdkMsSUFBTSxFQUFFLEdBQUcsVUFBVSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLEVBQUUsQ0FBQyxDQUFDO3dCQUN2QyxJQUFNLEVBQUUsR0FBRyxRQUFRLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksRUFBRSxFQUFFLEVBQUUsQ0FBQyxDQUFDO3dCQUN6QyxXQUFXLENBQUMsRUFBRSxDQUFDLEdBQUcsQ0FBQyxFQUFFLEVBQUUsRUFBRSxDQUFDLENBQUM7cUJBQzVCO3lCQUFNLElBQUksS0FBSyxDQUFDLGFBQWEsQ0FBQyxFQUFFLENBQUMsS0FBSyxDQUFDLEVBQUU7d0JBQ3hDLE1BQU0sSUFBSSxLQUFLLENBQUMsMkNBQXlDLEtBQUssdUNBQW9DLENBQUMsQ0FBQztxQkFDckc7Z0JBQ0gsQ0FBQyxDQUFDLENBQUM7Z0JBRUgsc0JBQU8sV0FBVyxFQUFDOzs7S0FDcEIsQ0FBQztBQUVXLCtCQUF1QixHQUFHLFVBQU8sT0FBZTs7OztvQkFDakMscUJBQU0scUJBQVksQ0FBSSxPQUFPLHFCQUFrQixDQUFDOztnQkFBcEUsU0FBUyxHQUFXLFNBQWdEO2dCQUNwRSxNQUFNLEdBQWUsRUFBRSxDQUFDO2dCQUM5QixTQUFTLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxDQUFDLE9BQU8sQ0FBQyxlQUFLO29CQUNqQyxJQUFJLEtBQUssQ0FBQyxNQUFNLEdBQUcsQ0FBQyxFQUFFO3dCQUNwQixJQUFNLEtBQUssR0FBRyxLQUFLLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxDQUFDO3dCQUMvQixJQUFNLFdBQVcsR0FBRyxDQUFDLFVBQVUsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxVQUFVLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQzt3QkFDakUsTUFBTSxDQUFDLElBQUksQ0FBQyxXQUFXLENBQUMsQ0FBQztxQkFDMUI7Z0JBQ0gsQ0FBQyxDQUFDLENBQUM7Z0JBRUgsc0JBQU8sTUFBTSxFQUFDOzs7S0FDZixDQUFDO0FBRVcsNkNBQXFDLEdBQUcsVUFBTyxZQUFvQjs7OztvQkFDcEQscUJBQU0scUJBQVksQ0FBQyxZQUFZLENBQUM7O2dCQUFwRCxTQUFTLEdBQVcsU0FBZ0M7Z0JBQ3BELE1BQU0sR0FBRyxJQUFJLEtBQUssRUFBWSxDQUFDOztvQkFDckMsS0FBa0IsdUJBQVMsQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLDZDQUFFO3dCQUE5QixHQUFHO3dCQUNaLElBQUksR0FBRyxDQUFDLE1BQU0sSUFBSSxDQUFDLEVBQUU7NEJBQ25CLE1BQU0sQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFHLENBQUMsVUFBVSxDQUFDLENBQUMsQ0FBQzt5QkFDN0M7cUJBQ0Y7Ozs7Ozs7OztnQkFFRCxzQkFBTyxNQUFNLEVBQUM7OztLQUNmLENBQUM7QUFFVyxxQ0FBNkIsR0FBRyxVQUFPLE9BQWU7O1FBQ2pFLHNCQUFPLDZDQUFxQyxDQUFJLE9BQU8scUJBQWtCLENBQUMsRUFBQzs7S0FDNUUsQ0FBQztBQUVXLHNCQUFjLEdBQUcsVUFBTyxJQUFZOzs7O29CQUNqQyxxQkFBTSxzQkFBYSxDQUFDLElBQUksQ0FBQzs7Z0JBQWpDLElBQUksR0FBRyxDQUFDLFNBQXlCLENBQXFCO2dCQUM1RCxJQUFJLENBQUMsSUFBSSxDQUFDLEtBQUssSUFBSSxDQUFDLElBQUksQ0FBQyxLQUFLLEVBQUU7b0JBQzlCLE1BQU0sSUFBSSxLQUFLLENBQUMsMEVBQTBFLENBQUMsQ0FBQztpQkFDN0Y7Z0JBRUQsc0JBQU8sSUFBSSxFQUFDOzs7S0FDYixDQUFDO0FBRVcsaUNBQXlCLEdBQUcsVUFBTyxHQUFXOzs7UUFDekQsSUFBSSxHQUFHLENBQUMsTUFBTSxLQUFLLENBQUMsRUFBRTtZQUNwQixzQkFBTyxPQUFPLENBQUMsTUFBTSxDQUFDLGFBQWEsQ0FBQyxFQUFDO1NBQ3RDO1FBQ0ssSUFBSSxHQUFNLEdBQUcsaUJBQWMsQ0FBQztRQUVsQyxzQkFBTyw0QkFBb0IsQ0FBQyxJQUFJLENBQUMsRUFBQzs7S0FDbkMsQ0FBQztBQUVXLDRCQUFvQixHQUFHLFVBQU8sSUFBMEIsRUFBRSxNQUEyQztJQUEzQyxvQ0FBMkM7OztvQkFDL0cscUJBQU0sR0FBRyxDQUFDLFFBQVEsQ0FBQyxJQUFJLEVBQUUsTUFBTSxDQUFDO29CQUFqQyx1QkFBQyxTQUFnQyxDQUFrQjs7O0NBQUEsQ0FBQztBQUV6QywyQkFBbUIsR0FBRyxVQUFPLEdBQVc7Ozs7OztnQkFDbkQsSUFBSSxHQUFHLENBQUMsTUFBTSxLQUFLLENBQUMsRUFBRTtvQkFDcEIsc0JBQU8sT0FBTyxDQUFDLE1BQU0sQ0FBQyxhQUFhLENBQUMsRUFBQztpQkFDdEM7Z0JBQ0ssZUFBZSxHQUFHLENBQUMscUJBQXFCLEVBQUUscUJBQXFCLENBQUMsQ0FBQztnQkFDaEQscUJBQU0sT0FBTyxDQUFDLEdBQUcsQ0FBQyxlQUFlLENBQUMsR0FBRyxDQUFDLFVBQU0sSUFBSTt3QkFBSSwyQ0FBWSxDQUFJLEdBQUcsU0FBSSxJQUFNLENBQUM7NkJBQUEsQ0FBQyxDQUFDOztnQkFBckcsY0FBYyxHQUFHLFNBQW9GO2dCQUMzRixxQkFBTSxlQUFRLENBQUMsU0FBUyxDQUFJLEdBQUcsaUJBQWMsQ0FBQzs7Z0JBQXhELE9BQU8sR0FBRyxTQUE4QztnQkFFOUQsc0JBQU87d0JBQ0wsY0FBYyxFQUFFLDZCQUFxQixDQUFDLGNBQWMsQ0FBQyxDQUFDLENBQUMsRUFBRSwrQkFBc0IsQ0FBQyxjQUFjLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQzt3QkFDbkcsT0FBTzt3QkFDUCxtQkFBbUIsRUFBRSxFQUFFO3FCQUN4QixFQUFDOzs7S0FDSCxDQUFDO0FBRUY7Ozs7Ozs7Ozs7R0FVRztBQUNVLDZCQUFxQixHQUFHLFVBQUMsSUFBWSxFQUFFLGNBQXNDO0lBQXRDLG9EQUFzQztJQUN4RixJQUFNLFNBQVMsR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsQ0FBQztJQUNqRCxJQUFNLGVBQWUsR0FBRyx1QkFBdUIsQ0FBQyxTQUFTLENBQUMsQ0FBQztJQUMzRCxJQUFNLGFBQWEsR0FBRyxpQ0FBd0IsQ0FBQyxTQUFTLEVBQUUsZUFBZSxDQUFDLENBQUM7SUFDM0UsSUFBTSxjQUFjLEdBQUcsSUFBSSx3QkFBaUIsRUFBRSxDQUFDO0lBQy9DLElBQUk7U0FDRCxLQUFLLENBQUMsSUFBSSxDQUFDO1NBQ1gsS0FBSyxDQUFDLGVBQWUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7U0FDOUIsTUFBTSxDQUFDLGFBQUcsSUFBSSxVQUFHLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxDQUFDLE1BQU0sSUFBSSxDQUFDLEVBQTFCLENBQTBCLENBQUM7U0FDekMsR0FBRyxDQUFDLGFBQUc7UUFDTixJQUFNLEtBQUssR0FBRyxHQUFHLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxDQUFDO1FBQzdCLElBQU0sS0FBSyxHQUFHLDBCQUEwQixDQUFDLEtBQUssRUFBRSxhQUFhLENBQUMsQ0FBQztRQUMvRCxJQUFJLGNBQWMsQ0FBQyxNQUFNLElBQUksQ0FBQyxFQUFFO1lBQzlCLElBQU0sYUFBYSxHQUFHLGNBQWMsQ0FBQyxTQUFTLENBQUMsaUJBQU8sSUFBSSxjQUFPLENBQUMsY0FBYyxLQUFLLEtBQUssQ0FBQyxDQUFDLEVBQWxDLENBQWtDLENBQUMsQ0FBQztZQUM5RixJQUFNLGFBQWEsR0FBRyxjQUFjLENBQUMsU0FBUyxDQUFDLGlCQUFPLElBQUksY0FBTyxDQUFDLGNBQWMsS0FBSyxLQUFLLENBQUMsQ0FBQyxFQUFsQyxDQUFrQyxDQUFDLENBQUM7WUFDOUYsY0FBYyxDQUFDLGdCQUFnQixjQUMxQixLQUFLLElBQ1IsR0FBRyxFQUFFLGNBQWMsQ0FBQyxhQUFhLENBQUMsQ0FBQyxVQUFVLEVBQzdDLEdBQUcsRUFBRSxjQUFjLENBQUMsYUFBYSxDQUFDLENBQUMsVUFBVSxFQUM3QyxDQUFDLEVBQUUsY0FBYyxDQUFDLGFBQWEsQ0FBQyxDQUFDLFFBQVEsRUFDekMsQ0FBQyxFQUFFLGNBQWMsQ0FBQyxhQUFhLENBQUMsQ0FBQyxRQUFRLElBQ3pDLENBQUM7U0FDSjthQUFNO1lBQ0wsY0FBYyxDQUFDLGdCQUFnQixDQUFDLEtBQUssQ0FBQyxDQUFDO1NBQ3hDO0lBQ0gsQ0FBQyxDQUFDLENBQUM7SUFFTCxPQUFPLGNBQWMsQ0FBQztBQUN4QixDQUFDLENBQUM7QUFFRixJQUFNLHVCQUF1QixHQUFHLFVBQUMsU0FBbUI7SUFDbEQsUUFBQyxJQUFJLEVBQUUsTUFBTSxFQUFFLEdBQUcsRUFBRSxHQUFHLENBQUMsQ0FBQyxNQUFNLENBQUMsYUFBRyxJQUFJLGdCQUFTLENBQUMsUUFBUSxDQUFDLEdBQUcsQ0FBQyxFQUF2QixDQUF1QixDQUFDLENBQUMsTUFBTSxJQUFJLENBQUM7QUFBM0UsQ0FBMkUsQ0FBQztBQUU5RSxJQUFNLDBCQUEwQixHQUFHLFVBQUMsR0FBYSxFQUFFLGFBQXdDO0lBQ3pGLGFBQU0sQ0FBQyxPQUFPLENBQUMsYUFBYSxDQUFDLENBQUMsTUFBTSxDQUNsQyxVQUFDLElBQUksRUFBRSxVQUFVOztRQUNmLElBQU0sV0FBVyxHQUFHLFVBQVUsQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUNsQyxJQUFNLGdCQUFnQixHQUFHLFVBQVUsQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUV2QyxvQkFDSyxJQUFJLGVBQ04sV0FBVyxJQUFHLEtBQUssQ0FBQyxNQUFNLENBQUMsR0FBRyxDQUFDLGdCQUFnQixDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsZ0JBQWdCLENBQUMsQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLEdBQUcsQ0FBQyxnQkFBZ0IsQ0FBQyxDQUFDLE9BQzNHO0lBQ0osQ0FBQyxFQUNELEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsRUFBRSxDQUNqQjtBQVhELENBV0MsQ0FBQztBQUVTLCtDQUF1QyxHQUFHLFVBQ3JELGNBQWlDLEVBQ2pDLGNBQXNDO0lBQXRDLG9EQUFzQzs7SUFFdEMsSUFBTSxNQUFNLEdBQUcsSUFBSSx3QkFBaUIsRUFBRSxDQUFDOzRCQUM1QixLQUFLO1FBQ2QsSUFBTSxZQUFZLEdBQUcsY0FBYyxDQUFDLFNBQVMsQ0FBQyxpQkFBTyxJQUFJLGNBQU8sQ0FBQyxjQUFjLEtBQUssS0FBSyxDQUFDLENBQUMsRUFBbEMsQ0FBa0MsQ0FBQyxDQUFDO1FBQzdGLElBQU0sWUFBWSxHQUFHLGNBQWMsQ0FBQyxTQUFTLENBQUMsaUJBQU8sSUFBSSxjQUFPLENBQUMsY0FBYyxLQUFLLEtBQUssQ0FBQyxDQUFDLEVBQWxDLENBQWtDLENBQUMsQ0FBQztRQUU3RixNQUFNLENBQUMsZ0JBQWdCLENBQUM7WUFDdEIsR0FBRyxFQUFFLGNBQWMsQ0FBQyxZQUFZLENBQUMsQ0FBQyxVQUFVO1lBQzVDLEdBQUcsRUFBRSxjQUFjLENBQUMsWUFBWSxDQUFDLENBQUMsVUFBVTtZQUM1QyxFQUFFLEVBQUUsS0FBSyxDQUFDLEVBQUU7WUFDWixJQUFJLEVBQUUsS0FBSyxDQUFDLElBQUk7WUFDaEIsQ0FBQyxFQUFFLGNBQWMsQ0FBQyxZQUFZLENBQUMsQ0FBQyxRQUFRO1lBQ3hDLENBQUMsRUFBRSxjQUFjLENBQUMsWUFBWSxDQUFDLENBQUMsUUFBUTtTQUN6QyxDQUFDLENBQUM7OztRQVhMLEtBQW9CLDhDQUFjO1lBQTdCLElBQU0sS0FBSztvQkFBTCxLQUFLO1NBWWY7Ozs7Ozs7OztJQUVELE9BQU8sTUFBTSxDQUFDO0FBQ2hCLENBQUMsQ0FBQztBQUVGOzs7Ozs7Ozs7Ozs7R0FZRztBQUNVLGlDQUF5QixHQUFHLFVBQUMsSUFBWTtJQUNwRCxPQUFPLElBQUk7U0FDUixLQUFLLENBQUMsSUFBSSxDQUFDO1NBQ1gsS0FBSyxDQUFDLENBQUMsQ0FBQztTQUNSLE1BQU0sQ0FBQyxhQUFHLElBQUksVUFBRyxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsQ0FBQyxNQUFNLElBQUksQ0FBQyxFQUExQixDQUEwQixDQUFDO1NBQ3pDLEdBQUcsQ0FBQyxhQUFHO1FBQ04sSUFBTSxLQUFLLEdBQUcsR0FBRyxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsQ0FBQztRQUU3QixPQUFPO1lBQ0wsS0FBSyxFQUFFLFVBQVUsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUM7WUFDM0IsUUFBUSxFQUFFLEtBQUssQ0FBQyxDQUFDLENBQTJDO1NBQzdELENBQUM7SUFDSixDQUFDLENBQUMsQ0FBQztBQUNQLENBQUMsQ0FBQztBQUVGOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztFQW9CRTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQy9URixpQkFxQ0E7O0FBckNhLG9CQUFZLEdBQUcsVUFBTyxRQUFnQjs7OztvQkFDaEMscUJBQU0sS0FBSyxDQUFDLFFBQVEsQ0FBQzs7Z0JBQWhDLFFBQVEsR0FBRyxTQUFxQjtnQkFDdEMsSUFBSSxRQUFRLENBQUMsRUFBRSxFQUFFO29CQUNmLHNCQUFPLFFBQVEsQ0FBQyxJQUFJLEVBQUUsRUFBQztpQkFDeEI7cUJBQU07b0JBQ0wsTUFBTSxJQUFJLEtBQUssQ0FBQyxXQUFXLENBQUMsS0FBSyxFQUFFLFFBQVEsQ0FBQyxDQUFDLENBQUM7aUJBQy9DOzs7O0tBQ0YsQ0FBQztBQUVXLHFCQUFhLEdBQUcsVUFBTyxRQUFnQjs7OztvQkFDakMscUJBQU0sS0FBSyxDQUFDLFFBQVEsQ0FBQzs7Z0JBQWhDLFFBQVEsR0FBRyxTQUFxQjtnQkFDdEMsSUFBSSxRQUFRLENBQUMsRUFBRSxFQUFFO29CQUNmLHNCQUFPLFFBQVEsQ0FBQyxJQUFJLEVBQUUsRUFBQztpQkFDeEI7cUJBQU07b0JBQ0wsTUFBTSxJQUFJLEtBQUssQ0FBQyxXQUFXLENBQUMsTUFBTSxFQUFFLFFBQVEsQ0FBQyxDQUFDLENBQUM7aUJBQ2hEOzs7O0tBQ0YsQ0FBQztBQUVGLElBQU0sV0FBVyxHQUFHLFVBQUMsUUFBZ0IsRUFBRSxRQUFrQjtJQUN2RCxxQ0FBNEIsUUFBUSx3QkFBbUIsUUFBUSxDQUFDLE1BQU0sbUJBQWMsUUFBUSxDQUFDLFVBQVUsT0FBSTtBQUEzRyxDQUEyRyxDQUFDO0FBRTlHLCtEQUErRDtBQUNsRCxzQkFBYyxHQUFHLFVBQU8sU0FBZTs7O1FBQzVDLG1CQUFtQixHQUFHLElBQUksVUFBVSxFQUFFLENBQUM7UUFFN0Msc0JBQU8sSUFBSSxPQUFPLENBQVMsVUFBQyxPQUFPLEVBQUUsTUFBTTtnQkFDekMsbUJBQW1CLENBQUMsT0FBTyxHQUFHO29CQUM1QixtQkFBbUIsQ0FBQyxLQUFLLEVBQUUsQ0FBQztvQkFDNUIsTUFBTSxDQUFDLDZCQUE2QixDQUFDLENBQUM7Z0JBQ3hDLENBQUMsQ0FBQztnQkFFRixtQkFBbUIsQ0FBQyxNQUFNLEdBQUc7b0JBQzNCLE9BQU8sQ0FBQyxtQkFBbUIsQ0FBQyxNQUFnQixDQUFDLENBQUM7Z0JBQ2hELENBQUMsQ0FBQztnQkFDRixtQkFBbUIsQ0FBQyxVQUFVLENBQUMsU0FBUyxDQUFDLENBQUM7WUFDNUMsQ0FBQyxDQUFDLEVBQUM7O0tBQ0osQ0FBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNoQ1csd0JBQWdCLEdBQWdEO0lBQzNFLEtBQUssRUFBRSxLQUFLO0lBQ1osZUFBZSxFQUFFLElBQUk7SUFDckIsb0JBQW9CLEVBQUUsV0FBVztJQUNqQyxxQkFBcUIsRUFBRSxJQUFJO0lBQzNCLFdBQVcsRUFBRSxJQUFJO0lBQ2pCLGdCQUFnQixFQUFFLE9BQU87SUFDekIsZ0JBQWdCLEVBQUUsR0FBRztJQUNyQixVQUFVLEVBQUUsT0FBTztJQUNuQixTQUFTLEVBQUUsQ0FBQztJQUNaLFNBQVMsRUFBRSxVQUFVO0lBQ3JCLFlBQVksRUFBRSxFQUFFO0NBQ2pCLENBQUM7QUFFRjs7Ozs7R0FLRztBQUNVLG9DQUE0QixHQUFHLFVBQzFDLGtCQUEwQyxFQUMxQyxTQUE0QixFQUM1QixNQUF3RDtJQUF4RCxvQ0FBd0Q7SUFFeEQseUJBQWtCLENBQUMsaUJBQWlCLENBQUMsVUFBVSxlQUMxQyx3QkFBZ0IsRUFDaEIsTUFBTSxJQUNULFFBQVEsRUFBRSxLQUFLLENBQUMsT0FBTyxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLFNBQVMsQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLENBQUMsSUFDekU7QUFKRixDQUlFLENBQUM7QUFFTDs7Ozs7R0FLRztBQUNVLHFDQUE2QixHQUFHLFVBQUMsa0JBQTBDLEVBQUUsUUFBd0I7SUFDaEgseUJBQWtCLENBQUMsaUJBQWlCLENBQUMsWUFBWSxFQUFFO1FBQ2pELElBQUksRUFBRSxRQUFRLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQztLQUMxQixDQUFDO0FBRkYsQ0FFRSxDQUFDO0FBRUw7Ozs7Ozs7R0FPRztBQUNVLHFDQUE2QixHQUFHLFVBQzNDLGtCQUEwQyxFQUMxQyxPQUFvQyxFQUNwQyxXQUF1QixFQUN2QixLQUF5QjtJQUR6Qiw2Q0FBdUI7SUFDdkIseUNBQXlCO0lBRXpCLElBQU0sR0FBRyxHQUFHLGtCQUFrQixDQUFDLGlCQUFpQixDQUFDLFNBQVMsRUFBRTtRQUMxRCxLQUFLO1FBQ0wsV0FBVztRQUNYLElBQUksRUFBSyxPQUFPLENBQUMsS0FBSyxTQUFJLE9BQU8sQ0FBQyxHQUFLO0tBQ3hDLENBQUMsQ0FBQztJQUNILEdBQUcsQ0FBQyxhQUFhLENBQUMsRUFBRSxTQUFTLEVBQUUsSUFBSSxFQUFFLENBQUMsQ0FBQztJQUV2QyxPQUFPLEdBQUcsQ0FBQztBQUNiLENBQUMsQ0FBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ25FRixnRkFBa0U7QUFFbEU7Ozs7OztHQU1HO0FBQ1UsNkJBQXFCLEdBQUcsVUFDbkMsS0FBMkIsRUFDM0IsWUFBNkI7SUFBN0IsbURBQTZCO0lBQ0oscUJBQ3RCLDJCQUFtQixDQUFDLEtBQUssRUFBRSxZQUFZLENBQUMsSUFDM0MsSUFBSSxFQUFFLHdCQUFpQixDQUFDLFNBQVMsSUFDakM7QUFIeUIsQ0FHekIsQ0FBQztBQUVIOzs7Ozs7R0FNRztBQUNVLDJCQUFtQixHQUFHLFVBQ2pDLEtBQTJCLEVBQzNCLFlBQTZCO0lBQTdCLG1EQUE2QjtJQUVyQix5QkFBTSxFQUFFLHFCQUFNLEVBQUUsMkJBQVMsRUFBRSx5QkFBUSxFQUFFLGlCQUFJLEVBQUUsaUJBQUksQ0FBVztJQUNsRSxJQUFNLE9BQU8sR0FBRyxNQUFNLENBQUMsR0FBRyxDQUFDLGNBQUksSUFBSSxXQUFJLENBQUMsQ0FBQyxFQUFOLENBQU0sQ0FBQyxDQUFDO0lBQzNDLElBQU0sT0FBTyxHQUFHLE1BQU0sQ0FBQyxHQUFHLENBQUMsY0FBSSxJQUFJLFdBQUksQ0FBQyxDQUFDLEVBQU4sQ0FBTSxDQUFDLENBQUM7SUFDM0MsSUFBTSxPQUFPLEdBQUcsTUFBTSxDQUFDLEdBQUcsQ0FBQyxjQUFJLElBQUksUUFBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUE1QixDQUE0QixDQUFDLENBQUM7SUFDakUsSUFBTSxVQUFVLEdBQUcsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUM7SUFFckUsT0FBTztRQUNMLFNBQVMsRUFBRSxTQUFTLENBQUMsQ0FBQyxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsT0FBTztRQUMxQyxNQUFNLGFBQ0osS0FBSyxFQUFFLGlCQUFpQixDQUFDLFlBQVksRUFBRSxPQUFPLEVBQUUsS0FBSyxDQUFDLEVBQ3RELElBQUksRUFBRSxLQUFLLENBQUMsUUFBUSxJQUNqQixNQUFNLENBQ1Y7UUFDRCxJQUFJLEVBQUUsU0FBUztRQUNmLElBQUksRUFBSyxJQUFJLFNBQUksUUFBVTtRQUMzQixJQUFJLEVBQUUsWUFBWTtZQUNoQixDQUFDLFVBQ00sVUFBVSxFQUNWLFVBQVUsQ0FBQyxHQUFHO1lBQ2YsNkZBQTZGO1lBQzdGLGVBQUs7Z0JBQ0gsYUFBSSxLQUFLO3FCQUNOLE1BQU0sQ0FBQyxDQUFDLEVBQUUsS0FBSyxDQUFDLE1BQU0sR0FBRyxDQUFDLENBQUM7cUJBQzNCLEtBQUssQ0FBQyxJQUFJLENBQUM7cUJBQ1gsT0FBTyxFQUFFO3FCQUNULElBQUksQ0FBQyxJQUFJLENBQUMsTUFBRztZQUpoQixDQUlnQixDQUNuQixFQUVMLENBQUMsQ0FBQyxVQUFVO1FBQ2QsSUFBSSxFQUFFLHdCQUFpQixDQUFDLE9BQU87UUFDL0IsQ0FBQyxFQUFFLFlBQVksQ0FBQyxDQUFDLFVBQUssT0FBTyxFQUFLLE9BQU8sRUFBRSxDQUFDLENBQUMsT0FBTztRQUNwRCxDQUFDLEVBQUUsWUFBWSxDQUFDLENBQUMsVUFBSyxPQUFPLEVBQUssT0FBTyxFQUFFLENBQUMsQ0FBQyxPQUFPO1FBQ3BELENBQUMsRUFBRSxZQUFZLENBQUMsQ0FBQyxVQUFLLE9BQU8sRUFBSyxPQUFPLEVBQUUsQ0FBQyxDQUFDLE9BQU87S0FDckQsQ0FBQztBQUNKLENBQUMsQ0FBQztBQUVGLElBQU0saUJBQWlCLEdBQUcsVUFBQyxZQUFxQixFQUFFLE9BQWlCLEVBQUUsS0FBMkI7SUFDOUYsSUFBTSxXQUFXLEdBQUcsWUFBWSxDQUFDLENBQUMsQ0FBQyxPQUFPLENBQUMsTUFBTSxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsT0FBTyxDQUFDLE1BQU0sQ0FBQztJQUN2RSxJQUFNLE1BQU0sR0FBRyxJQUFJLEtBQUssQ0FBZSxXQUFXLENBQUMsQ0FBQztJQUVwRCxJQUFJLEtBQUssQ0FBQyxNQUFNLElBQUksT0FBTyxLQUFLLENBQUMsTUFBTSxDQUFDLEtBQUssS0FBSyxRQUFRLEVBQUU7UUFDMUQsT0FBTyxNQUFNLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDLENBQUM7S0FDeEM7U0FBTTtRQUNMLElBQU0sUUFBUSxHQUFHLE9BQU8sQ0FBQyxHQUFHLENBQUMsYUFBRyxJQUFJLFVBQUcsQ0FBQyxRQUFRLEVBQUUsRUFBZCxDQUFjLENBQUMsQ0FBQztRQUVwRCxPQUFPLFlBQVksQ0FBQyxDQUFDLFVBQUssUUFBUSxFQUFLLFFBQVEsRUFBRSxDQUFDLENBQUMsUUFBUSxDQUFDO0tBQzdEO0FBQ0gsQ0FBQyxDQUFDO0FBRVcsd0NBQWdDLEdBQUcsVUFBQyxLQUFzQztJQUNyRixJQUFNLE1BQU0sR0FBRyxJQUFJLFlBQVksQ0FBQyxLQUFLLENBQUMsTUFBTSxHQUFHLENBQUMsQ0FBQyxDQUFDO0lBQ2xELEtBQUssQ0FBQyxPQUFPLENBQUMsVUFBQyxJQUFJLEVBQUUsS0FBSztRQUN4QixNQUFNLENBQUMsS0FBSyxHQUFHLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxDQUFDLENBQUM7UUFDM0IsTUFBTSxDQUFDLEtBQUssR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLENBQUMsQ0FBQztJQUNqQyxDQUFDLENBQUMsQ0FBQztJQUVILE9BQU8sTUFBTSxDQUFDO0FBQ2hCLENBQUMsQ0FBQztBQUVGOzs7Ozs7R0FNRztBQUNVLDhCQUFzQixHQUFHLFVBQ3BDLEtBQTJCLEVBQzNCLFlBQTZCO0lBQTdCLG1EQUE2QjtJQUVyQix5QkFBTSxDQUFXO0lBQ3pCLElBQU0sTUFBTSxHQUFHLHdDQUFnQyxDQUFDLE1BQU0sQ0FBQyxDQUFDO0lBRXhELE9BQU87UUFDTCxNQUFNLGVBQ0QsS0FBSyxDQUFDLE1BQU0sSUFDZixPQUFPLEVBQUUsS0FBSyxDQUFDLFFBQVEsR0FBRyxDQUFDLEVBQzNCLE9BQU8sRUFBRSxLQUFLLENBQUMsUUFBUSxHQUN4QjtRQUNELElBQUksRUFBRSxTQUFTO1FBQ2YsSUFBSSxFQUFFLHdCQUFpQixDQUFDLFVBQVU7UUFDbEMsRUFBRSxFQUFFLFlBQVk7WUFDZCxDQUFDLENBQUMsSUFBSSxZQUFZLFVBQ1gsS0FBSyxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsRUFDbEIsS0FBSyxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUM7aUJBQ2xCLEtBQUssRUFBRTtpQkFDUCxPQUFPLEVBQUUsRUFDWjtZQUNKLENBQUMsQ0FBQyxNQUFNO0tBQ1gsQ0FBQztBQUNKLENBQUMsQ0FBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ3JIRixJQUFNLHFCQUFxQixHQUFHLFVBQVUsQ0FBQztBQUN6QyxJQUFNLHVCQUF1QixHQUFHLFlBQVksQ0FBQztBQUM3QyxJQUFNLGdCQUFnQixHQUFHLFdBQVcsQ0FBQztBQUNyQyxJQUFNLGtCQUFrQixHQUFHLGFBQWEsQ0FBQztBQUV6QyxJQUFNLHlCQUF5QixHQUFHLElBQUksQ0FBQztBQUN2QyxJQUFNLDBCQUEwQixHQUFHLFVBQVUsQ0FBQztBQUM5QyxJQUFNLCtCQUErQixHQUFHLGlCQUFpQixDQUFDO0FBRTFELElBQU0sdUJBQXVCLEdBQUcsQ0FBQyxxQkFBcUIsRUFBRSx1QkFBdUIsRUFBRSxnQkFBZ0IsRUFBRSxrQkFBa0IsQ0FBQyxDQUFDO0FBQ3ZILElBQU0seUJBQXlCLEdBQUc7SUFDaEMseUJBQXlCO0lBQ3pCLDBCQUEwQjtJQUMxQiwrQkFBK0I7Q0FDaEMsQ0FBQztBQWdCRjs7Ozs7Ozs7Ozs7Ozs7O0dBZUc7QUFDVSw4QkFBc0IsR0FBRyxVQUFDLElBQVk7SUFDakQsSUFBTSxlQUFlLEdBQVcsTUFBTSxDQUFDO0lBQ3ZDLElBQU0sT0FBTyxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLGVBQWUsQ0FBQyxDQUFDO0lBQzNELElBQU0sVUFBVSxHQUFHLGFBQWEsQ0FBQyxPQUFPLENBQUMsQ0FBQztJQUMxQyxJQUFNLFNBQVMsR0FFWCx3QkFBd0IsQ0FBQyxPQUFPLEVBQUUsVUFBVSxDQUFDLENBQUM7SUFFbEQsSUFBTSxtQkFBbUIsR0FBRyxVQUFVLENBQUMsQ0FBQyxDQUFDLFNBQVMsQ0FBQyx5QkFBeUIsQ0FBQyxDQUFDLENBQUMsQ0FBQyxTQUFTLENBQUMscUJBQXFCLENBQUMsQ0FBQztJQUNqSCxJQUFNLG1CQUFtQixHQUFHLFVBQVUsQ0FBQyxDQUFDLENBQUMsU0FBUyxDQUFDLDBCQUEwQixDQUFDLENBQUMsQ0FBQyxDQUFDLFNBQVMsQ0FBQyxnQkFBZ0IsQ0FBQyxDQUFDO0lBQzdHLElBQU0scUJBQXFCLEdBQUcsVUFBVSxDQUFDLENBQUMsQ0FBQyxTQUFTLENBQUMsK0JBQStCLENBQUMsQ0FBQyxDQUFDLENBQUMsU0FBUyxDQUFDLGtCQUFrQixDQUFDLENBQUM7SUFFdEgsT0FBTyxJQUFJO1NBQ1IsS0FBSyxDQUFDLElBQUksQ0FBQztTQUNYLEtBQUssQ0FBQyxDQUFDLENBQUM7U0FDUixNQUFNLENBQUMsVUFBQyxNQUF5QixFQUFFLElBQVk7UUFDOUMsSUFBTSxTQUFTLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxlQUFlLENBQUMsQ0FBQztRQUM5QyxJQUFJLFNBQVMsQ0FBQyxNQUFNLElBQUksdUJBQXVCLENBQUMsTUFBTSxFQUFFO1lBQ3RELE1BQU0sQ0FBQyxJQUFJLENBQUM7Z0JBQ1YsZ0JBQWdCLEVBQUUsVUFBVTtvQkFDMUIsQ0FBQyxDQUFFLFNBQVMsQ0FBQyxxQkFBcUIsQ0FBbUM7b0JBQ3JFLENBQUMsQ0FBRSxTQUFTLENBQUMsU0FBUyxDQUFDLHVCQUF1QixDQUFDLENBQW1DO2dCQUNwRixjQUFjLEVBQUUsUUFBUSxDQUFDLFNBQVMsQ0FBQyxtQkFBbUIsQ0FBQyxFQUFFLEVBQUUsQ0FBQztnQkFDNUQsVUFBVSxFQUFFLFNBQVMsQ0FBQyxxQkFBcUIsQ0FBa0M7Z0JBQzdFLFFBQVEsRUFBRSxRQUFRLENBQUMsU0FBUyxDQUFDLG1CQUFtQixDQUFDLEVBQUUsRUFBRSxDQUFDO2FBQ3ZELENBQUMsQ0FBQztTQUNKO1FBRUQsT0FBTyxNQUFNLENBQUM7SUFDaEIsQ0FBQyxFQUFFLElBQUksS0FBSyxFQUFtQixDQUFDLENBQUM7QUFDckMsQ0FBQyxDQUFDO0FBRUYsSUFBTSx3QkFBd0IsR0FBRyxVQUFDLE9BQWlCLEVBQUUsVUFBbUI7SUFDdEUsSUFBTSxTQUFTLEdBRVgsRUFBRSxDQUFDO0lBRVAsSUFBTSxlQUFlLEdBQUcsVUFBVSxDQUFDLENBQUMsQ0FBQyx5QkFBeUIsQ0FBQyxDQUFDLENBQUMsdUJBQXVCLENBQUM7SUFDekYsSUFBSSxPQUFPLENBQUMsTUFBTSxJQUFJLHVCQUF1QixDQUFDLE1BQU0sRUFBRTtRQUNwRCxlQUFlLENBQUMsR0FBRyxDQUFDLGdCQUFNO1lBQ3hCLElBQUksQ0FBQyxPQUFPLENBQUMsUUFBUSxDQUFDLE1BQU0sQ0FBQyxFQUFFO2dCQUM3QixNQUFNLElBQUksS0FBSyxDQUFDLG1CQUFpQixNQUFNLDhCQUEyQixDQUFDLENBQUM7YUFDckU7WUFDRCxTQUFTLENBQUMsTUFBTSxDQUFDLEdBQUcsT0FBTyxDQUFDLE9BQU8sQ0FBQyxNQUFNLENBQUMsQ0FBQztRQUM5QyxDQUFDLENBQUMsQ0FBQztLQUNKO0lBRUQsT0FBTyxTQUFTLENBQUM7QUFDbkIsQ0FBQyxDQUFDO0FBRUYsSUFBTSxhQUFhLEdBQUcsVUFBQyxPQUFpQjs7O1FBQ3RDLEtBQXFCLG9FQUF5QixnTEFBRTtZQUEzQyxJQUFNLE1BQU07WUFDZixJQUFJLENBQUMsT0FBTyxDQUFDLFFBQVEsQ0FBQyxNQUFNLENBQUMsRUFBRTtnQkFDN0IsT0FBTyxLQUFLLENBQUM7YUFDZDtTQUNGOzs7Ozs7Ozs7SUFFRCxPQUFPLElBQUksQ0FBQztBQUNkLENBQUMsQ0FBQzs7Ozs7Ozs7Ozs7Ozs7O0FDMUdGLHVDQUF1QztBQUMxQiw2QkFBcUIsR0FBRyxVQUFDLElBQVk7SUFDaEQsWUFBRyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxpQkFBaUIsRUFBRSxHQUFHLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUMsaUJBQWlCLEVBQUk7QUFBL0UsQ0FBK0UsQ0FBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDRmxGLGtGQUE4QjtBQUM5Qix3RkFBaUM7QUFDakMsZ0ZBQTZCO0FBQzdCLGtGQUE4QjtBQUM5Qiw4RUFBNEI7QUFDNUIsb0ZBQStCO0FBQy9CLHNGQUFnQztBQUNoQyxvRkFBK0I7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNQL0IsOEVBQStCO0FBYS9CO0lBQXNDLDJDQUFvQztJQUExRTs7SUFNQSxDQUFDO0lBTFEsd0NBQU0sR0FBYjtRQUNRLG1CQUFxQyxFQUFuQyxzQkFBUSxFQUFFLDBCQUF5QixDQUFDO1FBRTVDLE9BQU8sZUFBZSxDQUFDLFFBQVEsRUFBRSxVQUFVLENBQUMsQ0FBQztJQUMvQyxDQUFDO0lBQ0gsOEJBQUM7QUFBRCxDQUFDLENBTnFDLEtBQUssQ0FBQyxTQUFTLEdBTXBEO0FBMkJRLDBEQUF1QjtBQXpCaEM7O0dBRUc7QUFDSCxJQUFNLGVBQWUsR0FBRyxVQUN0QixNQUE4QyxFQUM5QyxTQUEwQyxFQUMxQyxPQUE0QztJQUE1QyxzQ0FBNEM7SUFFNUMscUVBQXFFO0lBQ3JFLElBQUksQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLEVBQUU7UUFDakIsT0FBTyxNQUFNLENBQUMsT0FBTyxDQUFDLENBQUM7S0FDeEI7SUFFRCwwQ0FBMEM7SUFDMUMsd0ZBQXdGO0lBQ3hGLFNBQVMsVUFBVSxDQUFDLEtBQThCO1FBQ2hELE9BQU8sZUFBZSxDQUFDLE1BQU0sRUFBRSxTQUFTLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxFQUFFLE9BQU8sQ0FBQyxNQUFNLENBQUMsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFDOUUsQ0FBQztJQUVELElBQU0sSUFBSSxHQUFHLFNBQVMsQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUUxQiwyRUFBMkU7SUFDM0UsT0FBTyxLQUFLLENBQUMsWUFBWSxDQUFDLG9CQUFDLElBQUksUUFBRSxVQUFVLENBQVEsRUFBRSxFQUFFLFdBQVcsRUFBRSxJQUFJLENBQUMsV0FBVyxFQUFFLENBQUMsQ0FBQztBQUMxRixDQUFDLENBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQzVDRix3R0FBMEM7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ0ExQyw2RUFBNEI7QUFDNUIsNkVBQTRCO0FBQzVCLHlFQUEwQjtBQUMxQixtRUFBdUI7QUFDdkIsdUVBQXlCO0FBQ3pCLGlFQUFzQjtBQUN0QixtRUFBdUI7QUFFdkIsNEVBQThCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDUjlCLHFHQUF5QztBQUN6Qyw4RUFBK0I7QUFFL0IsNEhBQWtEO0FBRWxELCtGQUFnRztBQUNoRyxnRkFBMkM7QUFTM0M7SUFBaUMsK0JBQXFEO0lBQ3BGLHFCQUFZLEtBQXdCO1FBQXBDLFlBQ0Usa0JBQU0sS0FBSyxDQUFDLFNBS2I7UUFKQyxLQUFJLENBQUMsS0FBSyxHQUFHO1lBQ1gsZUFBZSxFQUFFLEVBQUU7WUFDbkIsY0FBYyxFQUFFLGdCQUFJLEVBQVU7U0FDL0IsQ0FBQzs7SUFDSixDQUFDO0lBRU0sdUNBQWlCLEdBQXhCO1FBQ0UsSUFBSSxJQUFJLENBQUMsS0FBSyxDQUFDLFFBQVEsRUFBRTtZQUN2QixJQUFJLENBQUMscUJBQXFCLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxRQUFRLENBQUMsTUFBTSxDQUFDLENBQUM7U0FDeEQ7SUFDSCxDQUFDO0lBRU0sd0NBQWtCLEdBQXpCLFVBQTBCLFNBQTRCO1FBQ3BELElBQUksSUFBSSxDQUFDLEtBQUssQ0FBQyxRQUFRLElBQUksSUFBSSxDQUFDLEtBQUssQ0FBQyxRQUFRLEtBQUssU0FBUyxDQUFDLFFBQVEsRUFBRTtZQUNyRSxJQUFJLENBQUMscUJBQXFCLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxRQUFRLENBQUMsTUFBTSxDQUFDLENBQUM7U0FDeEQ7SUFDSCxDQUFDO0lBRU0sNEJBQU0sR0FBYjtRQUFBLGlCQWVDO1FBZE8sbUJBQWdELEVBQTlDLGtDQUFjLEVBQUUsb0NBQThCLENBQUM7UUFFdkQsT0FBTyxDQUNMLDZCQUFLLEtBQUssRUFBRSxFQUFFLE9BQU8sRUFBRSxNQUFNLEVBQUU7WUFDN0Isb0JBQUMsd0JBQUksSUFBQyxRQUFRLEVBQUUsSUFBSSxFQUFFLFNBQVMsRUFBRSxJQUFJLEVBQUUsU0FBUyxFQUFFLEtBQUssRUFBRSxNQUFNLEVBQUUsSUFBSSxFQUFFLE9BQU8sRUFBRSxDQUFDLElBQzlFLGVBQWUsQ0FBQyxNQUFNLElBQUksQ0FBQztnQkFDMUIsY0FBYyxDQUFDLEdBQUcsQ0FBQyxVQUFDLGFBQWEsRUFBRSxLQUFLLElBQUssUUFDM0Msb0JBQUMsd0JBQUksQ0FBQyxNQUFNLElBQUMsR0FBRyxFQUFFLDJCQUF5QixLQUFPLEVBQUUsS0FBSyxFQUFFLEVBQUUsS0FBSyxFQUFFLE1BQU0sRUFBRSxJQUN6RSxLQUFJLENBQUMsbUJBQW1CLENBQUMsYUFBYSxFQUFFLGVBQWUsQ0FBQyxDQUM3QyxDQUNmLEVBSjRDLENBSTVDLENBQUMsQ0FDQyxDQUNILENBQ1AsQ0FBQztJQUNKLENBQUM7SUFFUywyQ0FBcUIsR0FBL0IsVUFBZ0MsS0FBYTtRQUMzQyxJQUFNLE1BQU0sR0FBRyxJQUFJLGVBQWUsQ0FBQyxLQUFLLENBQUMsQ0FBQztRQUMxQyw2REFBNkQ7UUFDN0QsSUFBTSxlQUFlLEdBQUcsTUFBTSxDQUFDLEdBQUcsQ0FBQyxNQUFNLENBQUMsQ0FBQztRQUMzQyxJQUFNLGNBQWMsR0FBRyxrQkFBTSxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDLENBQWlCLENBQUM7UUFFcEUsSUFBSSxDQUFDLFFBQVEsQ0FBQztZQUNaLGVBQWUsRUFBRSxlQUFlLENBQUMsQ0FBQyxDQUFDLGVBQWUsQ0FBQyxDQUFDLENBQUMsRUFBRTtZQUN2RCxjQUFjO1NBQ2YsQ0FBQyxDQUFDO0lBQ0wsQ0FBQztJQUVTLHlDQUFtQixHQUE3QixVQUE4QixHQUF1QixFQUFFLGVBQXVCO1FBQzVFLElBQU0sVUFBVSxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsY0FBYyxDQUFDLElBQUksS0FBSyxDQUFDLENBQUM7UUFDeEQsUUFBUSxHQUFHLEVBQUU7WUFDWCxLQUFLLGNBQU8sQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLGlCQUFpQixFQUFFO2dCQUMxQyxPQUFPLG9CQUFDLDJCQUFlLElBQUMsZUFBZSxFQUFFLGVBQWUsRUFBRSxVQUFVLEVBQUUsVUFBVSxHQUFJLENBQUM7WUFDdkYsS0FBSyxjQUFPLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxpQkFBaUIsRUFBRTtnQkFDNUMsT0FBTyxvQkFBQyw0QkFBZ0IsSUFBQyxlQUFlLEVBQUUsZUFBZSxFQUFFLFVBQVUsRUFBRSxVQUFVLEdBQUksQ0FBQztZQUN4RixLQUFLLGNBQU8sQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDLGlCQUFpQixFQUFFO2dCQUMvQyxPQUFPLG9CQUFDLGdDQUFvQixJQUFDLE9BQU8sRUFBRSxlQUFlLENBQUMsUUFBUSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxjQUFjLENBQUMsQ0FBQyxDQUFDLGNBQWMsR0FBSSxDQUFDO1lBQzlHO2dCQUNFLE9BQU8sb0JBQUMsMkJBQU8sSUFBQyxLQUFLLEVBQUUsSUFBSSxJQUFHLDBDQUF3QyxHQUFHLE1BQUcsQ0FBVyxDQUFDO1NBQzNGO0lBQ0gsQ0FBQztJQUNILGtCQUFDO0FBQUQsQ0FBQyxDQS9EZ0MsS0FBSyxDQUFDLFNBQVMsR0ErRC9DO0FBL0RZLGtDQUFXOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDZnhCLDhFQUErQjtBQUUvQixvSEFBd0M7QUFDeEMsNEhBQXNGO0FBRXRGLGdGQUF5RztBQUl6RztJQUFpQywrQkFBdUM7SUFDdEUscUJBQVksS0FBd0I7ZUFDbEMsa0JBQU0sS0FBSyxDQUFDO0lBQ2QsQ0FBQztJQUVNLDRCQUFNLEdBQWI7UUFDRSxPQUFPLENBQ0wsb0JBQUMsNkJBQVMsSUFBQyxLQUFLLEVBQUUsS0FBSztZQUNyQixvQkFBQywyQkFBTyxJQUFDLEtBQUssRUFBRSxJQUFJLEVBQUUsTUFBTSxFQUFFLE1BQU07Z0JBQ2xDLG9CQUFDLHdCQUFJLElBQUMsUUFBUSxFQUFFLElBQUksRUFBRSxNQUFNLEVBQUUsSUFBSSxFQUFFLE9BQU8sRUFBRSxJQUFJO29CQUM5QyxJQUFJLENBQUMscUJBQXFCLEVBQUU7b0JBQzVCLElBQUksQ0FBQyw0QkFBNEIsRUFBRTtvQkFDbkMsSUFBSSxDQUFDLHNCQUFzQixFQUFFLENBQ3pCLENBQ0MsQ0FDQSxDQUNiLENBQUM7SUFDSixDQUFDO0lBRVMsK0NBQXlCLEdBQW5DLFVBQW9DLEdBQW9CO1FBQ3RELE9BQU8sQ0FDTCxvQkFBQyx3QkFBSSxDQUFDLEdBQUcsSUFBQyxPQUFPLEVBQUUsQ0FBQztZQUNsQixvQkFBQyx3QkFBSSxDQUFDLE1BQU0sSUFBQyxLQUFLLEVBQUUsQ0FBQztnQkFDbkIsNkJBQ0UsR0FBRyxFQUFFLGtCQUFnQixHQUFHLENBQUMsSUFBSSxDQUFDLGlCQUFpQixFQUFFLG1CQUFnQixFQUNqRSxLQUFLLEVBQUUsRUFBRSxNQUFNLEVBQUUsTUFBTSxFQUFFLEtBQUssRUFBRSxNQUFNLEVBQUUsRUFDeEMsR0FBRyxFQUFFLFNBQU8sR0FBRyxDQUFDLElBQUksVUFBTyxHQUMzQixDQUNVO1lBQ2Qsb0JBQUMsd0JBQUksQ0FBQyxNQUFNLElBQUMsU0FBUyxFQUFFLE1BQU0sRUFBRSxLQUFLLEVBQUUsQ0FBQztnQkFDdEMsb0JBQUMsMEJBQU0sUUFBRSxHQUFHLENBQUMsSUFBSSxDQUFVO2dCQUMxQixHQUFHLENBQUMsT0FBTztnQkFDWjtvQkFDRSw4QkFBTSxLQUFLLEVBQUUsRUFBRSxVQUFVLEVBQUUsTUFBTSxFQUFFO3dCQUFHLEdBQUcsQ0FBQyxjQUFjLENBQUMsQ0FBQyxDQUFDLGtCQUFrQixDQUFDLENBQUMsQ0FBQyxTQUFTOzZCQUFVO29CQUNsRyxHQUFHLENBQUMsT0FBTyxDQUFDLE1BQU0sS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFJLEdBQUcsQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLGFBQVEsR0FBRyxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUcsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQzVGO2dCQUNKLCtCQUFNLENBQ007WUFDZCxvQkFBQyx3QkFBSSxDQUFDLE1BQU0sSUFBQyxLQUFLLEVBQUUsQ0FBQztnQkFDbkIsb0JBQUMsd0JBQUksQ0FBQyxHQUFHO29CQUNQLG9CQUFDLDBCQUFNLElBQUMsS0FBSyxFQUFFLElBQUk7d0JBQ2pCLG9CQUFDLHVCQUFJLElBQUMsRUFBRSxFQUFFLEVBQUUsUUFBUSxFQUFFLGtCQUFrQixFQUFFLE1BQU0sRUFBRSxXQUFTLEdBQUcsQ0FBQyxJQUFJLENBQUMsaUJBQWlCLEVBQUksRUFBRSxjQUVwRixDQUNBLENBQ0E7Z0JBQ1gsb0JBQUMsd0JBQUksQ0FBQyxHQUFHO29CQUNQLG9CQUFDLDBCQUFNLElBQUMsS0FBSyxFQUFFLElBQUk7d0JBQ2pCLG9CQUFDLHVCQUFJLElBQUMsRUFBRSxFQUFFLEVBQUUsUUFBUSxFQUFFLFVBQVUsRUFBRSxNQUFNLEVBQUUsVUFBUSxHQUFHLENBQUMsSUFBSSxDQUFDLGlCQUFpQixFQUFJLEVBQUUsYUFBZSxDQUMxRixDQUNBLENBQ0MsQ0FDTCxDQUNaLENBQUM7SUFDSixDQUFDO0lBRVMsNENBQXNCLEdBQWhDO1FBQ0UsT0FBTyxDQUNMO1lBQ0Usb0JBQUMsd0JBQUksQ0FBQyxHQUFHLElBQUMsUUFBUSxFQUFFLElBQUk7Z0JBQ3RCLG9CQUFDLHdCQUFJLENBQUMsTUFBTSxJQUFDLEtBQUssRUFBRSxFQUFFO29CQUNwQixvQkFBQywwQkFBTSxJQUFDLE9BQU8sRUFBRSxNQUFNLHdCQUE0QjtvQkFDbkQsb0JBQUMsMkJBQU8sSUFBQyxPQUFPLEVBQUUsSUFBSSxHQUFJLENBQ2QsQ0FDTDtZQUNYLG9CQUFDLHdCQUFJLENBQUMsR0FBRyxJQUFDLE9BQU8sRUFBRSxDQUFDLEVBQUUsT0FBTyxFQUFFLElBQUk7Z0JBQ2hDLElBQUksQ0FBQyxpQkFBaUIsRUFBRTtnQkFDeEIsSUFBSSxDQUFDLHdCQUF3QixFQUFFLENBQ3ZCO1lBQ1gsb0JBQUMsd0JBQUksQ0FBQyxHQUFHLElBQUMsUUFBUSxFQUFFLEtBQUs7Z0JBQ3ZCLG9CQUFDLHdCQUFJLENBQUMsTUFBTSxJQUFDLEtBQUssRUFBRSxFQUFFO29CQUNwQixvQkFBQyx1QkFBSSxJQUFDLEtBQUssRUFBRSxFQUFFLEtBQUssRUFBRSxNQUFNLEVBQUUsS0FBSyxFQUFFLE9BQU8sRUFBRSxFQUFFLEVBQUUsRUFBRSxVQUFVLHVCQUV2RCxDQUNLLENBQ0wsQ0FDVixDQUNKLENBQUM7SUFDSixDQUFDO0lBRVMsMkNBQXFCLEdBQS9CO1FBQ0UsT0FBTyxDQUNMO1lBQ0Usb0JBQUMsd0JBQUksQ0FBQyxHQUFHLElBQUMsUUFBUSxFQUFFLEtBQUs7Z0JBQ3ZCLG9CQUFDLHdCQUFJLENBQUMsTUFBTSxJQUFDLEtBQUssRUFBRSxFQUFFO29CQUNwQixvQkFBQywwQkFBTSxJQUFDLE9BQU8sRUFBRSxNQUFNLHVCQUEyQjtvQkFDbEQsb0JBQUMsMkJBQU8sSUFBQyxPQUFPLEVBQUUsSUFBSSxHQUFJLENBQ2QsQ0FDTDtZQUNWLElBQUksQ0FBQyx5QkFBeUIsQ0FBQyxjQUFPLENBQUMsQ0FBQyxDQUFDLENBQUM7WUFDMUMsSUFBSSxDQUFDLHlCQUF5QixDQUFDLGNBQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQztZQUMzQyxvQkFBQyx3QkFBSSxDQUFDLEdBQUcsSUFBQyxRQUFRLEVBQUUsS0FBSztnQkFDdkIsb0JBQUMsd0JBQUksQ0FBQyxNQUFNLElBQUMsS0FBSyxFQUFFLEVBQUU7b0JBQ3BCLG9CQUFDLHVCQUFJLElBQUMsS0FBSyxFQUFFLEVBQUUsS0FBSyxFQUFFLE1BQU0sRUFBRSxLQUFLLEVBQUUsT0FBTyxFQUFFLEVBQUUsRUFBRSxFQUFFLFNBQVMsc0JBRXRELENBQ0ssQ0FDTCxDQUNWLENBQ0osQ0FBQztJQUNKLENBQUM7SUFFUyxrREFBNEIsR0FBdEM7UUFDRSxPQUFPLENBQ0w7WUFDRSxvQkFBQyx3QkFBSSxDQUFDLEdBQUcsSUFBQyxRQUFRLEVBQUUsS0FBSztnQkFDdkIsb0JBQUMsd0JBQUksQ0FBQyxNQUFNLElBQUMsS0FBSyxFQUFFLEVBQUU7b0JBQ3BCLG9CQUFDLDBCQUFNLElBQUMsT0FBTyxFQUFFLE1BQU0sOEJBQWtDO29CQUN6RCxvQkFBQywyQkFBTyxJQUFDLE9BQU8sRUFBRSxJQUFJLEdBQUksQ0FDZCxDQUNMO1lBQ1YsSUFBSSxDQUFDLHlCQUF5QixDQUFDLGNBQU8sQ0FBQyxNQUFNLENBQUM7WUFDOUMsSUFBSSxDQUFDLHlCQUF5QixDQUFDLGNBQU8sQ0FBQyxRQUFRLENBQUM7WUFDakQsb0JBQUMsd0JBQUksQ0FBQyxHQUFHLElBQUMsUUFBUSxFQUFFLEtBQUs7Z0JBQ3ZCLG9CQUFDLHdCQUFJLENBQUMsTUFBTSxJQUFDLEtBQUssRUFBRSxFQUFFO29CQUNwQixvQkFBQyx1QkFBSSxJQUFDLEtBQUssRUFBRSxFQUFFLEtBQUssRUFBRSxNQUFNLEVBQUUsS0FBSyxFQUFFLE9BQU8sRUFBRSxFQUFFLEVBQUUsRUFBRSxnQkFBZ0IsNkJBRTdELENBQ0ssQ0FDTCxDQUNWLENBQ0osQ0FBQztJQUNKLENBQUM7SUFFUywrQ0FBeUIsR0FBbkMsVUFBb0MsS0FBYTtRQUMvQyxPQUFPLENBQ0wsb0JBQUMsd0JBQUksQ0FBQyxHQUFHLElBQUMsT0FBTyxFQUFFLENBQUM7WUFDbEIsb0JBQUMsd0JBQUksQ0FBQyxNQUFNLElBQUMsS0FBSyxFQUFFLENBQUM7Z0JBQ25CLDZCQUFLLEdBQUcsRUFBRSxLQUFLLENBQUMsSUFBSSxFQUFFLEtBQUssRUFBRSxFQUFFLE1BQU0sRUFBRSxNQUFNLEVBQUUsS0FBSyxFQUFFLE1BQU0sRUFBRSxFQUFFLEdBQUcsRUFBRSxXQUFTLEtBQUssQ0FBQyxLQUFLLFVBQU8sR0FBSSxDQUN4RjtZQUNkLG9CQUFDLHdCQUFJLENBQUMsTUFBTSxJQUFDLFNBQVMsRUFBRSxNQUFNLEVBQUUsS0FBSyxFQUFFLENBQUM7Z0JBQ3RDLG9CQUFDLDBCQUFNLFFBQUUsS0FBSyxDQUFDLEtBQUssQ0FBVTtnQkFDOUI7b0JBQ0UsOEJBQU0sS0FBSyxFQUFFLEVBQUUsVUFBVSxFQUFFLE1BQU0sRUFBRSxvQkFBc0I7b0JBQ3hELEtBQUssQ0FBQyxXQUFXLENBQ2hCO2dCQUNKO29CQUNFLDhCQUFNLEtBQUssRUFBRSxFQUFFLFVBQVUsRUFBRSxNQUFNLEVBQUUseUJBQTJCO29CQUM3RCxLQUFLLENBQUMsT0FBTyxDQUFDLE1BQU0sS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFJLEtBQUssQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLGFBQVEsS0FBSyxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUcsQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQ3BHO2dCQUNKLCtCQUFNLENBQ007WUFDZCxvQkFBQyx3QkFBSSxDQUFDLE1BQU0sSUFBQyxLQUFLLEVBQUUsQ0FBQztnQkFDbkIsb0JBQUMsMEJBQU0sSUFBQyxLQUFLLEVBQUUsSUFBSTtvQkFDakIsb0JBQUMsdUJBQUksSUFBQyxFQUFFLEVBQUUsS0FBSyxDQUFDLElBQUksYUFBZSxDQUM1QixDQUNHLENBQ0wsQ0FDWixDQUFDO0lBQ0osQ0FBQztJQUVTLHVDQUFpQixHQUEzQjtRQUNFLE9BQU8sQ0FDTCxvQkFBQyx3QkFBSSxDQUFDLE1BQU0sSUFBQyxLQUFLLEVBQUUsQ0FBQztZQUNuQixvQkFBQyx3QkFBSSxDQUFDLEdBQUc7Z0JBQ1AsNkJBQ0UsR0FBRyxFQUFFLDJCQUEyQixFQUNoQyxLQUFLLEVBQUUsRUFBRSxLQUFLLEVBQUUsT0FBTyxFQUFFLE1BQU0sRUFBRSxPQUFPLEVBQUUsRUFDMUMsR0FBRyxFQUFFLHVCQUF1QixHQUM1QjtnQkFDRixvQkFBQyx3QkFBSSxDQUFDLEdBQUc7b0JBQ1AsMkJBQUcsSUFBSSxFQUFFLDBDQUEwQyw4QkFBNkIsQ0FDdkUsQ0FDRixDQUNDLENBQ2YsQ0FBQztJQUNKLENBQUM7SUFFUyxvREFBOEIsR0FBeEMsVUFBeUMsT0FBcUI7UUFDNUQsT0FBTyxDQUNMLG9CQUFDLHdCQUFJLENBQUMsR0FBRyxJQUFDLE9BQU8sRUFBRSxDQUFDO1lBQ2xCLG9CQUFDLHdCQUFJLENBQUMsTUFBTSxJQUFDLE9BQU8sRUFBRSxNQUFNO2dCQUMxQixvQkFBQywwQkFBTSxRQUFFLE9BQU8sQ0FBQyxJQUFJLENBQVU7Z0JBQy9CO29CQUNHLE9BQU8sQ0FBQyxPQUFPO29CQUNoQiwrQkFBTTtvQkFDTiw4QkFBTSxLQUFLLEVBQUUsRUFBRSxVQUFVLEVBQUUsTUFBTSxFQUFFLGdCQUFrQjtvQkFDcEQsT0FBTyxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQ3pCLENBQ1E7WUFDZCxvQkFBQyx3QkFBSSxDQUFDLE1BQU0sSUFBQyxPQUFPLEVBQUUsT0FBTztnQkFDM0Isb0JBQUMsMEJBQU0sSUFBQyxLQUFLLEVBQUUsSUFBSSxFQUFFLE9BQU8sRUFBRSxPQUFPO29CQUNuQyxvQkFBQyx1QkFBSSxJQUFDLEVBQUUsRUFBRSxPQUFPLENBQUMsS0FBSyxDQUFDLE1BQU0sY0FBZ0IsQ0FDdkM7Z0JBQ1Qsb0JBQUMsMEJBQU0sSUFBQyxLQUFLLEVBQUUsSUFBSSxFQUFFLE9BQU8sRUFBRSxPQUFPO29CQUNuQyxvQkFBQyx1QkFBSSxJQUFDLEVBQUUsRUFBRSxPQUFPLENBQUMsS0FBSyxDQUFDLFFBQVEsY0FBZ0IsQ0FDekMsQ0FDRyxDQUNMLENBQ1osQ0FBQztJQUNKLENBQUM7SUFFUyw4Q0FBd0IsR0FBbEM7UUFDRSxPQUFPLENBQ0wsb0JBQUMsd0JBQUksQ0FBQyxNQUFNLElBQUMsU0FBUyxFQUFFLElBQUksRUFBRSxTQUFTLEVBQUUsTUFBTSxFQUFFLEtBQUssRUFBRSxDQUFDO1lBQ3ZELG9CQUFDLHdCQUFJLENBQUMsR0FBRyxJQUFDLFNBQVMsRUFBRSxRQUFRO2dCQUMzQixvQkFBQywwQkFBTSxJQUFDLEVBQUUsRUFBRSxJQUFJLEVBQUUsU0FBUyxFQUFFLFFBQVEsa0JBRTVCLENBQ0E7WUFDWCwrQkFBTTtZQUNOLG9CQUFDLHdCQUFJLENBQUMsR0FBRyxRQUFFLElBQUksQ0FBQyw4QkFBOEIsQ0FBQyxtQkFBWSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQVk7WUFDM0Usb0JBQUMsd0JBQUksQ0FBQyxHQUFHLFFBQUUsSUFBSSxDQUFDLDhCQUE4QixDQUFDLG1CQUFZLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBWSxDQUMvRCxDQUNmLENBQUM7SUFDSixDQUFDO0lBQ0gsa0JBQUM7QUFBRCxDQUFDLENBOU1nQyxLQUFLLENBQUMsU0FBUyxHQThNL0M7QUE5TVksa0NBQVc7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNUeEIsOEVBQStCO0FBRS9CLG9IQUF3QztBQUN4Qyw0SEFBeUQ7QUFFekQsZ0ZBQW1EO0FBSW5EO0lBQWlDLCtCQUF1QztJQUN0RSxxQkFBWSxLQUF3QjtlQUNsQyxrQkFBTSxLQUFLLENBQUM7SUFDZCxDQUFDO0lBRU0sNEJBQU0sR0FBYjtRQUFBLGlCQVFDO1FBUEMsT0FBTyxDQUNMLG9CQUFDLHdCQUFJLElBQUMsUUFBUSxFQUFFLElBQUksRUFBRSxPQUFPLEVBQUUsWUFBWSxFQUFFLE1BQU0sRUFBRSxJQUFJLEVBQUUsT0FBTyxFQUFFLEtBQUssSUFDdEUsY0FBTyxDQUFDLEdBQUcsQ0FBQyxVQUFDLEtBQUssRUFBRSxLQUFLLElBQUssUUFDN0Isb0JBQUMsS0FBSyxDQUFDLFFBQVEsSUFBQyxHQUFHLEVBQUUsV0FBUyxLQUFPLElBQUcsS0FBSSxDQUFDLHlCQUF5QixDQUFDLEtBQUssQ0FBQyxDQUFrQixDQUNoRyxFQUY4QixDQUU5QixDQUFDLENBQ0csQ0FDUixDQUFDO0lBQ0osQ0FBQztJQUVTLCtDQUF5QixHQUFuQyxVQUFvQyxLQUFhO1FBQy9DLE9BQU8sQ0FDTCxvQkFBQyx3QkFBSSxDQUFDLEdBQUcsSUFBQyxPQUFPLEVBQUUsQ0FBQztZQUNsQixvQkFBQyx3QkFBSSxDQUFDLE1BQU07Z0JBQ1YsNkJBQUssR0FBRyxFQUFFLEtBQUssQ0FBQyxJQUFJLEVBQUUsS0FBSyxFQUFFLEVBQUUsTUFBTSxFQUFFLE1BQU0sRUFBRSxLQUFLLEVBQUUsTUFBTSxFQUFFLEVBQUUsR0FBRyxFQUFFLFdBQVMsS0FBSyxDQUFDLEtBQUssVUFBTyxHQUFJLENBQ3hGO1lBQ2Qsb0JBQUMsd0JBQUksQ0FBQyxNQUFNLElBQUMsU0FBUyxFQUFFLE1BQU07Z0JBQzVCLG9CQUFDLDBCQUFNLFFBQUUsS0FBSyxDQUFDLEtBQUssQ0FBVTtnQkFDOUI7b0JBQ0UsOEJBQU0sS0FBSyxFQUFFLEVBQUUsVUFBVSxFQUFFLE1BQU0sRUFBRSxvQkFBc0I7b0JBQ3hELEtBQUssQ0FBQyxXQUFXLENBQ2hCO2dCQUNKO29CQUNFLDhCQUFNLEtBQUssRUFBRSxFQUFFLFVBQVUsRUFBRSxNQUFNLEVBQUUseUJBQTJCO29CQUM3RCxLQUFLLENBQUMsT0FBTyxDQUFDLE1BQU0sS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFJLEtBQUssQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLGFBQVEsS0FBSyxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUcsQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQ3BHO2dCQUNKLCtCQUFNLENBQ007WUFDZCxvQkFBQyx3QkFBSSxDQUFDLE1BQU07Z0JBQ1Ysb0JBQUMsMEJBQU0sSUFBQyxLQUFLLEVBQUUsSUFBSTtvQkFDakIsb0JBQUMsdUJBQUksSUFBQyxFQUFFLEVBQUUsS0FBSyxDQUFDLElBQUksYUFBZSxDQUM1QixDQUNHLENBQ0wsQ0FDWixDQUFDO0lBQ0osQ0FBQztJQUNILGtCQUFDO0FBQUQsQ0FBQyxDQXpDZ0MsS0FBSyxDQUFDLFNBQVMsR0F5Qy9DO0FBekNZLGtDQUFXOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDVHhCLDhFQUErQjtBQUUvQixvSEFBd0M7QUFDeEMsNEhBQStEO0FBRS9ELGdGQUE0RDtBQUk1RDtJQUF3QyxzQ0FBOEM7SUFDcEYsNEJBQVksS0FBK0I7ZUFDekMsa0JBQU0sS0FBSyxDQUFDO0lBQ2QsQ0FBQztJQUVNLG1DQUFNLEdBQWI7UUFDRSxPQUFPLENBQ0wsb0JBQUMsd0JBQUksSUFBQyxPQUFPLEVBQUUsSUFBSTtZQUNqQixvQkFBQyx3QkFBSSxDQUFDLElBQUksUUFBRSxJQUFJLENBQUMsdUJBQXVCLENBQUMsY0FBTyxDQUFDLE1BQU0sQ0FBQyxDQUFhO1lBQ3JFLG9CQUFDLHdCQUFJLENBQUMsSUFBSSxRQUFFLElBQUksQ0FBQyx1QkFBdUIsQ0FBQyxjQUFPLENBQUMsUUFBUSxDQUFDLENBQWE7WUFDdkUsb0JBQUMsd0JBQUksQ0FBQyxJQUFJLFFBQUUsSUFBSSxDQUFDLHVCQUF1QixDQUFDLGNBQU8sQ0FBQyxXQUFXLENBQUMsQ0FBYSxDQUNyRSxDQUNSLENBQUM7SUFDSixDQUFDO0lBRVMsb0RBQXVCLEdBQWpDLFVBQWtDLEdBQW9CO1FBQ3BELE9BQU8sQ0FDTCxvQkFBQyx3QkFBSSxJQUFDLFFBQVEsRUFBRSxJQUFJLEVBQUUsT0FBTyxFQUFFLENBQUMsRUFBRSxNQUFNLEVBQUUsSUFBSSxFQUFFLE9BQU8sRUFBRSxJQUFJO1lBQzNELG9CQUFDLHdCQUFJLENBQUMsTUFBTTtnQkFDViw2QkFDRSxHQUFHLEVBQUUsa0JBQWdCLEdBQUcsQ0FBQyxJQUFJLENBQUMsaUJBQWlCLEVBQUUsbUJBQWdCLEVBQ2pFLEdBQUcsRUFBRSxjQUFZLEdBQUcsQ0FBQyxJQUFNLEVBQzNCLEtBQUssRUFBRSxFQUFFLE1BQU0sRUFBRSxPQUFPLEVBQUUsR0FDMUIsQ0FDVTtZQUNkLG9CQUFDLHdCQUFJLENBQUMsTUFBTSxJQUFDLFNBQVMsRUFBRSxNQUFNO2dCQUM1QixvQkFBQywwQkFBTSxJQUFDLEVBQUUsRUFBRSxJQUFJLElBQUcsR0FBRyxDQUFDLElBQUksQ0FBVTtnQkFDckMsb0JBQUMsd0JBQUk7b0JBQ0gsb0JBQUMsd0JBQUksQ0FBQyxJQUFJLFFBQUUsTUFBRyxHQUFHLENBQUMsY0FBYyxDQUFDLENBQUMsQ0FBQyxZQUFZLENBQUMsQ0FBQyxDQUFDLEVBQUUsSUFBRyxHQUFHLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUcsQ0FBYTtvQkFDN0Ysb0JBQUMsd0JBQUksQ0FBQyxJQUFJLFFBQUUsR0FBRyxDQUFDLE9BQU8sQ0FBYTtvQkFDcEMsb0JBQUMsd0JBQUksQ0FBQyxJQUFJLFFBQUUsb0JBQWtCLEdBQUcsQ0FBQyxZQUFjLENBQWEsQ0FDeEQsQ0FDSztZQUNkLG9CQUFDLHdCQUFJLENBQUMsTUFBTSxJQUFDLFNBQVMsRUFBRSxJQUFJO2dCQUMxQixvQkFBQyx3QkFBSSxDQUFDLEdBQUc7b0JBQ1Asb0JBQUMsMEJBQU0sSUFBQyxLQUFLLEVBQUUsSUFBSTt3QkFDakIsb0JBQUMsdUJBQUksSUFBQyxFQUFFLEVBQUUsRUFBRSxRQUFRLEVBQUUsa0JBQWtCLEVBQUUsTUFBTSxFQUFFLFdBQVMsR0FBRyxDQUFDLElBQUksQ0FBQyxpQkFBaUIsRUFBSSxFQUFFLGNBRXBGLENBQ0EsQ0FDQTtnQkFDWCxvQkFBQyx3QkFBSSxDQUFDLEdBQUc7b0JBQ1Asb0JBQUMsMEJBQU0sSUFBQyxLQUFLLEVBQUUsSUFBSTt3QkFDakIsb0JBQUMsdUJBQUksSUFBQyxFQUFFLEVBQUUsRUFBRSxRQUFRLEVBQUUsVUFBVSxFQUFFLE1BQU0sRUFBRSxVQUFRLEdBQUcsQ0FBQyxJQUFJLENBQUMsaUJBQWlCLEVBQUksRUFBRSxhQUFlLENBQzFGLENBQ0EsQ0FDQyxDQUNULENBQ1IsQ0FBQztJQUNKLENBQUM7SUFDSCx5QkFBQztBQUFELENBQUMsQ0FsRHVDLEtBQUssQ0FBQyxTQUFTLEdBa0R0RDtBQWxEWSxnREFBa0I7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNUL0IsOEVBQStCO0FBRS9CLDRIQUFvRztBQUVwRyxvSEFBd0M7QUFDeEMsZ0ZBQTBFO0FBUTFFO0lBQXFDLG1DQUE2RDtJQUNoRyx5QkFBWSxLQUE0QjtRQUF4QyxZQUNFLGtCQUFNLEtBQUssQ0FBQyxTQUliO1FBSEMsS0FBSSxDQUFDLEtBQUssR0FBRztZQUNYLFVBQVUsRUFBRSxJQUFJO1NBQ2pCLENBQUM7O0lBQ0osQ0FBQztJQUVNLDJDQUFpQixHQUF4QjtRQUNFLElBQUksQ0FBQyxlQUFlLEVBQUUsQ0FBQztJQUN6QixDQUFDO0lBRU0sNENBQWtCLEdBQXpCLFVBQTBCLFNBQWdDO1FBQ3hELElBQUksSUFBSSxDQUFDLEtBQUssQ0FBQyxRQUFRLEtBQUssU0FBUyxDQUFDLFFBQVEsRUFBRTtZQUM5QyxJQUFJLENBQUMsZUFBZSxFQUFFLENBQUM7U0FDeEI7SUFDSCxDQUFDO0lBRU0sZ0NBQU0sR0FBYjtRQUNFLE9BQU8sQ0FDTCxJQUFJLENBQUMsS0FBSyxDQUFDLFVBQVUsSUFBSSxDQUN2QixvQkFBQyw2QkFBUztZQUNQLElBQUksQ0FBQyxjQUFjLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxVQUFVLENBQUM7WUFDMUMsSUFBSSxDQUFDLGNBQWMsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLFVBQVUsQ0FBQyxRQUFRLENBQUMsQ0FDMUMsQ0FDYixDQUNGLENBQUM7SUFDSixDQUFDO0lBRVMsd0NBQWMsR0FBeEIsVUFBeUIsR0FBcUI7UUFDNUMsT0FBTyxDQUNMLG9CQUFDLHdCQUFJLElBQUMsUUFBUSxFQUFFLElBQUksRUFBRSxPQUFPLEVBQUUsQ0FBQztZQUM5QixvQkFBQyx3QkFBSSxDQUFDLE1BQU0sSUFBQyxLQUFLLEVBQUUsQ0FBQztnQkFDbkIsNkJBQ0UsR0FBRyxFQUFFLGNBQVksR0FBRyxDQUFDLElBQU0sRUFDM0IsR0FBRyxFQUFFLGtCQUFnQixHQUFHLENBQUMsSUFBSSxDQUFDLGlCQUFpQixFQUFFLGNBQVcsRUFDNUQsS0FBSyxFQUFFLEVBQUUsTUFBTSxFQUFFLE9BQU8sRUFBRSxPQUFPLEVBQUUsTUFBTSxFQUFFLEdBQzNDLENBQ1U7WUFDZCxvQkFBQyx3QkFBSSxDQUFDLE1BQU0sSUFBQyxTQUFTLEVBQUUsTUFBTTtnQkFDNUIsb0JBQUMsMEJBQU0sSUFBQyxFQUFFLEVBQUUsSUFBSTtvQkFDYixHQUFHLENBQUMsSUFBSTtvQkFDVCxvQkFBQywwQkFBTSxDQUFDLFNBQVMsUUFBRSxHQUFHLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBb0IsQ0FDdEQ7Z0JBQ1Q7b0JBQ0UsK0JBQUksR0FBRyxDQUFDLGVBQWUsQ0FBSztvQkFDNUIsb0JBQUMsd0JBQUk7d0JBQ0gsb0JBQUMsd0JBQUksQ0FBQyxJQUFJOzs0QkFBbUIsR0FBRyxDQUFDLFlBQVksQ0FBYTt3QkFDMUQsb0JBQUMsd0JBQUksQ0FBQyxJQUFJOzs0QkFBbUIsR0FBRyxDQUFDLGFBQWEsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQWE7d0JBQ3RFLG9CQUFDLHdCQUFJLENBQUMsSUFBSTs7NEJBQ0ssR0FBRzs0QkFDZixHQUFHLENBQUMsU0FBUyxDQUFDLEdBQUcsQ0FBQyxVQUFDLFFBQVEsRUFBRSxLQUFLLElBQUssUUFDdEMsb0JBQUMsS0FBSyxDQUFDLFFBQVEsSUFBQyxHQUFHLEVBQUssR0FBRyxDQUFDLElBQUksQ0FBQyxpQkFBaUIsRUFBRSxrQkFBYSxLQUFPO2dDQUNyRSxRQUFRLENBQUMsWUFBWTs7Z0NBQUksMkJBQUcsSUFBSSxFQUFFLFFBQVEsQ0FBQyxJQUFJLFdBQVU7b0NBQzNDLENBQ2xCLEVBSnVDLENBSXZDLENBQUMsQ0FDUTt3QkFDWixvQkFBQyx3QkFBSSxDQUFDLElBQUk7OzRCQUNFLEdBQUcsQ0FBQyxJQUFJLENBQUMsT0FBTzs7NEJBQWlCLEdBQUcsQ0FBQyxJQUFJLENBQUMsVUFBVTs7NEJBQzdELDJCQUFHLElBQUksRUFBRSxHQUFHLENBQUMsSUFBSSxDQUFDLElBQUksbUJBQWtCLENBQy9CO3dCQUNaLG9CQUFDLHdCQUFJLENBQUMsSUFBSTs0QkFDUixvQkFBQyx3QkFBSSxDQUFDLE1BQU0sSUFBQyxPQUFPLEVBQUUsT0FBTztnQ0FDM0Isb0JBQUMsMEJBQU0sSUFBQyxLQUFLLEVBQUUsSUFBSSxFQUFFLElBQUksRUFBRSxJQUFJLEVBQUUsYUFBYSxFQUFFLE9BQU87b0NBQ3JELG9CQUFDLHVCQUFJLElBQUMsRUFBRSxFQUFFLEVBQUUsUUFBUSxFQUFFLFVBQVUsRUFBRSxNQUFNLEVBQUUsVUFBUSxHQUFHLENBQUMsSUFBSSxDQUFDLGlCQUFpQixFQUFJLEVBQUUsSUFDL0UsWUFBVSxHQUFHLENBQUMsSUFBTSxDQUNoQjtvQ0FFUCxvQkFBQyx3QkFBSSxJQUFDLElBQUksRUFBRSxvQkFBb0IsR0FBSSxDQUM3QixDQUNHLENBQ0osQ0FDUCxDQUNOLENBQ1MsQ0FDVCxDQUNSLENBQUM7SUFDSixDQUFDO0lBRVMsd0NBQWMsR0FBeEIsVUFBeUIsUUFBdUI7UUFBaEQsaUJBNEJDO1FBM0JDLElBQU0sTUFBTSxHQUFHO1lBQ2I7Z0JBQ0UsT0FBTyxFQUFFO29CQUNQLE9BQU8sRUFBRSxDQUNQO3dCQUNFLG9CQUFDLDJCQUFPLE9BQUc7d0JBQ1gsb0JBQUMsd0JBQUksSUFBQyxRQUFRLEVBQUUsSUFBSSxFQUFFLE9BQU8sRUFBRSxDQUFDLEVBQUUsU0FBUyxFQUFFLElBQUksRUFBRSxPQUFPLEVBQUUsWUFBWSxFQUFFLEtBQUssRUFBRSxFQUFFLE9BQU8sRUFBRSxRQUFRLEVBQUUsSUFDbkcsUUFBUSxDQUFDLEdBQUcsQ0FBQyxVQUFDLE9BQU8sRUFBRSxLQUFLLElBQUssUUFDaEMsb0JBQUMsd0JBQUksQ0FBQyxHQUFHLElBQUMsT0FBTyxFQUFFLENBQUMsRUFBRSxHQUFHLEVBQUUsaUJBQWUsS0FBTyxJQUM5QyxLQUFJLENBQUMsa0JBQWtCLENBQUMsT0FBTyxDQUFDLENBQ3hCLENBQ1osRUFKaUMsQ0FJakMsQ0FBQyxDQUNHLENBQ04sQ0FDSjtpQkFDRjtnQkFDRCxHQUFHLEVBQUUsVUFBVTtnQkFDZixLQUFLLEVBQUUsaUJBQWlCO2FBQ3pCO1lBQ0Q7Z0JBQ0UsT0FBTyxFQUFFLGNBQWM7Z0JBQ3ZCLEdBQUcsRUFBRSxPQUFPO2dCQUNaLEtBQUssRUFBRSxPQUFPO2FBQ2Y7U0FDRixDQUFDO1FBRUYsT0FBTyxvQkFBQyw2QkFBUyxJQUFDLE1BQU0sRUFBRSxNQUFNLEVBQUUsa0JBQWtCLEVBQUUsQ0FBQyxHQUFJLENBQUM7SUFDOUQsQ0FBQztJQUVTLDRDQUFrQixHQUE1QixVQUE2QixPQUFvQjtRQUMvQyxPQUFPLENBQ0w7WUFDRSxvQkFBQyx3QkFBSSxDQUFDLE1BQU0sSUFBQyxLQUFLLEVBQUUsQ0FBQztnQkFDbkIsNkJBQUssR0FBRyxFQUFFLE9BQU8sQ0FBQyxJQUFJLEVBQUUsR0FBRyxFQUFLLE9BQU8sQ0FBQyxJQUFJLFVBQU8sRUFBRSxLQUFLLEVBQUUsRUFBRSxNQUFNLEVBQUUsTUFBTSxFQUFFLEtBQUssRUFBRSxNQUFNLEVBQUUsR0FBSSxDQUNyRjtZQUNkLG9CQUFDLHdCQUFJLENBQUMsTUFBTSxJQUFDLFNBQVMsRUFBRSxNQUFNLEVBQUUsS0FBSyxFQUFFLENBQUM7Z0JBQ3RDLG9CQUFDLDBCQUFNLFFBQUUsT0FBTyxDQUFDLElBQUksQ0FBVTtnQkFDL0IsK0JBQUksT0FBTyxDQUFDLE9BQU8sQ0FBSyxDQUNaO1lBQ2Qsb0JBQUMsd0JBQUksQ0FBQyxNQUFNLElBQUMsT0FBTyxFQUFFLE9BQU87Z0JBQzNCLG9CQUFDLDBCQUFNLElBQUMsS0FBSyxFQUFFLElBQUksRUFBRSxJQUFJLEVBQUUsSUFBSSxFQUFFLGFBQWEsRUFBRSxPQUFPO29CQUNyRCxvQkFBQyx1QkFBSSxJQUFDLEVBQUUsRUFBRSxPQUFPLENBQUMsSUFBSSxJQUFHLGdCQUFnQixDQUFRO29CQUVqRCxvQkFBQyx3QkFBSSxJQUFDLElBQUksRUFBRSxvQkFBb0IsR0FBSSxDQUM3QixDQUNHLENBQ2IsQ0FDSixDQUFDO0lBQ0osQ0FBQztJQUVTLHlDQUFlLEdBQXpCO1FBQ0UsSUFBTSxNQUFNLEdBQUcsSUFBSSxlQUFlLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsUUFBUSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUM7UUFDMUYsNkRBQTZEO1FBQzdELElBQU0sT0FBTyxHQUFHLE1BQU0sQ0FBQyxHQUFHLENBQUMsTUFBTSxDQUFDLENBQUM7UUFFbkMsSUFBSSxPQUFPLEtBQUssY0FBTyxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsaUJBQWlCLEVBQUUsRUFBRTtZQUN2RCxJQUFJLENBQUMsUUFBUSxDQUFDO2dCQUNaLFVBQVUsRUFBRSxjQUFPLENBQUMsTUFBTTthQUMzQixDQUFDLENBQUM7U0FDSjthQUFNLElBQUksT0FBTyxLQUFLLGNBQU8sQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLGlCQUFpQixFQUFFLEVBQUU7WUFDaEUsSUFBSSxDQUFDLFFBQVEsQ0FBQztnQkFDWixVQUFVLEVBQUUsY0FBTyxDQUFDLFFBQVE7YUFDN0IsQ0FBQyxDQUFDO1NBQ0o7YUFBTSxJQUFJLE9BQU8sS0FBSyxjQUFPLENBQUMsV0FBVyxDQUFDLElBQUksQ0FBQyxpQkFBaUIsRUFBRSxFQUFFO1lBQ25FLElBQUksQ0FBQyxRQUFRLENBQUM7Z0JBQ1osVUFBVSxFQUFFLGNBQU8sQ0FBQyxXQUFXO2FBQ2hDLENBQUMsQ0FBQztTQUNKO0lBQ0gsQ0FBQztJQUNILHNCQUFDO0FBQUQsQ0FBQyxDQXJKb0MsS0FBSyxDQUFDLFNBQVMsR0FxSm5EO0FBckpZLDBDQUFlOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNiNUIsK0ZBQXFDO0FBQ3JDLGlGQUE4QjtBQUM5QixpRkFBOEI7QUFDOUIsaUZBQThCO0FBQzlCLHlGQUFrQzs7Ozs7Ozs7Ozs7O0FDSmxDLGU7Ozs7Ozs7Ozs7O0FDQUEsZTs7Ozs7Ozs7Ozs7QUNBQSxlOzs7Ozs7Ozs7OztBQ0FBLGUiLCJmaWxlIjoiZGVmYXVsdH5hcHB+YmV0YX5leGFtcGxlLmJ1bmRsZS5qcyIsInNvdXJjZXNDb250ZW50IjpbInZhciBtYXAgPSB7XG5cdFwiLi9icmFpbi5zZWxlY3RlZC5wbmdcIjogXCIuL25vZGVfbW9kdWxlcy9hbmF0b21vZ3JhbS9saWIvaW1nL2JyYWluLnNlbGVjdGVkLnBuZ1wiLFxuXHRcIi4vYnJhaW4udW5zZWxlY3RlZC5wbmdcIjogXCIuL25vZGVfbW9kdWxlcy9hbmF0b21vZ3JhbS9saWIvaW1nL2JyYWluLnVuc2VsZWN0ZWQucG5nXCIsXG5cdFwiLi9mZW1hbGUuc2VsZWN0ZWQucG5nXCI6IFwiLi9ub2RlX21vZHVsZXMvYW5hdG9tb2dyYW0vbGliL2ltZy9mZW1hbGUuc2VsZWN0ZWQucG5nXCIsXG5cdFwiLi9mZW1hbGUudW5zZWxlY3RlZC5wbmdcIjogXCIuL25vZGVfbW9kdWxlcy9hbmF0b21vZ3JhbS9saWIvaW1nL2ZlbWFsZS51bnNlbGVjdGVkLnBuZ1wiLFxuXHRcIi4vZmxvd2VyX3BhcnRzLnNlbGVjdGVkLnBuZ1wiOiBcIi4vbm9kZV9tb2R1bGVzL2FuYXRvbW9ncmFtL2xpYi9pbWcvZmxvd2VyX3BhcnRzLnNlbGVjdGVkLnBuZ1wiLFxuXHRcIi4vZmxvd2VyX3BhcnRzLnVuc2VsZWN0ZWQucG5nXCI6IFwiLi9ub2RlX21vZHVsZXMvYW5hdG9tb2dyYW0vbGliL2ltZy9mbG93ZXJfcGFydHMudW5zZWxlY3RlZC5wbmdcIixcblx0XCIuL21hbGUuc2VsZWN0ZWQucG5nXCI6IFwiLi9ub2RlX21vZHVsZXMvYW5hdG9tb2dyYW0vbGliL2ltZy9tYWxlLnNlbGVjdGVkLnBuZ1wiLFxuXHRcIi4vbWFsZS51bnNlbGVjdGVkLnBuZ1wiOiBcIi4vbm9kZV9tb2R1bGVzL2FuYXRvbW9ncmFtL2xpYi9pbWcvbWFsZS51bnNlbGVjdGVkLnBuZ1wiLFxuXHRcIi4vd2hvbGVfcGxhbnQuc2VsZWN0ZWQucG5nXCI6IFwiLi9ub2RlX21vZHVsZXMvYW5hdG9tb2dyYW0vbGliL2ltZy93aG9sZV9wbGFudC5zZWxlY3RlZC5wbmdcIixcblx0XCIuL3dob2xlX3BsYW50LnVuc2VsZWN0ZWQucG5nXCI6IFwiLi9ub2RlX21vZHVsZXMvYW5hdG9tb2dyYW0vbGliL2ltZy93aG9sZV9wbGFudC51bnNlbGVjdGVkLnBuZ1wiXG59O1xuXG5cbmZ1bmN0aW9uIHdlYnBhY2tDb250ZXh0KHJlcSkge1xuXHR2YXIgaWQgPSB3ZWJwYWNrQ29udGV4dFJlc29sdmUocmVxKTtcblx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oaWQpO1xufVxuZnVuY3Rpb24gd2VicGFja0NvbnRleHRSZXNvbHZlKHJlcSkge1xuXHR2YXIgaWQgPSBtYXBbcmVxXTtcblx0aWYoIShpZCArIDEpKSB7IC8vIGNoZWNrIGZvciBudW1iZXIgb3Igc3RyaW5nXG5cdFx0dmFyIGUgPSBuZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiICsgcmVxICsgXCInXCIpO1xuXHRcdGUuY29kZSA9ICdNT0RVTEVfTk9UX0ZPVU5EJztcblx0XHR0aHJvdyBlO1xuXHR9XG5cdHJldHVybiBpZDtcbn1cbndlYnBhY2tDb250ZXh0LmtleXMgPSBmdW5jdGlvbiB3ZWJwYWNrQ29udGV4dEtleXMoKSB7XG5cdHJldHVybiBPYmplY3Qua2V5cyhtYXApO1xufTtcbndlYnBhY2tDb250ZXh0LnJlc29sdmUgPSB3ZWJwYWNrQ29udGV4dFJlc29sdmU7XG5tb2R1bGUuZXhwb3J0cyA9IHdlYnBhY2tDb250ZXh0O1xud2VicGFja0NvbnRleHQuaWQgPSBcIi4vbm9kZV9tb2R1bGVzL2FuYXRvbW9ncmFtL2xpYi9pbWcgc3luYyByZWN1cnNpdmUgXlxcXFwuXFxcXC8uKnNlbGVjdGVkXFxcXC5wbmckXCI7IiwidmFyIG1hcCA9IHtcblx0XCIuL2Fub2xpc19jYXJvbGluZW5zaXMuc3ZnXCI6IFwiLi9ub2RlX21vZHVsZXMvYW5hdG9tb2dyYW0vbGliL3N2Zy9hbm9saXNfY2Fyb2xpbmVuc2lzLnN2Z1wiLFxuXHRcIi4vYXJhYmlkb3BzaXNfdGhhbGlhbmEuc3ZnXCI6IFwiLi9ub2RlX21vZHVsZXMvYW5hdG9tb2dyYW0vbGliL3N2Zy9hcmFiaWRvcHNpc190aGFsaWFuYS5zdmdcIixcblx0XCIuL2Jvc190YXVydXMuc3ZnXCI6IFwiLi9ub2RlX21vZHVsZXMvYW5hdG9tb2dyYW0vbGliL3N2Zy9ib3NfdGF1cnVzLnN2Z1wiLFxuXHRcIi4vYnJhY2h5cG9kaXVtX2Rpc3RhY2h5b24uZmxvd2VyX3BhcnRzLnN2Z1wiOiBcIi4vbm9kZV9tb2R1bGVzL2FuYXRvbW9ncmFtL2xpYi9zdmcvYnJhY2h5cG9kaXVtX2Rpc3RhY2h5b24uZmxvd2VyX3BhcnRzLnN2Z1wiLFxuXHRcIi4vYnJhY2h5cG9kaXVtX2Rpc3RhY2h5b24ud2hvbGVfcGxhbnQuc3ZnXCI6IFwiLi9ub2RlX21vZHVsZXMvYW5hdG9tb2dyYW0vbGliL3N2Zy9icmFjaHlwb2RpdW1fZGlzdGFjaHlvbi53aG9sZV9wbGFudC5zdmdcIixcblx0XCIuL2dhbGx1c19nYWxsdXMuc3ZnXCI6IFwiLi9ub2RlX21vZHVsZXMvYW5hdG9tb2dyYW0vbGliL3N2Zy9nYWxsdXNfZ2FsbHVzLnN2Z1wiLFxuXHRcIi4vaG9tb19zYXBpZW5zLmJyYWluLnN2Z1wiOiBcIi4vbm9kZV9tb2R1bGVzL2FuYXRvbW9ncmFtL2xpYi9zdmcvaG9tb19zYXBpZW5zLmJyYWluLnN2Z1wiLFxuXHRcIi4vaG9tb19zYXBpZW5zLmZlbWFsZS5zdmdcIjogXCIuL25vZGVfbW9kdWxlcy9hbmF0b21vZ3JhbS9saWIvc3ZnL2hvbW9fc2FwaWVucy5mZW1hbGUuc3ZnXCIsXG5cdFwiLi9ob21vX3NhcGllbnMubWFsZS5zdmdcIjogXCIuL25vZGVfbW9kdWxlcy9hbmF0b21vZ3JhbS9saWIvc3ZnL2hvbW9fc2FwaWVucy5tYWxlLnN2Z1wiLFxuXHRcIi4vaG9yZGV1bV92dWxnYXJlLmZsb3dlcl9wYXJ0cy5zdmdcIjogXCIuL25vZGVfbW9kdWxlcy9hbmF0b21vZ3JhbS9saWIvc3ZnL2hvcmRldW1fdnVsZ2FyZS5mbG93ZXJfcGFydHMuc3ZnXCIsXG5cdFwiLi9ob3JkZXVtX3Z1bGdhcmUud2hvbGVfcGxhbnQuc3ZnXCI6IFwiLi9ub2RlX21vZHVsZXMvYW5hdG9tb2dyYW0vbGliL3N2Zy9ob3JkZXVtX3Z1bGdhcmUud2hvbGVfcGxhbnQuc3ZnXCIsXG5cdFwiLi9tYWNhY2FfbXVsYXR0YS5zdmdcIjogXCIuL25vZGVfbW9kdWxlcy9hbmF0b21vZ3JhbS9saWIvc3ZnL21hY2FjYV9tdWxhdHRhLnN2Z1wiLFxuXHRcIi4vbW9ub2RlbHBoaXNfZG9tZXN0aWNhLnN2Z1wiOiBcIi4vbm9kZV9tb2R1bGVzL2FuYXRvbW9ncmFtL2xpYi9zdmcvbW9ub2RlbHBoaXNfZG9tZXN0aWNhLnN2Z1wiLFxuXHRcIi4vbXVzX211c2N1bHVzLmJyYWluLnN2Z1wiOiBcIi4vbm9kZV9tb2R1bGVzL2FuYXRvbW9ncmFtL2xpYi9zdmcvbXVzX211c2N1bHVzLmJyYWluLnN2Z1wiLFxuXHRcIi4vbXVzX211c2N1bHVzLmZlbWFsZS5zdmdcIjogXCIuL25vZGVfbW9kdWxlcy9hbmF0b21vZ3JhbS9saWIvc3ZnL211c19tdXNjdWx1cy5mZW1hbGUuc3ZnXCIsXG5cdFwiLi9tdXNfbXVzY3VsdXMubWFsZS5zdmdcIjogXCIuL25vZGVfbW9kdWxlcy9hbmF0b21vZ3JhbS9saWIvc3ZnL211c19tdXNjdWx1cy5tYWxlLnN2Z1wiLFxuXHRcIi4vb3J5emFfc2F0aXZhLmZsb3dlcl9wYXJ0cy5zdmdcIjogXCIuL25vZGVfbW9kdWxlcy9hbmF0b21vZ3JhbS9saWIvc3ZnL29yeXphX3NhdGl2YS5mbG93ZXJfcGFydHMuc3ZnXCIsXG5cdFwiLi9vcnl6YV9zYXRpdmEud2hvbGVfcGxhbnQuc3ZnXCI6IFwiLi9ub2RlX21vZHVsZXMvYW5hdG9tb2dyYW0vbGliL3N2Zy9vcnl6YV9zYXRpdmEud2hvbGVfcGxhbnQuc3ZnXCIsXG5cdFwiLi9wYXBpb19hbnViaXMuc3ZnXCI6IFwiLi9ub2RlX21vZHVsZXMvYW5hdG9tb2dyYW0vbGliL3N2Zy9wYXBpb19hbnViaXMuc3ZnXCIsXG5cdFwiLi9yYXR0dXNfbm9ydmVnaWN1cy5zdmdcIjogXCIuL25vZGVfbW9kdWxlcy9hbmF0b21vZ3JhbS9saWIvc3ZnL3JhdHR1c19ub3J2ZWdpY3VzLnN2Z1wiLFxuXHRcIi4vc29sYW51bV9seWNvcGVyc2ljdW0uZmxvd2VyX3BhcnRzLnN2Z1wiOiBcIi4vbm9kZV9tb2R1bGVzL2FuYXRvbW9ncmFtL2xpYi9zdmcvc29sYW51bV9seWNvcGVyc2ljdW0uZmxvd2VyX3BhcnRzLnN2Z1wiLFxuXHRcIi4vc29sYW51bV9seWNvcGVyc2ljdW0ud2hvbGVfcGxhbnQuc3ZnXCI6IFwiLi9ub2RlX21vZHVsZXMvYW5hdG9tb2dyYW0vbGliL3N2Zy9zb2xhbnVtX2x5Y29wZXJzaWN1bS53aG9sZV9wbGFudC5zdmdcIixcblx0XCIuL3NvbGFudW1fdHViZXJvc3VtLnN2Z1wiOiBcIi4vbm9kZV9tb2R1bGVzL2FuYXRvbW9ncmFtL2xpYi9zdmcvc29sYW51bV90dWJlcm9zdW0uc3ZnXCIsXG5cdFwiLi9zb3JnaHVtX2JpY29sb3IuZmxvd2VyX3BhcnRzLnN2Z1wiOiBcIi4vbm9kZV9tb2R1bGVzL2FuYXRvbW9ncmFtL2xpYi9zdmcvc29yZ2h1bV9iaWNvbG9yLmZsb3dlcl9wYXJ0cy5zdmdcIixcblx0XCIuL3NvcmdodW1fYmljb2xvci53aG9sZV9wbGFudC5zdmdcIjogXCIuL25vZGVfbW9kdWxlcy9hbmF0b21vZ3JhbS9saWIvc3ZnL3NvcmdodW1fYmljb2xvci53aG9sZV9wbGFudC5zdmdcIixcblx0XCIuL3RldHJhb2Rvbl9uaWdyb3ZpcmlkaXMuc3ZnXCI6IFwiLi9ub2RlX21vZHVsZXMvYW5hdG9tb2dyYW0vbGliL3N2Zy90ZXRyYW9kb25fbmlncm92aXJpZGlzLnN2Z1wiLFxuXHRcIi4vdHJpdGljdW1fYWVzdGl2dW0uZmxvd2VyX3BhcnRzLnN2Z1wiOiBcIi4vbm9kZV9tb2R1bGVzL2FuYXRvbW9ncmFtL2xpYi9zdmcvdHJpdGljdW1fYWVzdGl2dW0uZmxvd2VyX3BhcnRzLnN2Z1wiLFxuXHRcIi4vdHJpdGljdW1fYWVzdGl2dW0ud2hvbGVfcGxhbnQuc3ZnXCI6IFwiLi9ub2RlX21vZHVsZXMvYW5hdG9tb2dyYW0vbGliL3N2Zy90cml0aWN1bV9hZXN0aXZ1bS53aG9sZV9wbGFudC5zdmdcIixcblx0XCIuL3hlbm9wdXNfdHJvcGljYWxpcy5zdmdcIjogXCIuL25vZGVfbW9kdWxlcy9hbmF0b21vZ3JhbS9saWIvc3ZnL3hlbm9wdXNfdHJvcGljYWxpcy5zdmdcIixcblx0XCIuL3plYV9tYXlzLmZsb3dlcl9wYXJ0cy5zdmdcIjogXCIuL25vZGVfbW9kdWxlcy9hbmF0b21vZ3JhbS9saWIvc3ZnL3plYV9tYXlzLmZsb3dlcl9wYXJ0cy5zdmdcIixcblx0XCIuL3plYV9tYXlzLndob2xlX3BsYW50LnN2Z1wiOiBcIi4vbm9kZV9tb2R1bGVzL2FuYXRvbW9ncmFtL2xpYi9zdmcvemVhX21heXMud2hvbGVfcGxhbnQuc3ZnXCJcbn07XG5cblxuZnVuY3Rpb24gd2VicGFja0NvbnRleHQocmVxKSB7XG5cdHZhciBpZCA9IHdlYnBhY2tDb250ZXh0UmVzb2x2ZShyZXEpO1xuXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXyhpZCk7XG59XG5mdW5jdGlvbiB3ZWJwYWNrQ29udGV4dFJlc29sdmUocmVxKSB7XG5cdHZhciBpZCA9IG1hcFtyZXFdO1xuXHRpZighKGlkICsgMSkpIHsgLy8gY2hlY2sgZm9yIG51bWJlciBvciBzdHJpbmdcblx0XHR2YXIgZSA9IG5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIgKyByZXEgKyBcIidcIik7XG5cdFx0ZS5jb2RlID0gJ01PRFVMRV9OT1RfRk9VTkQnO1xuXHRcdHRocm93IGU7XG5cdH1cblx0cmV0dXJuIGlkO1xufVxud2VicGFja0NvbnRleHQua2V5cyA9IGZ1bmN0aW9uIHdlYnBhY2tDb250ZXh0S2V5cygpIHtcblx0cmV0dXJuIE9iamVjdC5rZXlzKG1hcCk7XG59O1xud2VicGFja0NvbnRleHQucmVzb2x2ZSA9IHdlYnBhY2tDb250ZXh0UmVzb2x2ZTtcbm1vZHVsZS5leHBvcnRzID0gd2VicGFja0NvbnRleHQ7XG53ZWJwYWNrQ29udGV4dC5pZCA9IFwiLi9ub2RlX21vZHVsZXMvYW5hdG9tb2dyYW0vbGliL3N2ZyBzeW5jIHJlY3Vyc2l2ZSBeXFxcXC5cXFxcLy4qXFxcXC5zdmckXCI7IiwiaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgSGFzaFJvdXRlciBhcyBSb3V0ZXIsIFJvdXRlLCBSb3V0ZUNvbXBvbmVudFByb3BzIH0gZnJvbSAncmVhY3Qtcm91dGVyLWRvbSc7XG5cbmltcG9ydCB7IENvbnRhaW5lciB9IGZyb20gJ3NlbWFudGljLXVpLXJlYWN0JztcblxuaW1wb3J0IHsgU2l0ZUhlYWRlciB9IGZyb20gJ35jaGVsbC12aXp+L2NvbnRhaW5lcic7XG5pbXBvcnQgeyBDaGVsbENvbnRleHRQcm92aWRlciB9IGZyb20gJ35jaGVsbC12aXp+L2NvbnRleHQnO1xuaW1wb3J0IHsgRGF0YXNldFBhZ2UsIExhbmRpbmdQYWdlLCBTdG9yaWVzUGFnZSwgVmlzdWFsaXphdGlvbnNQYWdlLCBWaXpPdmVydmlld1BhZ2UgfSBmcm9tICd+Y2hlbGwtdml6fi9wYWdlJztcblxuZXhwb3J0IGludGVyZmFjZSBJQ2hlbGxWaXpBcHBTdGF0ZSB7XG4gIGFjdGl2ZVZpc3VhbGl6YXRpb25zOiBudW1iZXI7XG59XG5cbmV4cG9ydCBjbGFzcyBDaGVsbFZpekFwcCBleHRlbmRzIFJlYWN0LkNvbXBvbmVudDxQYXJ0aWFsPFJvdXRlQ29tcG9uZW50UHJvcHM+LCBJQ2hlbGxWaXpBcHBTdGF0ZT4ge1xuICBjb25zdHJ1Y3Rvcihwcm9wczogUGFydGlhbDxSb3V0ZUNvbXBvbmVudFByb3BzPikge1xuICAgIHN1cGVyKHByb3BzKTtcbiAgICB0aGlzLnN0YXRlID0ge1xuICAgICAgYWN0aXZlVmlzdWFsaXphdGlvbnM6IDAsXG4gICAgfTtcbiAgfVxuXG4gIHB1YmxpYyBhc3luYyBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgIGFjdGl2ZVZpc3VhbGl6YXRpb25zOiAyLFxuICAgIH0pO1xuICB9XG5cbiAgcHVibGljIHJlbmRlcigpIHtcbiAgICByZXR1cm4gKFxuICAgICAgPFJvdXRlcj5cbiAgICAgICAgPFJvdXRlIHJlbmRlcj17dGhpcy5yZW5kZXJDb21wb25lbnRzfSAvPlxuICAgICAgPC9Sb3V0ZXI+XG4gICAgKTtcbiAgfVxuXG4gIHByb3RlY3RlZCByZW5kZXJDb21wb25lbnRzID0gKHByb3BzOiBSb3V0ZUNvbXBvbmVudFByb3BzKSA9PiAoXG4gICAgPENoZWxsQ29udGV4dFByb3ZpZGVyIHsuLi5wcm9wc30+XG4gICAgICA8Q29udGFpbmVyIGlkPXsnQ2hlbGxWaXpBcHAnfSBmbHVpZD17dHJ1ZX0+XG4gICAgICAgIDxTaXRlSGVhZGVyIHsuLi5wcm9wc30gLz5cbiAgICAgICAgPFJvdXRlIGV4YWN0PXt0cnVlfSBzdHJpY3Q9e3RydWV9IHBhdGg9eycvdmlzdWFsaXphdGlvbnMnfSByZW5kZXI9e3RoaXMucmVuZGVyVmlzdWFsaXphdGlvbnNQYWdlfSAvPlxuICAgICAgICA8Um91dGUgZXhhY3Q9e3RydWV9IHN0cmljdD17dHJ1ZX0gcGF0aD17Jy92aXN1YWxpemF0aW9ucy8nfSByZW5kZXI9e3RoaXMucmVuZGVyT3ZlcnZpZXdQYWdlfSAvPlxuICAgICAgICA8Um91dGUgcGF0aD17Jy9kYXRhc2V0J30gcmVuZGVyPXt0aGlzLnJlbmRlckRhdGFzZXRQYWdlfSAvPlxuICAgICAgICA8Um91dGUgcGF0aD17Jy9zdG9yaWVzJ30gcmVuZGVyPXt0aGlzLnJlbmRlclN0b3JpZXNQYWdlfSAvPlxuICAgICAgICA8Um91dGUgZXhhY3Q9e3RydWV9IHBhdGg9eycvJ30gcmVuZGVyPXt0aGlzLnJlbmRlckxhbmRpbmdQYWdlfSAvPlxuICAgICAgPC9Db250YWluZXI+XG4gICAgPC9DaGVsbENvbnRleHRQcm92aWRlcj5cbiAgKTtcblxuICBwcm90ZWN0ZWQgcmVuZGVyVmlzdWFsaXphdGlvbnNQYWdlID0gKHByb3BzOiBSb3V0ZUNvbXBvbmVudFByb3BzKSA9PiB7XG4gICAgcmV0dXJuIDxWaXN1YWxpemF0aW9uc1BhZ2Ugey4uLnByb3BzfSAvPjtcbiAgfTtcblxuICBwcm90ZWN0ZWQgcmVuZGVyRGF0YXNldFBhZ2UgPSAocHJvcHM6IFJvdXRlQ29tcG9uZW50UHJvcHMpID0+IHtcbiAgICByZXR1cm4gPERhdGFzZXRQYWdlIHsuLi5wcm9wc30gLz47XG4gIH07XG5cbiAgcHJvdGVjdGVkIHJlbmRlckxhbmRpbmdQYWdlID0gKHByb3BzOiBSb3V0ZUNvbXBvbmVudFByb3BzKSA9PiB7XG4gICAgcmV0dXJuIDxMYW5kaW5nUGFnZSB7Li4ucHJvcHN9IC8+O1xuICB9O1xuXG4gIHByb3RlY3RlZCByZW5kZXJPdmVydmlld1BhZ2UgPSAocHJvcHM6IFJvdXRlQ29tcG9uZW50UHJvcHMpID0+IHtcbiAgICByZXR1cm4gPFZpek92ZXJ2aWV3UGFnZSB7Li4ucHJvcHN9IC8+O1xuICB9O1xuXG4gIHByb3RlY3RlZCByZW5kZXJTdG9yaWVzUGFnZSA9IChwcm9wczogUm91dGVDb21wb25lbnRQcm9wcykgPT4ge1xuICAgIHJldHVybiA8U3Rvcmllc1BhZ2Ugey4uLnByb3BzfSAvPjtcbiAgfTtcbn1cbiIsImltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IERpbW1lciwgTG9hZGVyIH0gZnJvbSAnc2VtYW50aWMtdWktcmVhY3QnO1xuXG5pbXBvcnQge1xuICBDb250YWN0TWFwQ2hhcnQsXG4gIGdlbmVyYXRlQ2hhcnREYXRhRW50cnksXG4gIElDb250YWN0TWFwQ2hhcnREYXRhLFxuICBJQ29udGFjdE1hcENoYXJ0UG9pbnQsXG59IGZyb20gJ35jaGVsbC12aXp+L2NvbXBvbmVudCc7XG5pbXBvcnQge1xuICBpbml0aWFsUmVzaWR1ZUNvbnRleHQsXG4gIGluaXRpYWxTZWNvbmRhcnlTdHJ1Y3R1cmVDb250ZXh0LFxuICBJUmVzaWR1ZUNvbnRleHQsXG4gIElTZWNvbmRhcnlTdHJ1Y3R1cmVDb250ZXh0LFxuICBSZXNpZHVlQ29udGV4dENvbnN1bWVyLFxuICBTZWNvbmRhcnlTdHJ1Y3R1cmVDb250ZXh0Q29uc3VtZXIsXG59IGZyb20gJ35jaGVsbC12aXp+L2NvbnRleHQnO1xuaW1wb3J0IHtcbiAgQ0hFTExfQ1NTX1NUWUxFLFxuICBDaGVsbENoYXJ0RXZlbnQsXG4gIENoZWxsV2lkZ2V0Q29uZmlnLFxuICBDT05GSUdVUkFUSU9OX0NPTVBPTkVOVF9UWVBFLFxuICBDb3VwbGluZ0NvbnRhaW5lcixcbiAgSUNvbnRhY3RNYXBEYXRhLFxuICBJQ291cGxpbmdTY29yZSxcbiAgUkVTSURVRV9UWVBFLFxuICBTRUNPTkRBUllfU1RSVUNUVVJFLFxuICBTbGlkZXJXaWRnZXRDb25maWcsXG59IGZyb20gJ35jaGVsbC12aXp+L2RhdGEnO1xuXG5leHBvcnQgdHlwZSBDT05UQUNUX01BUF9DQl9SRVNVTFRfVFlQRSA9IElDb3VwbGluZ1Njb3JlO1xuZXhwb3J0IHR5cGUgQ29udGFjdE1hcENhbGxiYWNrID0gKGNvdXBsaW5nOiBDT05UQUNUX01BUF9DQl9SRVNVTFRfVFlQRSkgPT4gdm9pZDtcblxuZXhwb3J0IGludGVyZmFjZSBJQ29udGFjdE1hcFByb3BzIHtcbiAgY29uZmlndXJhdGlvbnM6IENoZWxsV2lkZ2V0Q29uZmlnW107XG4gIGRhdGE6IElDb250YWN0TWFwRGF0YTtcbiAgZm9ybWF0dGVkUG9pbnRzOiBJQ29udGFjdE1hcENoYXJ0RGF0YVtdO1xuICBoZWlnaHQ6IG51bWJlciB8IHN0cmluZztcbiAgaGlnaGxpZ2h0Q29sb3I6IHN0cmluZztcbiAgaXNEYXRhTG9hZGluZzogYm9vbGVhbjtcbiAgb2JzZXJ2ZWRDb2xvcjogc3RyaW5nO1xuICBvbkJveFNlbGVjdGlvbj86ICgocmVzaWR1ZXM6IFJFU0lEVUVfVFlQRVtdKSA9PiB2b2lkKTtcbiAgcmVzaWR1ZUNvbnRleHQ6IElSZXNpZHVlQ29udGV4dDtcbiAgc2Vjb25kYXJ5U3RydWN0dXJlQ29udGV4dDogSVNlY29uZGFyeVN0cnVjdHVyZUNvbnRleHQ7XG4gIHNob3dDb25maWd1cmF0aW9uczogYm9vbGVhbjtcbiAgc3R5bGU/OiBDSEVMTF9DU1NfU1RZTEU7XG4gIHdpZHRoOiBudW1iZXIgfCBzdHJpbmc7XG59XG5cbmV4cG9ydCBjb25zdCBpbml0aWFsQ29udGFjdE1hcFN0YXRlID0ge1xuICBwb2ludHNUb1Bsb3Q6IG5ldyBBcnJheTxJQ29udGFjdE1hcENoYXJ0RGF0YT4oKSxcbn07XG5cbmV4cG9ydCB0eXBlIENvbnRhY3RNYXBTdGF0ZSA9IFJlYWRvbmx5PHR5cGVvZiBpbml0aWFsQ29udGFjdE1hcFN0YXRlPjtcblxuZXhwb3J0IGNsYXNzIENvbnRhY3RNYXBDbGFzcyBleHRlbmRzIFJlYWN0LkNvbXBvbmVudDxJQ29udGFjdE1hcFByb3BzLCBDb250YWN0TWFwU3RhdGU+IHtcbiAgcHVibGljIHN0YXRpYyBkZWZhdWx0UHJvcHMgPSB7XG4gICAgY29uZmlndXJhdGlvbnM6IG5ldyBBcnJheTxDaGVsbFdpZGdldENvbmZpZz4oKSxcbiAgICBkYXRhOiB7XG4gICAgICBjb3VwbGluZ1Njb3JlczogbmV3IENvdXBsaW5nQ29udGFpbmVyKCksXG4gICAgICBzZWNvbmRhcnlTdHJ1Y3R1cmVzOiBuZXcgQXJyYXk8U0VDT05EQVJZX1NUUlVDVFVSRT4oKSxcbiAgICB9LFxuICAgIGVuYWJsZVNsaWRlcnM6IHRydWUsXG4gICAgZm9ybWF0dGVkUG9pbnRzOiBuZXcgQXJyYXk8SUNvbnRhY3RNYXBDaGFydERhdGE+KCksXG4gICAgaGVpZ2h0OiAnMTAwJScsXG4gICAgaGlnaGxpZ2h0Q29sb3I6ICcjZmY4ODAwJyxcbiAgICBpc0RhdGFMb2FkaW5nOiBmYWxzZSxcbiAgICBvYnNlcnZlZENvbG9yOiAnIzAwMDBmZicsXG4gICAgcmVzaWR1ZUNvbnRleHQ6IHtcbiAgICAgIC4uLmluaXRpYWxSZXNpZHVlQ29udGV4dCxcbiAgICB9LFxuICAgIHNlY29uZGFyeVN0cnVjdHVyZUNvbnRleHQ6IHtcbiAgICAgIC4uLmluaXRpYWxTZWNvbmRhcnlTdHJ1Y3R1cmVDb250ZXh0LFxuICAgIH0sXG4gICAgc2hvd0NvbmZpZ3VyYXRpb25zOiB0cnVlLFxuICAgIHdpZHRoOiAnMTAwJScsXG4gIH07XG5cbiAgcHVibGljIHJlYWRvbmx5IHN0YXRlOiBDb250YWN0TWFwU3RhdGUgPSBpbml0aWFsQ29udGFjdE1hcFN0YXRlO1xuXG4gIGNvbnN0cnVjdG9yKHByb3BzOiBJQ29udGFjdE1hcFByb3BzKSB7XG4gICAgc3VwZXIocHJvcHMpO1xuICB9XG5cbiAgcHVibGljIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgIHRoaXMuc2V0dXBQb2ludHNUb1Bsb3QodGhpcy5wcm9wcy5kYXRhLmNvdXBsaW5nU2NvcmVzKTtcbiAgfVxuXG4gIHB1YmxpYyBjb21wb25lbnREaWRVcGRhdGUocHJldlByb3BzOiBJQ29udGFjdE1hcFByb3BzKSB7XG4gICAgY29uc3QgeyBkYXRhLCByZXNpZHVlQ29udGV4dCB9ID0gdGhpcy5wcm9wcztcbiAgICBpZiAoZGF0YSAhPT0gcHJldlByb3BzLmRhdGEgfHwgcmVzaWR1ZUNvbnRleHQubG9ja2VkUmVzaWR1ZVBhaXJzICE9PSBwcmV2UHJvcHMucmVzaWR1ZUNvbnRleHQubG9ja2VkUmVzaWR1ZVBhaXJzKSB7XG4gICAgICB0aGlzLnNldHVwUG9pbnRzVG9QbG90KGRhdGEuY291cGxpbmdTY29yZXMpO1xuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyByZW5kZXIoKSB7XG4gICAgY29uc3QgeyBjb25maWd1cmF0aW9ucywgaXNEYXRhTG9hZGluZywgcmVzaWR1ZUNvbnRleHQsIHN0eWxlIH0gPSB0aGlzLnByb3BzO1xuICAgIGNvbnN0IHsgcG9pbnRzVG9QbG90IH0gPSB0aGlzLnN0YXRlO1xuXG4gICAgcmV0dXJuIChcbiAgICAgIDxkaXYgY2xhc3NOYW1lPVwiQ29udGFjdE1hcENvbXBvbmVudFwiIHN0eWxlPXt7IC4uLnN0eWxlIH19PlxuICAgICAgICA8RGltbWVyLkRpbW1hYmxlIGRpbW1lZD17dHJ1ZX0+XG4gICAgICAgICAgPERpbW1lciBhY3RpdmU9e2lzRGF0YUxvYWRpbmd9PlxuICAgICAgICAgICAgPExvYWRlciAvPlxuICAgICAgICAgIDwvRGltbWVyPlxuXG4gICAgICAgICAge3RoaXMucmVuZGVyQ29udGFjdE1hcENoYXJ0KHBvaW50c1RvUGxvdCwgW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBuYW1lOiAnQ2xlYXIgU2VsZWN0aW9ucycsXG4gICAgICAgICAgICAgIG9uQ2xpY2s6IHJlc2lkdWVDb250ZXh0LnJlbW92ZUFsbExvY2tlZFJlc2lkdWVQYWlycyxcbiAgICAgICAgICAgICAgdHlwZTogQ09ORklHVVJBVElPTl9DT01QT05FTlRfVFlQRS5CVVRUT04sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgLi4uY29uZmlndXJhdGlvbnMsXG4gICAgICAgICAgICAuLi50aGlzLmdlbmVyYXRlTm9kZVNpemVTbGlkZXJDb25maWdzKHBvaW50c1RvUGxvdCksXG4gICAgICAgICAgXSl9XG4gICAgICAgIDwvRGltbWVyLkRpbW1hYmxlPlxuICAgICAgPC9kaXY+XG4gICAgKTtcbiAgfVxuXG4gIHB1YmxpYyBvbk5vZGVTaXplQ2hhbmdlID0gKGluZGV4OiBudW1iZXIpID0+ICh2YWx1ZTogbnVtYmVyKSA9PiB7XG4gICAgY29uc3QgeyBwb2ludHNUb1Bsb3QgfSA9IHRoaXMuc3RhdGU7XG5cbiAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgIHBvaW50c1RvUGxvdDogW1xuICAgICAgICAuLi5wb2ludHNUb1Bsb3Quc2xpY2UoMCwgaW5kZXgpLFxuICAgICAgICB7XG4gICAgICAgICAgLi4ucG9pbnRzVG9QbG90W2luZGV4XSxcbiAgICAgICAgICBub2RlU2l6ZTogdmFsdWUsXG4gICAgICAgIH0sXG4gICAgICAgIC4uLnBvaW50c1RvUGxvdC5zbGljZShpbmRleCArIDEpLFxuICAgICAgXSxcbiAgICB9KTtcbiAgfTtcblxuICBwcm90ZWN0ZWQgc2V0dXBQb2ludHNUb1Bsb3QoY291cGxpbmdDb250YWluZXI6IENvdXBsaW5nQ29udGFpbmVyKSB7XG4gICAgY29uc3QgeyBmb3JtYXR0ZWRQb2ludHMsIG9ic2VydmVkQ29sb3IsIGhpZ2hsaWdodENvbG9yLCByZXNpZHVlQ29udGV4dCB9ID0gdGhpcy5wcm9wcztcbiAgICBjb25zdCB7IHBvaW50c1RvUGxvdCB9ID0gdGhpcy5zdGF0ZTtcblxuICAgIGNvbnN0IGNoYXJ0TmFtZXMgPSB7XG4gICAgICBrbm93bjogJ0tub3duIFN0cnVjdHVyZSBDb250YWN0JyxcbiAgICAgIHNlbGVjdGVkOiAnU2VsZWN0ZWQgUmVzaWR1ZSBQYWlycycsXG4gICAgfTtcblxuICAgIGNvbnN0IGtub3duUG9pbnRzSW5kZXggPSBwb2ludHNUb1Bsb3QuZmluZEluZGV4KGVudHJ5ID0+IGVudHJ5Lm5hbWUgPT09IGNoYXJ0TmFtZXMua25vd24pO1xuICAgIGNvbnN0IHNlbGVjdGVkUG9pbnRJbmRleCA9IHBvaW50c1RvUGxvdC5maW5kSW5kZXgoZW50cnkgPT4gZW50cnkubmFtZSA9PT0gY2hhcnROYW1lcy5zZWxlY3RlZCk7XG5cbiAgICBjb25zdCBvYnNlcnZlZENvbnRhY3RQb2ludHMgPSBjb3VwbGluZ0NvbnRhaW5lci5nZXRPYnNlcnZlZENvbnRhY3RzKCk7XG4gICAgY29uc3QgcmVzdWx0ID0gbmV3IEFycmF5PElDb250YWN0TWFwQ2hhcnREYXRhPihcbiAgICAgIGdlbmVyYXRlQ2hhcnREYXRhRW50cnkoXG4gICAgICAgICd0ZXh0JyxcbiAgICAgICAgeyBzdGFydDogb2JzZXJ2ZWRDb2xvciwgZW5kOiAncmdiKDEwMCwxNzcsMjAwKScgfSxcbiAgICAgICAgY2hhcnROYW1lcy5rbm93bixcbiAgICAgICAgJyhmcm9tIFBEQiBzdHJ1Y3R1cmUpJyxcbiAgICAgICAga25vd25Qb2ludHNJbmRleCA+PSAwID8gcG9pbnRzVG9QbG90W2tub3duUG9pbnRzSW5kZXhdLm5vZGVTaXplIDogNCxcbiAgICAgICAgb2JzZXJ2ZWRDb250YWN0UG9pbnRzLFxuICAgICAgICB7XG4gICAgICAgICAgdGV4dDogb2JzZXJ2ZWRDb250YWN0UG9pbnRzLm1hcChwb2ludCA9PiB7XG4gICAgICAgICAgICBjb25zdCBzY29yZSA9IGNvdXBsaW5nQ29udGFpbmVyLmdldENvdXBsaW5nU2NvcmUocG9pbnQuaSwgcG9pbnQuaik7XG5cbiAgICAgICAgICAgIHJldHVybiBzY29yZSAmJiBzY29yZS5BX2kgJiYgc2NvcmUuQV9qXG4gICAgICAgICAgICAgID8gYCgke3BvaW50Lml9JHtzY29yZS5BX2l9LCAke3BvaW50Lmp9JHtzY29yZS5BX2p9KWBcbiAgICAgICAgICAgICAgOiBgKCR7cG9pbnQuaX0sICR7cG9pbnQuan0pYDtcbiAgICAgICAgICB9KSxcbiAgICAgICAgfSxcbiAgICAgICksXG4gICAgICAuLi5mb3JtYXR0ZWRQb2ludHMsXG4gICAgKTtcblxuICAgIGNvbnN0IHsgbG9ja2VkUmVzaWR1ZVBhaXJzLCBob3ZlcmVkUmVzaWR1ZXMgfSA9IHJlc2lkdWVDb250ZXh0O1xuXG4gICAgY29uc3QgY2hhcnRQb2ludHMgPSBuZXcgQXJyYXk8SUNvbnRhY3RNYXBDaGFydFBvaW50PigpO1xuXG4gICAgaWYgKGhvdmVyZWRSZXNpZHVlcy5sZW5ndGggPj0gMSkge1xuICAgICAgY2hhcnRQb2ludHMucHVzaCh7XG4gICAgICAgIGk6IGhvdmVyZWRSZXNpZHVlc1swXSxcbiAgICAgICAgajogaG92ZXJlZFJlc2lkdWVzLmxlbmd0aCA9PT0gMSA/IGhvdmVyZWRSZXNpZHVlc1swXSA6IGhvdmVyZWRSZXNpZHVlc1sxXSxcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmIChsb2NrZWRSZXNpZHVlUGFpcnMuc2l6ZSA+PSAxKSB7XG4gICAgICBjaGFydFBvaW50cy5wdXNoKFxuICAgICAgICAuLi5BcnJheS5mcm9tKGxvY2tlZFJlc2lkdWVQYWlycy5rZXlzKCkpLnJlZHVjZSgocmVkdWNlUmVzdWx0OiBJQ29udGFjdE1hcENoYXJ0UG9pbnRbXSwga2V5KSA9PiB7XG4gICAgICAgICAgY29uc3Qga2V5UGFpciA9IGxvY2tlZFJlc2lkdWVQYWlycy5nZXQoa2V5KTtcbiAgICAgICAgICBpZiAoa2V5UGFpciAmJiBrZXlQYWlyLmxlbmd0aCA9PT0gMikge1xuICAgICAgICAgICAgcmVkdWNlUmVzdWx0LnB1c2goeyBpOiBrZXlQYWlyWzBdLCBqOiBrZXlQYWlyWzFdLCBkaXN0OiAwIH0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiByZWR1Y2VSZXN1bHQ7XG4gICAgICAgIH0sIG5ldyBBcnJheTxJQ29udGFjdE1hcENoYXJ0UG9pbnQ+KCkpLFxuICAgICAgKTtcbiAgICB9XG5cbiAgICByZXN1bHQucHVzaChcbiAgICAgIGdlbmVyYXRlQ2hhcnREYXRhRW50cnkoXG4gICAgICAgICdub25lJyxcbiAgICAgICAgaGlnaGxpZ2h0Q29sb3IsXG4gICAgICAgIGNoYXJ0TmFtZXMuc2VsZWN0ZWQsXG4gICAgICAgICcnLFxuICAgICAgICBzZWxlY3RlZFBvaW50SW5kZXggPj0gMCA/IHBvaW50c1RvUGxvdFtzZWxlY3RlZFBvaW50SW5kZXhdLm5vZGVTaXplIDogNixcbiAgICAgICAgY2hhcnRQb2ludHMsXG4gICAgICAgIHtcbiAgICAgICAgICBtYXJrZXI6IHtcbiAgICAgICAgICAgIGNvbG9yOiBuZXcgQXJyYXk8c3RyaW5nPihjaGFydFBvaW50cy5sZW5ndGggKiAyKS5maWxsKGhpZ2hsaWdodENvbG9yKSxcbiAgICAgICAgICAgIGxpbmU6IHtcbiAgICAgICAgICAgICAgY29sb3I6IGhpZ2hsaWdodENvbG9yLFxuICAgICAgICAgICAgICB3aWR0aDogMyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzeW1ib2w6ICdjaXJjbGUtb3BlbicsXG4gICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICAgICksXG4gICAgKTtcblxuICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgLi4udGhpcy5zdGF0ZSxcbiAgICAgIHBvaW50c1RvUGxvdDogWy4uLnJlc3VsdF0sXG4gICAgfSk7XG4gIH1cblxuICBwcm90ZWN0ZWQgcmVuZGVyQ29udGFjdE1hcENoYXJ0KHBvaW50c1RvUGxvdDogSUNvbnRhY3RNYXBDaGFydERhdGFbXSwgY29uZmlndXJhdGlvbnM6IENoZWxsV2lkZ2V0Q29uZmlnW10pIHtcbiAgICBjb25zdCB7XG4gICAgICBkYXRhLFxuICAgICAgaGVpZ2h0LFxuICAgICAgb25Cb3hTZWxlY3Rpb24sXG4gICAgICByZXNpZHVlQ29udGV4dCxcbiAgICAgIHNob3dDb25maWd1cmF0aW9ucyxcbiAgICAgIHNlY29uZGFyeVN0cnVjdHVyZUNvbnRleHQsXG4gICAgICB3aWR0aCxcbiAgICB9ID0gdGhpcy5wcm9wcztcblxuICAgIHJldHVybiAoXG4gICAgICA8Q29udGFjdE1hcENoYXJ0XG4gICAgICAgIGNhbmRpZGF0ZVJlc2lkdWVzPXtyZXNpZHVlQ29udGV4dC5jYW5kaWRhdGVSZXNpZHVlc31cbiAgICAgICAgY29uZmlndXJhdGlvbnM9e2NvbmZpZ3VyYXRpb25zfVxuICAgICAgICBjb250YWN0RGF0YT17cG9pbnRzVG9QbG90fVxuICAgICAgICBoZWlnaHQ9e2hlaWdodH1cbiAgICAgICAgb25DbGlja0NhbGxiYWNrPXt0aGlzLm9uTW91c2VDbGljayhyZXNpZHVlQ29udGV4dC50b2dnbGVMb2NrZWRSZXNpZHVlUGFpcil9XG4gICAgICAgIG9uSG92ZXJDYWxsYmFjaz17dGhpcy5vbk1vdXNlRW50ZXIocmVzaWR1ZUNvbnRleHQuYWRkSG92ZXJlZFJlc2lkdWVzKX1cbiAgICAgICAgb25TZWxlY3RlZENhbGxiYWNrPXt0aGlzLm9uTW91c2VTZWxlY3Qob25Cb3hTZWxlY3Rpb24pfVxuICAgICAgICBvblVuSG92ZXJDYWxsYmFjaz17dGhpcy5vbk1vdXNlTGVhdmUocmVzaWR1ZUNvbnRleHQucmVtb3ZlSG92ZXJlZFJlc2lkdWVzKX1cbiAgICAgICAgcmFuZ2U9e2RhdGEuY291cGxpbmdTY29yZXMucmVzaWR1ZUluZGV4UmFuZ2UubWF4ICsgMjB9XG4gICAgICAgIHNlY29uZGFyeVN0cnVjdHVyZXM9e2RhdGEucGRiRGF0YSA/IGRhdGEucGRiRGF0YS5zZWNvbmRhcnlTdHJ1Y3R1cmVTZWN0aW9ucyA6IFtdfVxuICAgICAgICBzaG93Q29uZmlndXJhdGlvbnM9e3Nob3dDb25maWd1cmF0aW9uc31cbiAgICAgICAgc2VsZWN0ZWRTZWNvbmRhcnlTdHJ1Y3R1cmVzPXtbc2Vjb25kYXJ5U3RydWN0dXJlQ29udGV4dC5zZWxlY3RlZFNlY29uZGFyeVN0cnVjdHVyZXNdfVxuICAgICAgICB3aWR0aD17d2lkdGh9XG4gICAgICAvPlxuICAgICk7XG4gIH1cblxuICBwcm90ZWN0ZWQgZ2VuZXJhdGVOb2RlU2l6ZVNsaWRlckNvbmZpZ3MgPSAoZW50cmllczogSUNvbnRhY3RNYXBDaGFydERhdGFbXSkgPT5cbiAgICBlbnRyaWVzLm1hcChcbiAgICAgIChlbnRyeSwgaW5kZXgpOiBTbGlkZXJXaWRnZXRDb25maWcgPT4ge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGlkOiBgbm9kZS1zaXplLXNsaWRlci0ke2luZGV4fWAsXG4gICAgICAgICAgbmFtZTogYE5vZGUgc2l6ZSBmb3IgJHtlbnRyeS5uYW1lfWAsXG4gICAgICAgICAgb25DaGFuZ2U6IHRoaXMub25Ob2RlU2l6ZUNoYW5nZShpbmRleCksXG4gICAgICAgICAgdHlwZTogQ09ORklHVVJBVElPTl9DT01QT05FTlRfVFlQRS5TTElERVIsXG4gICAgICAgICAgdmFsdWVzOiB7XG4gICAgICAgICAgICBjdXJyZW50OiBlbnRyeS5ub2RlU2l6ZSxcbiAgICAgICAgICAgIG1heDogMjAsXG4gICAgICAgICAgICBtaW46IDEsXG4gICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICAgIH0sXG4gICAgKTtcblxuICBwcm90ZWN0ZWQgb25Nb3VzZUVudGVyID0gKGNiOiAocmVzaWR1ZTogUkVTSURVRV9UWVBFW10pID0+IHZvaWQpID0+IChlOiBDaGVsbENoYXJ0RXZlbnQpID0+IHtcbiAgICBpZiAoZS5pc0F4aXMoKSkge1xuICAgICAgY29uc3QgeyBzZWNvbmRhcnlTdHJ1Y3R1cmVDb250ZXh0LCBkYXRhIH0gPSB0aGlzLnByb3BzO1xuXG4gICAgICBmb3IgKGNvbnN0IHNlY29uZGFyeVN0cnVjdHVyZSBvZiBkYXRhLnNlY29uZGFyeVN0cnVjdHVyZXMpIHtcbiAgICAgICAgZm9yIChjb25zdCBzZWN0aW9uIG9mIHNlY29uZGFyeVN0cnVjdHVyZSkge1xuICAgICAgICAgIGlmIChzZWN0aW9uLmNvbnRhaW5zKC4uLmUuc2VsZWN0ZWRQb2ludHMpKSB7XG4gICAgICAgICAgICBzZWNvbmRhcnlTdHJ1Y3R1cmVDb250ZXh0LmFkZEhvdmVyZWRTZWNvbmRhcnlTdHJ1Y3R1cmUoc2VjdGlvbik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNiKGUuc2VsZWN0ZWRQb2ludHMpO1xuICAgIH1cbiAgfTtcblxuICBwcm90ZWN0ZWQgb25Nb3VzZUxlYXZlID0gKGNiPzogKHJlc2lkdWU6IFJFU0lEVUVfVFlQRVtdKSA9PiB2b2lkKSA9PiAoZTogQ2hlbGxDaGFydEV2ZW50KSA9PiB7XG4gICAgaWYgKGUuaXNBeGlzKCkpIHtcbiAgICAgIGNvbnN0IHsgZGF0YSwgc2Vjb25kYXJ5U3RydWN0dXJlQ29udGV4dCB9ID0gdGhpcy5wcm9wcztcblxuICAgICAgZm9yIChjb25zdCBzZWNvbmRhcnlTdHJ1Y3R1cmUgb2YgZGF0YS5zZWNvbmRhcnlTdHJ1Y3R1cmVzKSB7XG4gICAgICAgIGZvciAoY29uc3Qgc2VjdGlvbiBvZiBzZWNvbmRhcnlTdHJ1Y3R1cmUpIHtcbiAgICAgICAgICBpZiAoc2VjdGlvbi5jb250YWlucyguLi5lLnNlbGVjdGVkUG9pbnRzKSkge1xuICAgICAgICAgICAgc2Vjb25kYXJ5U3RydWN0dXJlQ29udGV4dC5yZW1vdmVIb3ZlcmVkU2Vjb25kYXJ5U3RydWN0dXJlKHNlY3Rpb24pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoY2IpIHtcbiAgICAgIGNiKGUuc2VsZWN0ZWRQb2ludHMpO1xuICAgIH1cbiAgfTtcblxuICBwcm90ZWN0ZWQgb25Nb3VzZUNsaWNrID0gKGNiOiAocmVzaWR1ZXM6IFJFU0lEVUVfVFlQRVtdKSA9PiB2b2lkKSA9PiAoZTogQ2hlbGxDaGFydEV2ZW50KSA9PiB7XG4gICAgaWYgKGUuaXNBeGlzKCkpIHtcbiAgICAgIGNvbnN0IHsgZGF0YSwgc2Vjb25kYXJ5U3RydWN0dXJlQ29udGV4dCB9ID0gdGhpcy5wcm9wcztcblxuICAgICAgZm9yIChjb25zdCBzZWNvbmRhcnlTdHJ1Y3R1cmUgb2YgZGF0YS5zZWNvbmRhcnlTdHJ1Y3R1cmVzKSB7XG4gICAgICAgIGZvciAoY29uc3Qgc2VjdGlvbiBvZiBzZWNvbmRhcnlTdHJ1Y3R1cmUpIHtcbiAgICAgICAgICBpZiAoc2VjdGlvbi5jb250YWlucyguLi5lLnNlbGVjdGVkUG9pbnRzKSkge1xuICAgICAgICAgICAgaWYgKHNlY29uZGFyeVN0cnVjdHVyZUNvbnRleHQuc2VsZWN0ZWRTZWNvbmRhcnlTdHJ1Y3R1cmVzLmluY2x1ZGVzKHNlY3Rpb24pKSB7XG4gICAgICAgICAgICAgIHNlY29uZGFyeVN0cnVjdHVyZUNvbnRleHQucmVtb3ZlU2Vjb25kYXJ5U3RydWN0dXJlKHNlY3Rpb24pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgc2Vjb25kYXJ5U3RydWN0dXJlQ29udGV4dC5hZGRTZWxlY3RlZFNlY29uZGFyeVN0cnVjdHVyZShzZWN0aW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY2IoZS5zZWxlY3RlZFBvaW50cyk7XG4gICAgfVxuICB9O1xuXG4gIHByb3RlY3RlZCBvbk1vdXNlU2VsZWN0ID0gKGNiPzogKHJlc2lkdWVzOiBSRVNJRFVFX1RZUEVbXSkgPT4gdm9pZCkgPT4gKGU6IENoZWxsQ2hhcnRFdmVudCkgPT4ge1xuICAgIGlmIChjYikge1xuICAgICAgLy8gRm9yIHRoZSBjb250YWN0IG1hcCwgYWxsIHRoZSB4L3kgdmFsdWVzIGFyZSBtaXJyb3JlZCBhbmQgY29ycmVzcG9uZCBkaXJlY3RseSB3aXRoIGkvaiB2YWx1ZXMuXG4gICAgICAvLyBUaHVzLCBhbGwgdGhlIHJlc2lkdWUgbnVtYmVycyBjYW4gYmUgb2J0YWluZWQgYnkgZ2V0dGluZyBlaXRoZXIgYWxsIHggb3IgdmFsdWVzIGZyb20gdGhzIHNlbGVjdGVkIHBvaW50cy5cbiAgICAgIGNiKGUuc2VsZWN0ZWRQb2ludHMubWFwKHBvaW50ID0+IHBvaW50KSk7XG4gICAgfVxuICB9O1xufVxuXG50eXBlIHJlcXVpcmVkUHJvcHMgPSBPbWl0PElDb250YWN0TWFwUHJvcHMsIGtleW9mIHR5cGVvZiBDb250YWN0TWFwQ2xhc3MuZGVmYXVsdFByb3BzPiAmIFBhcnRpYWw8SUNvbnRhY3RNYXBQcm9wcz47XG5cbmNvbnN0IENvbnRhY3RNYXAgPSAocHJvcHM6IHJlcXVpcmVkUHJvcHMpID0+IChcbiAgPFJlc2lkdWVDb250ZXh0Q29uc3VtZXI+XG4gICAge3Jlc2lkdWVDb250ZXh0ID0+IChcbiAgICAgIDxTZWNvbmRhcnlTdHJ1Y3R1cmVDb250ZXh0Q29uc3VtZXI+XG4gICAgICAgIHtzZWNvbmRhcnlTdHJ1Y3R1cmVDb250ZXh0ID0+IChcbiAgICAgICAgICA8Q29udGFjdE1hcENsYXNzXG4gICAgICAgICAgICByZXNpZHVlQ29udGV4dD17cmVzaWR1ZUNvbnRleHR9XG4gICAgICAgICAgICBzZWNvbmRhcnlTdHJ1Y3R1cmVDb250ZXh0PXtzZWNvbmRhcnlTdHJ1Y3R1cmVDb250ZXh0fVxuICAgICAgICAgICAgey4uLnByb3BzfVxuICAgICAgICAgIC8+XG4gICAgICAgICl9XG4gICAgICA8L1NlY29uZGFyeVN0cnVjdHVyZUNvbnRleHRDb25zdW1lcj5cbiAgICApfVxuICA8L1Jlc2lkdWVDb250ZXh0Q29uc3VtZXI+XG4pO1xuXG5leHBvcnQgeyBDb250YWN0TWFwIH07XG4iLCJpbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XG5cbmltcG9ydCB7IFNldCB9IGZyb20gJ2ltbXV0YWJsZSc7XG5pbXBvcnQgeyBQbG90bHlDaGFydCB9IGZyb20gJ35jaGVsbC12aXp+L2NvbXBvbmVudCc7XG5pbXBvcnQgeyBDaGVsbDFEU2VjdGlvbiwgQ2hlbGxDaGFydEV2ZW50LCBJUGxvdGx5RGF0YSwgVGludGVkQ2hlbGwxRFNlY3Rpb24gfSBmcm9tICd+Y2hlbGwtdml6fi9kYXRhJztcblxuZXhwb3J0IGludGVyZmFjZSBJRmVhdHVyZVJhbmdlU2VsZWN0aW9uIHtcbiAgZW5kOiBudW1iZXI7XG4gIGxlbmd0aDogbnVtYmVyO1xuICBzdGFydDogbnVtYmVyO1xuICBmZWF0dXJlc1NlbGVjdGVkOiBBcnJheTxDaGVsbDFEU2VjdGlvbjxzdHJpbmc+Pjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBJRmVhdHVyZVZpZXdlclByb3BzIHtcbiAgZGF0YTogQXJyYXk8VGludGVkQ2hlbGwxRFNlY3Rpb248c3RyaW5nPj47XG4gIGhlaWdodDogbnVtYmVyO1xuICBtYXhMZW5ndGg/OiBudW1iZXI7XG4gIHNob3dHcm91cGVkOiBib29sZWFuO1xuICB0aXRsZTogc3RyaW5nO1xuICB3aWR0aDogbnVtYmVyO1xuICBnZXRUZXh0Rm9ySG92ZXI/KGxhYmVsOiBzdHJpbmcsIGluZGV4OiBudW1iZXIpOiBzdHJpbmc7XG4gIG9uQ2xpY2tDYWxsYmFjaz8oc2VjdGlvbjogQXJyYXk8Q2hlbGwxRFNlY3Rpb248c3RyaW5nPj4pOiB2b2lkO1xuICBvblNlbGVjdENhbGxiYWNrPyhzZWxlY3Rpb246IElGZWF0dXJlUmFuZ2VTZWxlY3Rpb24pOiB2b2lkO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIElGZWF0dXJlVmlld2VyU3RhdGUge1xuICBob3ZlcmVkRmVhdHVyZUluZGV4OiBudW1iZXI7XG4gIGhvdmVyQW5ub3RhdGlvblRleHQ6IHN0cmluZztcbiAgcGxvdGx5TGF5b3V0OiBQYXJ0aWFsPFBsb3RseS5MYXlvdXQ+O1xuICBwbG90bHlDb25maWc6IFBhcnRpYWw8UGxvdGx5LkNvbmZpZz47XG4gIHBsb3RseURhdGE6IEFycmF5PFBhcnRpYWw8SVBsb3RseURhdGE+PjtcbiAgc2VsZWN0ZWRGZWF0dXJlSW5kaWNlczogU2V0PG51bWJlcj47XG4gIHNlbGVjdGVkUmFuZ2U6IENoZWxsMURTZWN0aW9uPHN0cmluZz47XG59XG5cbmV4cG9ydCBjbGFzcyBGZWF0dXJlVmlld2VyIGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50PElGZWF0dXJlVmlld2VyUHJvcHMsIElGZWF0dXJlVmlld2VyU3RhdGU+IHtcbiAgcHVibGljIHN0YXRpYyBkZWZhdWx0UHJvcHMgPSB7XG4gICAgZGF0YTogW10sXG4gICAgaGVpZ2h0OiAyMDAsXG4gICAgc2hvd0dyb3VwZWQ6IGZhbHNlLFxuICAgIHRpdGxlOiAnJyxcbiAgICB3aWR0aDogNjAwLFxuICB9O1xuXG4gIHB1YmxpYyBzdGF0aWMgZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzKFxuICAgIG5leHRQcm9wczogSUZlYXR1cmVWaWV3ZXJQcm9wcyxcbiAgICBuZXh0U3RhdGU6IElGZWF0dXJlVmlld2VyU3RhdGUsXG4gICk6IFBhcnRpYWw8SUZlYXR1cmVWaWV3ZXJTdGF0ZT4ge1xuICAgIGNvbnN0IHsgZGF0YSwgaGVpZ2h0LCBtYXhMZW5ndGgsIHNob3dHcm91cGVkLCB0aXRsZSwgd2lkdGggfSA9IG5leHRQcm9wcztcbiAgICBjb25zdCB7IGhvdmVyQW5ub3RhdGlvblRleHQsIGhvdmVyZWRGZWF0dXJlSW5kZXgsIHNlbGVjdGVkUmFuZ2UgfSA9IG5leHRTdGF0ZTtcblxuICAgIGNvbnN0IHBsb3RseURhdGEgPSBkYXRhLm1hcChcbiAgICAgIChkYXR1bSwgaW5kZXgpOiBQYXJ0aWFsPElQbG90bHlEYXRhPiA9PiB7XG4gICAgICAgIGNvbnN0IHlJbmRleCA9IHNob3dHcm91cGVkXG4gICAgICAgICAgPyBpbmRleFxuICAgICAgICAgIDogZGF0YS5maW5kSW5kZXgoY2FuZGlkYXRlRGF0dW0gPT4gZGF0dW0ubGFiZWwubG9jYWxlQ29tcGFyZShjYW5kaWRhdGVEYXR1bS5sYWJlbCkgPT09IDApO1xuXG4gICAgICAgIHJldHVybiBGZWF0dXJlVmlld2VyLmdldFBsb3RseURhdGFPYmplY3QoZGF0dW0sIHNob3dHcm91cGVkLCB5SW5kZXgpO1xuICAgICAgfSxcbiAgICApO1xuXG4gICAgcGxvdGx5RGF0YS5wdXNoKHtcbiAgICAgIGhvdmVyaW5mbzogJ25vbmUnLFxuICAgICAgbGluZToge1xuICAgICAgICBjb2xvcjogJ29yYW5nZScsXG4gICAgICAgIHdpZHRoOiAxMCxcbiAgICAgIH0sXG4gICAgICBtb2RlOiAnbGluZXMnLFxuICAgICAgc2hvd2xlZ2VuZDogZmFsc2UsXG4gICAgICB4OiBbc2VsZWN0ZWRSYW5nZS5zdGFydCwgc2VsZWN0ZWRSYW5nZS5lbmRdLFxuICAgICAgeTogWy0wLjI1LCAtMC4yNV0sXG4gICAgfSk7XG4gICAgY29uc3QgaG92ZXJlZERhdHVtID0gcGxvdGx5RGF0YVtob3ZlcmVkRmVhdHVyZUluZGV4XTtcblxuICAgIHJldHVybiB7XG4gICAgICBwbG90bHlEYXRhLFxuICAgICAgcGxvdGx5TGF5b3V0OiB7XG4gICAgICAgIGFubm90YXRpb25zOlxuICAgICAgICAgIGhvdmVyZWRGZWF0dXJlSW5kZXggPj0gMCAmJiBob3ZlcmVkRGF0dW0ueCAmJiBob3ZlcmVkRGF0dW0ueVxuICAgICAgICAgICAgPyBbXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgYWxpZ246ICdsZWZ0JyxcbiAgICAgICAgICAgICAgICAgIGFycm93aGVhZDogMCxcbiAgICAgICAgICAgICAgICAgIGFycm93c2l6ZTogMSxcbiAgICAgICAgICAgICAgICAgIGFycm93d2lkdGg6IDEsXG4gICAgICAgICAgICAgICAgICBheDogMCxcbiAgICAgICAgICAgICAgICAgIGF5OiAtMjUsXG4gICAgICAgICAgICAgICAgICBiZ2NvbG9yOiAnI2ZmZmZmZicsXG4gICAgICAgICAgICAgICAgICBib3JkZXJjb2xvcjogJyMwMDAwMDAnLFxuICAgICAgICAgICAgICAgICAgYm9yZGVycGFkOiA1LFxuICAgICAgICAgICAgICAgICAgc2hvd2Fycm93OiB0cnVlLFxuICAgICAgICAgICAgICAgICAgdGV4dDogaG92ZXJBbm5vdGF0aW9uVGV4dCxcbiAgICAgICAgICAgICAgICAgIHg6IGhvdmVyZWREYXR1bS54WzBdIGFzIG51bWJlcixcbiAgICAgICAgICAgICAgICAgIHhyZWY6ICd4JyxcbiAgICAgICAgICAgICAgICAgIHk6IGhvdmVyZWREYXR1bS55W2hvdmVyZWREYXR1bS55Lmxlbmd0aCAtIDNdIGFzIG51bWJlcixcbiAgICAgICAgICAgICAgICAgIHlyZWY6ICd5JyxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBdXG4gICAgICAgICAgICA6IFtdLFxuICAgICAgICBkcmFnbW9kZTogJ3NlbGVjdCcsXG4gICAgICAgIGhlaWdodCxcbiAgICAgICAgaG92ZXJtb2RlOiAnY2xvc2VzdCcsXG4gICAgICAgIG1hcmdpbjoge1xuICAgICAgICAgIGI6IDMwLFxuICAgICAgICAgIHQ6IDYwLFxuICAgICAgICB9LFxuICAgICAgICBzaG93bGVnZW5kOiBmYWxzZSxcbiAgICAgICAgdGl0bGUsXG4gICAgICAgIHdpZHRoLFxuICAgICAgICB4YXhpczpcbiAgICAgICAgICBkYXRhLmxlbmd0aCA+IDBcbiAgICAgICAgICAgID8ge1xuICAgICAgICAgICAgICAgIGF1dG9yYW5nZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgZml4ZWRyYW5nZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICByYW5nZTogWzAsIG1heExlbmd0aCA/IG1heExlbmd0aCA6IGRhdGEucmVkdWNlKChwcmV2LCBjdXIpID0+IE1hdGgubWF4KHByZXYsIGN1ci5lbmQpLCAtMSkgKyAyMDBdLFxuICAgICAgICAgICAgICAgIHNob3dncmlkOiBmYWxzZSxcbiAgICAgICAgICAgICAgICB0aWNrMDogMCxcbiAgICAgICAgICAgICAgICB0aWNrbW9kZTogJ2F1dG8nLFxuICAgICAgICAgICAgICAgIHRpY2tzOiAnb3V0c2lkZScsXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIDogeyB2aXNpYmxlOiBmYWxzZSB9LFxuICAgICAgICB5YXhpczoge1xuICAgICAgICAgIGF1dG9yYW5nZTogZmFsc2UsXG4gICAgICAgICAgZml4ZWRyYW5nZTogdHJ1ZSxcbiAgICAgICAgICByYW5nZTogWy0wLjI1LCBzaG93R3JvdXBlZCA/IDIgOiBkYXRhLmxlbmd0aF0sXG4gICAgICAgICAgdmlzaWJsZTogZmFsc2UsXG4gICAgICAgIH0sXG4gICAgICB9LFxuICAgIH07XG4gIH1cblxuICBwcm90ZWN0ZWQgc3RhdGljIGdldEJveEZvckNoZWxsU2VjdGlvbihkYXR1bTogVGludGVkQ2hlbGwxRFNlY3Rpb248YW55Pikge1xuICAgIHJldHVybiBbXG4gICAgICBkYXR1bS5lbmQgLSAoZGF0dW0uZW5kIC0gZGF0dW0uc3RhcnQpIC8gMixcbiAgICAgIG51bGwsXG4gICAgICBkYXR1bS5zdGFydCxcbiAgICAgIGRhdHVtLnN0YXJ0LFxuICAgICAgZGF0dW0uZW5kLFxuICAgICAgZGF0dW0uZW5kLFxuICAgICAgZGF0dW0uc3RhcnQsXG4gICAgXTtcbiAgfVxuXG4gIHByb3RlY3RlZCBzdGF0aWMgZ2V0UGxvdGx5RGF0YU9iamVjdCA9IChcbiAgICBkYXR1bTogVGludGVkQ2hlbGwxRFNlY3Rpb248c3RyaW5nPixcbiAgICBzaG93R3JvdXBlZDogYm9vbGVhbixcbiAgICB5SW5kZXg6IG51bWJlcixcbiAgKTogUGFydGlhbDxJUGxvdGx5RGF0YT4gPT4gKHtcbiAgICBmaWxsOiAndG9zZWxmJyxcbiAgICBmaWxsY29sb3I6IGRhdHVtLmNvbG9yLnRvU3RyaW5nKCksXG4gICAgaG92ZXJpbmZvOiAnbm9uZScsXG4gICAgaG92ZXJvbjogJ2ZpbGxzJyxcbiAgICBsaW5lOiB7XG4gICAgICB3aWR0aDogMCxcbiAgICB9LFxuICAgIG1vZGU6ICd0ZXh0K2xpbmVzJyxcbiAgICBuYW1lOiBgJHtkYXR1bS5sYWJlbH1gLFxuICAgIHRleHQ6IFtkYXR1bS5sYWJlbF0sXG4gICAgdGV4dGZvbnQ6IHsgY29sb3I6IFsnI0ZGRkZGRiddIH0sXG4gICAgdHlwZTogJ3NjYXR0ZXInLFxuICAgIC8vIENyZWF0ZXMgYSAnYm94JyBzbyB3ZSBjYW4gZmlsbCBpdCBhbmQgaG92ZXIgb3ZlciBpdCBhbmQgYWRkIGEgcG9pbnQgdG8gdGhlIG1pZGRsZSBmb3IgdGhlIGxhYmVsLlxuICAgIHg6IEZlYXR1cmVWaWV3ZXIuZ2V0Qm94Rm9yQ2hlbGxTZWN0aW9uKGRhdHVtKSxcbiAgICB5OiBzaG93R3JvdXBlZFxuICAgICAgPyBbMC41LCBudWxsLCAwLCAxLCAxLCAwLCAwXVxuICAgICAgOiBbeUluZGV4ICsgMC41LCBudWxsLCB5SW5kZXggKyAxLCB5SW5kZXgsIHlJbmRleCwgeUluZGV4ICsgMSwgeUluZGV4ICsgMV0sXG4gIH0pO1xuXG4gIGNvbnN0cnVjdG9yKHByb3BzOiBJRmVhdHVyZVZpZXdlclByb3BzKSB7XG4gICAgc3VwZXIocHJvcHMpO1xuICAgIHRoaXMuc3RhdGUgPSB7XG4gICAgICBob3ZlckFubm90YXRpb25UZXh0OiAnJyxcbiAgICAgIGhvdmVyZWRGZWF0dXJlSW5kZXg6IC0xLFxuICAgICAgcGxvdGx5Q29uZmlnOiB7XG4gICAgICAgIHNob3dBeGlzRHJhZ0hhbmRsZXM6IGZhbHNlLFxuICAgICAgICBzaG93QXhpc1JhbmdlRW50cnlCb3hlczogZmFsc2UsXG4gICAgICB9LFxuICAgICAgcGxvdGx5RGF0YTogW10sXG4gICAgICBwbG90bHlMYXlvdXQ6IHt9LFxuICAgICAgc2VsZWN0ZWRGZWF0dXJlSW5kaWNlczogU2V0PG51bWJlcj4oKSxcbiAgICAgIHNlbGVjdGVkUmFuZ2U6IG5ldyBDaGVsbDFEU2VjdGlvbignc2VsZWN0aW9uJywgLTEsIC0xKSxcbiAgICB9O1xuICB9XG5cbiAgcHVibGljIHJlbmRlcigpIHtcbiAgICBjb25zdCB7IHdpZHRoLCBoZWlnaHQgfSA9IHRoaXMucHJvcHM7XG4gICAgY29uc3QgeyBwbG90bHlDb25maWcsIHBsb3RseURhdGEsIHBsb3RseUxheW91dCB9ID0gdGhpcy5zdGF0ZTtcblxuICAgIHJldHVybiAoXG4gICAgICA8ZGl2IHN0eWxlPXt7IGhlaWdodCwgd2lkdGggfX0+XG4gICAgICAgIDxQbG90bHlDaGFydFxuICAgICAgICAgIGNvbmZpZz17cGxvdGx5Q29uZmlnfVxuICAgICAgICAgIGRhdGE9e3Bsb3RseURhdGF9XG4gICAgICAgICAgbGF5b3V0PXtwbG90bHlMYXlvdXR9XG4gICAgICAgICAgb25DbGlja0NhbGxiYWNrPXt0aGlzLm9uRmVhdHVyZUNsaWNrfVxuICAgICAgICAgIG9uSG92ZXJDYWxsYmFjaz17dGhpcy5vbkZlYXR1cmVIb3Zlcn1cbiAgICAgICAgICBvblNlbGVjdGVkQ2FsbGJhY2s9e3RoaXMub25GZWF0dXJlU2VsZWN0fVxuICAgICAgICAgIHNob3dMb2FkZXI9e2ZhbHNlfVxuICAgICAgICAvPlxuICAgICAgPC9kaXY+XG4gICAgKTtcbiAgfVxuXG4gIHByb3RlY3RlZCBvbkZlYXR1cmVIb3ZlciA9IChldmVudDogQ2hlbGxDaGFydEV2ZW50KSA9PiB7XG4gICAgY29uc3QgeyBkYXRhLCBnZXRUZXh0Rm9ySG92ZXIgfSA9IHRoaXMucHJvcHM7XG4gICAgbGV0IGhvdmVyZWRGZWF0dXJlSW5kZXggPSAtMTtcbiAgICAvLyBUT0RPIEhhbmRsZSB2ZXJ0aWNhbCB2aWV3ZXIsIGJldHRlciBzZWxlY3Rpb24gbG9naWMuXG4gICAgY29uc3QgeENvb3JkcyA9IFtldmVudC5zZWxlY3RlZFBvaW50c1swXSwgZXZlbnQuc2VsZWN0ZWRQb2ludHNbMl1dO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7ICsraSkge1xuICAgICAgZm9yIChjb25zdCB4Q29vcmQgb2YgeENvb3Jkcykge1xuICAgICAgICBpZiAoZGF0YVtpXS5jb250YWlucyh4Q29vcmQpKSB7XG4gICAgICAgICAgaG92ZXJlZEZlYXR1cmVJbmRleCA9IGk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgIGhvdmVyQW5ub3RhdGlvblRleHQ6XG4gICAgICAgIGdldFRleHRGb3JIb3ZlciAmJiBob3ZlcmVkRmVhdHVyZUluZGV4ID49IDBcbiAgICAgICAgICA/IGdldFRleHRGb3JIb3ZlcihkYXRhW2hvdmVyZWRGZWF0dXJlSW5kZXhdLmxhYmVsLCBob3ZlcmVkRmVhdHVyZUluZGV4KVxuICAgICAgICAgIDogJycsXG4gICAgICBob3ZlcmVkRmVhdHVyZUluZGV4LFxuICAgIH0pO1xuICB9O1xuXG4gIHByb3RlY3RlZCBvbkZlYXR1cmVDbGljayA9IChldmVudDogQ2hlbGxDaGFydEV2ZW50KSA9PiB7XG4gICAgY29uc3QgeyBkYXRhLCBvbkNsaWNrQ2FsbGJhY2sgfSA9IHRoaXMucHJvcHM7XG4gICAgY29uc3Qgc2VsZWN0ZWRGZWF0dXJlSW5kaWNlcyA9IHRoaXMuZGVyaXZlRmVhdHVyZUluZGljZXMoZGF0YSwgZXZlbnQuc2VsZWN0ZWRQb2ludHMpO1xuXG4gICAgaWYgKG9uQ2xpY2tDYWxsYmFjaykge1xuICAgICAgb25DbGlja0NhbGxiYWNrKHRoaXMuZGVyaXZlU2VsZWN0ZWRGZWF0dXJlcyhkYXRhLCBzZWxlY3RlZEZlYXR1cmVJbmRpY2VzLnRvQXJyYXkoKSkpO1xuICAgIH1cblxuICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgc2VsZWN0ZWRGZWF0dXJlSW5kaWNlcyxcbiAgICAgIHNlbGVjdGVkUmFuZ2U6IG5ldyBDaGVsbDFEU2VjdGlvbignc2VsZWN0aW9uJywgLTEsIC0xKSxcbiAgICB9KTtcbiAgfTtcblxuICBwcm90ZWN0ZWQgb25GZWF0dXJlU2VsZWN0ID0gKGV2ZW50OiBDaGVsbENoYXJ0RXZlbnQpID0+IHtcbiAgICBjb25zdCB7IGRhdGEsIG9uU2VsZWN0Q2FsbGJhY2sgfSA9IHRoaXMucHJvcHM7XG4gICAgY29uc3Qgc2VsZWN0ZWRGZWF0dXJlSW5kaWNlcyA9IHRoaXMuZGVyaXZlRmVhdHVyZUluZGljZXMoZGF0YSwgZXZlbnQuc2VsZWN0ZWRQb2ludHMpO1xuXG4gICAgY29uc3QgcGxvdGx5RXZlbnQgPSBldmVudC5wbG90bHlFdmVudCBhcyBQbG90bHkuUGxvdFNlbGVjdGlvbkV2ZW50O1xuICAgIGxldCB7IHNlbGVjdGVkUmFuZ2UgfSA9IHRoaXMuc3RhdGU7XG4gICAgaWYgKHBsb3RseUV2ZW50LnJhbmdlKSB7XG4gICAgICBzZWxlY3RlZFJhbmdlID0gbmV3IENoZWxsMURTZWN0aW9uKFxuICAgICAgICAnc2VsZWN0aW9uJyxcbiAgICAgICAgTWF0aC5mbG9vcihwbG90bHlFdmVudC5yYW5nZS54WzBdKSxcbiAgICAgICAgTWF0aC5jZWlsKHBsb3RseUV2ZW50LnJhbmdlLnhbMV0pLFxuICAgICAgKTtcblxuICAgICAgY29uc3Qgc2VsZWN0aW9uOiBJRmVhdHVyZVJhbmdlU2VsZWN0aW9uID0ge1xuICAgICAgICBlbmQ6IHNlbGVjdGVkUmFuZ2UuZW5kLFxuICAgICAgICBmZWF0dXJlc1NlbGVjdGVkOiB0aGlzLmRlcml2ZVNlbGVjdGVkRmVhdHVyZXMoZGF0YSwgc2VsZWN0ZWRGZWF0dXJlSW5kaWNlcy50b0FycmF5KCkpLFxuICAgICAgICBsZW5ndGg6IHNlbGVjdGVkUmFuZ2UubGVuZ3RoLFxuICAgICAgICBzdGFydDogc2VsZWN0ZWRSYW5nZS5zdGFydCxcbiAgICAgIH07XG5cbiAgICAgIGlmIChvblNlbGVjdENhbGxiYWNrKSB7XG4gICAgICAgIG9uU2VsZWN0Q2FsbGJhY2soc2VsZWN0aW9uKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgIHNlbGVjdGVkRmVhdHVyZUluZGljZXMsXG4gICAgICBzZWxlY3RlZFJhbmdlLFxuICAgIH0pO1xuICB9O1xuXG4gIC8qKlxuICAgKiBEZXJpdmUgdGhlIGluZGljZXMgb2YgdGhlIEZlYXR1cmVzIGZyb20gdGhlIHBvaW50cyB0aGUgdXNlciBzZWxlY3RlZC5cbiAgICovXG4gIHByb3RlY3RlZCBkZXJpdmVGZWF0dXJlSW5kaWNlcyA9IChkYXRhOiBBcnJheTxUaW50ZWRDaGVsbDFEU2VjdGlvbjxzdHJpbmc+PiwgdXNlclNlbGVjdGVkUG9pbnRzOiBudW1iZXJbXSkgPT4ge1xuICAgIGxldCBmZWF0dXJlSW5kaWNlcyA9IFNldDxudW1iZXI+KCk7XG5cbiAgICAvLyBQb2ludHMgY29tZSB0byB1cyBhcyBbeDAsIHkwLCB4MSwgeTEsIC4uLiwgeG4sIHluXSwgc28gd2Ugc2tpcCBldmVyeSBvdGhlciBwb2ludC5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHVzZXJTZWxlY3RlZFBvaW50cy5sZW5ndGg7IGkgKz0gMikge1xuICAgICAgY29uc3QgeENvb3JkID0gdXNlclNlbGVjdGVkUG9pbnRzW2ldO1xuICAgICAgZGF0YVxuICAgICAgICAucmVkdWNlKChyZXN1bHQsIGRhdHVtLCBpbmRleCkgPT4gKGRhdHVtLmNvbnRhaW5zKHhDb29yZCkgPyBbLi4ucmVzdWx0LCBpbmRleF0gOiByZXN1bHQpLCBuZXcgQXJyYXk8bnVtYmVyPigpKVxuICAgICAgICAuZm9yRWFjaChpbmRleFRvQWRkID0+IHtcbiAgICAgICAgICBmZWF0dXJlSW5kaWNlcyA9IGZlYXR1cmVJbmRpY2VzLmFkZChpbmRleFRvQWRkKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZlYXR1cmVJbmRpY2VzO1xuICB9O1xuXG4gIC8qKlxuICAgKiBTaG9ydGhhbmQgdG8gZ2V0IHRoZSByYXcgc2VjdGlvbiBkYXRhIGZvciBhIHNldCBvZiBGZWF0dXJlcyBnaXZlbiBzb21lIGluZGljZXMuXG4gICAqL1xuICBwcm90ZWN0ZWQgZGVyaXZlU2VsZWN0ZWRGZWF0dXJlcyA9IChkYXRhOiBBcnJheTxUaW50ZWRDaGVsbDFEU2VjdGlvbjxzdHJpbmc+Piwgc2VsZWN0ZWRGZWF0dXJlSW5kaWNlczogbnVtYmVyW10pID0+IHtcbiAgICByZXR1cm4gc2VsZWN0ZWRGZWF0dXJlSW5kaWNlcy5tYXAoXG4gICAgICBpbmRleCA9PiBuZXcgQ2hlbGwxRFNlY3Rpb24oZGF0YVtpbmRleF0ubGFiZWwsIGRhdGFbaW5kZXhdLnN0YXJ0LCBkYXRhW2luZGV4XS5lbmQpLFxuICAgICk7XG4gIH07XG59XG4iLCJpbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBBY2NvcmRpb24sIExhYmVsIH0gZnJvbSAnc2VtYW50aWMtdWktcmVhY3QnO1xuXG5pbXBvcnQge1xuICBpbml0aWFsUmVzaWR1ZUNvbnRleHQsXG4gIGluaXRpYWxTZWNvbmRhcnlTdHJ1Y3R1cmVDb250ZXh0LFxuICBJUmVzaWR1ZUNvbnRleHQsXG4gIElTZWNvbmRhcnlTdHJ1Y3R1cmVDb250ZXh0LFxuICBSZXNpZHVlQ29udGV4dCxcbiAgUmVzaWR1ZVNlbGVjdGlvbixcbiAgU2Vjb25kYXJ5U3RydWN0dXJlQ29udGV4dCxcbn0gZnJvbSAnfmNoZWxsLXZpen4vY29udGV4dCc7XG5pbXBvcnQge1xuICBDaGVsbFBEQixcbiAgQ291cGxpbmdDb250YWluZXIsXG4gIElDb250YWN0TWFwRGF0YSxcbiAgU0VDT05EQVJZX1NUUlVDVFVSRSxcbiAgU0VDT05EQVJZX1NUUlVDVFVSRV9DT0RFUyxcbn0gZnJvbSAnfmNoZWxsLXZpen4vZGF0YSc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgSUluZm9QYW5lbFByb3BzIHtcbiAgZGF0YTogUGFydGlhbDxJQ29udGFjdE1hcERhdGE+O1xuICBoZWlnaHQ6IG51bWJlcjtcbiAgd2lkdGg6IDQwMDtcbiAgcmVzaWR1ZUNvbnRleHQ6IElSZXNpZHVlQ29udGV4dDtcbiAgc2Vjb25kYXJ5U3RydWN0dXJlQ29udGV4dDogSVNlY29uZGFyeVN0cnVjdHVyZUNvbnRleHQ7XG59XG5cbmV4cG9ydCBjbGFzcyBJbmZvUGFuZWxDbGFzcyBleHRlbmRzIFJlYWN0LkNvbXBvbmVudDxJSW5mb1BhbmVsUHJvcHMsIGFueT4ge1xuICBwdWJsaWMgc3RhdGljIGRlZmF1bHRQcm9wcyA9IHtcbiAgICBkYXRhOiB7XG4gICAgICBjb3VwbGluZ1Njb3JlczogbmV3IENvdXBsaW5nQ29udGFpbmVyKCksXG4gICAgICBzZWNvbmRhcnlTdHJ1Y3R1cmVzOiBuZXcgQXJyYXk8U0VDT05EQVJZX1NUUlVDVFVSRT4oKSxcbiAgICB9LFxuICAgIGhlaWdodDogNDAwLFxuICAgIHJlc2lkdWVDb250ZXh0OiB7IC4uLmluaXRpYWxSZXNpZHVlQ29udGV4dCB9LFxuICAgIHNlY29uZGFyeVN0cnVjdHVyZUNvbnRleHQ6IHsgLi4uaW5pdGlhbFNlY29uZGFyeVN0cnVjdHVyZUNvbnRleHQgfSxcbiAgICB3aWR0aDogNDAwLFxuICB9O1xuXG4gIGNvbnN0cnVjdG9yKHByb3BzOiBJSW5mb1BhbmVsUHJvcHMpIHtcbiAgICBzdXBlcihwcm9wcyk7XG4gIH1cblxuICBwdWJsaWMgcmVuZGVyKCkge1xuICAgIGNvbnN0IHsgZGF0YSwgaGVpZ2h0LCByZXNpZHVlQ29udGV4dCwgd2lkdGgsIHNlY29uZGFyeVN0cnVjdHVyZUNvbnRleHQgfSA9IHRoaXMucHJvcHM7XG4gICAgY29uc3QgdW5hc3NpZ25lZFJlc2lkdWVzID0gZGF0YS5wZGJEYXRhXG4gICAgICA/IHRoaXMucmVuZGVyVW5hc3NpZ25lZFJlc2lkdWVzKGRhdGEucGRiRGF0YSlcbiAgICAgIDogWzxMYWJlbCBrZXk9eyd1bmFzc2lnbmVkLXJlc2lkdWVzLW5vbmUnfSAvPl07XG5cbiAgICByZXR1cm4gKFxuICAgICAgPGRpdiBjbGFzc05hbWU9XCJJbmZvUGFuZWxcIiBzdHlsZT17eyBoZWlnaHQsIHdpZHRoIH19PlxuICAgICAgICA8QWNjb3JkaW9uXG4gICAgICAgICAgZXhjbHVzaXZlPXtmYWxzZX1cbiAgICAgICAgICBwYW5lbHM9e1tcbiAgICAgICAgICAgIGRhdGEucGRiRGF0YSAmJlxuICAgICAgICAgICAgICBkYXRhLnBkYkRhdGEuc2Vjb25kYXJ5U3RydWN0dXJlU2VjdGlvbnMubWFwKHNlY29uZGFyeVN0cnVjdHVyZSA9PiAoe1xuICAgICAgICAgICAgICAgIGNvbnRlbnQ6IHRoaXMucmVuZGVyU2Vjb25kYXJ5U3RydWN0dXJlcyhzZWNvbmRhcnlTdHJ1Y3R1cmUpLFxuICAgICAgICAgICAgICAgIGtleTogJ2FsbC1zZWNvbmRhcnktc3RydWN0dXJlcycsXG4gICAgICAgICAgICAgICAgdGl0bGU6IGBBbGwgU2Vjb25kYXJ5IFN0cnVjdHVyZXMgKCR7XG4gICAgICAgICAgICAgICAgICBkYXRhLnBkYkRhdGEgPyBkYXRhLnBkYkRhdGEuc2Vjb25kYXJ5U3RydWN0dXJlU2VjdGlvbnMubGVuZ3RoIDogMFxuICAgICAgICAgICAgICAgIH0pOmAsXG4gICAgICAgICAgICAgIH0pKSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgY29udGVudDogdW5hc3NpZ25lZFJlc2lkdWVzLFxuICAgICAgICAgICAgICBrZXk6ICd1bmFzc2lnbmVkLXJlc2lkdWVzJyxcbiAgICAgICAgICAgICAgdGl0bGU6IGBVbmFzc2lnbmVkIFJlc2lkdWVzICgke3VuYXNzaWduZWRSZXNpZHVlcy5sZW5ndGh9KTpgLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgY29udGVudDogdGhpcy5yZW5kZXJTZWNvbmRhcnlTdHJ1Y3R1cmVzKHNlY29uZGFyeVN0cnVjdHVyZUNvbnRleHQuc2VsZWN0ZWRTZWNvbmRhcnlTdHJ1Y3R1cmVzKSxcbiAgICAgICAgICAgICAga2V5OiAnc2VsZWN0ZWQtc2Vjb25kYXJ5LXN0cnVjdHVyZXMnLFxuICAgICAgICAgICAgICB0aXRsZTogYFNlbGVjdGVkIFNlY29uZGFyeSBTdHJ1Y3R1cmVzICgke3NlY29uZGFyeVN0cnVjdHVyZUNvbnRleHQuc2VsZWN0ZWRTZWNvbmRhcnlTdHJ1Y3R1cmVzLmxlbmd0aH0pOmAsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBjb250ZW50OiB0aGlzLnJlbmRlckxvY2tlZFJlc2lkdWVQYWlycyhyZXNpZHVlQ29udGV4dC5sb2NrZWRSZXNpZHVlUGFpcnMpLFxuICAgICAgICAgICAgICBrZXk6ICdzZWxlY3RlZC1yZXNpZHVlLXBhaXJzJyxcbiAgICAgICAgICAgICAgdGl0bGU6IGBTZWxlY3RlZCBSZXNpZHVlIFBhaXJzICgke3Jlc2lkdWVDb250ZXh0LmxvY2tlZFJlc2lkdWVQYWlycy5zaXplfSk6YCxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgXX1cbiAgICAgICAgLz5cbiAgICAgIDwvZGl2PlxuICAgICk7XG4gIH1cblxuICBwcm90ZWN0ZWQgcmVuZGVyTG9ja2VkUmVzaWR1ZVBhaXJzKGxvY2tlZFJlc2lkdWVQYWlyczogUmVzaWR1ZVNlbGVjdGlvbikge1xuICAgIHJldHVybiBsb2NrZWRSZXNpZHVlUGFpcnMuc2l6ZSA9PT0gMFxuICAgICAgPyBbPExhYmVsIGtleT17J2xvY2tlZC1yZXNpZHVlLXBhaXItbm9uZSd9Pk5vbmU8L0xhYmVsPl1cbiAgICAgIDogQXJyYXkuZnJvbShsb2NrZWRSZXNpZHVlUGFpcnMudmFsdWVzKCkpLm1hcCgocGFpciwgaW5kZXgpID0+IChcbiAgICAgICAgICA8TGFiZWwga2V5PXtgbG9ja2VkLXJlc2lkdWUtcGFpci0ke2luZGV4fWB9PntwYWlyLmpvaW4oJywgJyl9PC9MYWJlbD5cbiAgICAgICAgKSk7XG4gIH1cblxuICBwcm90ZWN0ZWQgcmVuZGVyU2Vjb25kYXJ5U3RydWN0dXJlcyhzZWxlY3RlZFNlY29uZGFyeVN0cnVjdHVyZXM6IFNFQ09OREFSWV9TVFJVQ1RVUkUpIHtcbiAgICByZXR1cm4gc2VsZWN0ZWRTZWNvbmRhcnlTdHJ1Y3R1cmVzLmxlbmd0aCA9PT0gMFxuICAgICAgPyBbPExhYmVsIGtleT17J3NlYy1zdHJ1Y3Qtbm9uZSd9Pk5vbmU8L0xhYmVsPl1cbiAgICAgIDogc2VsZWN0ZWRTZWNvbmRhcnlTdHJ1Y3R1cmVzLm1hcCgoc2VjdGlvbiwgaW5kZXgpID0+IChcbiAgICAgICAgICA8TGFiZWwga2V5PXtgc2VjLXN0cnVjdC0ke2luZGV4fWB9PntgWyR7c2VjdGlvbi5zdGFydH0tJHtzZWN0aW9uLmVuZH1dOiAke3NlY3Rpb24ubGFiZWx9IC0gJHtcbiAgICAgICAgICAgIFNFQ09OREFSWV9TVFJVQ1RVUkVfQ09ERVNbc2VjdGlvbi5sYWJlbF1cbiAgICAgICAgICB9YH08L0xhYmVsPlxuICAgICAgICApKTtcbiAgfVxuXG4gIHByb3RlY3RlZCByZW5kZXJVbmFzc2lnbmVkUmVzaWR1ZXMocGRiRGF0YTogQ2hlbGxQREIpIHtcbiAgICBjb25zdCByZXN1bHQgPSBuZXcgQXJyYXk8SlNYLkVsZW1lbnQ+KCk7XG4gICAgcGRiRGF0YS5lYWNoUmVzaWR1ZShyZXNpZHVlID0+IHtcbiAgICAgIGlmIChyZXNpZHVlLmlzUHJvdGVpbigpKSB7XG4gICAgICAgIGxldCBpc1VuYXNzaWduZWQgPSB0cnVlO1xuICAgICAgICBmb3IgKGNvbnN0IHNlY29uZGFyeVN0cnVjdHVyZSBvZiBwZGJEYXRhLnNlY29uZGFyeVN0cnVjdHVyZVNlY3Rpb25zKSB7XG4gICAgICAgICAgZm9yIChjb25zdCBzZWN0aW9uIG9mIHNlY29uZGFyeVN0cnVjdHVyZSkge1xuICAgICAgICAgICAgaWYgKHNlY3Rpb24uY29udGFpbnMocmVzaWR1ZS5yZXNubykpIHtcbiAgICAgICAgICAgICAgaXNVbmFzc2lnbmVkID0gZmFsc2U7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc1VuYXNzaWduZWQpIHtcbiAgICAgICAgICByZXN1bHQucHVzaChcbiAgICAgICAgICAgIDxMYWJlbCBrZXk9e2B1bmFzc2lnbmVkLXJlc2lkdWUtJHtyZXNpZHVlLnJlc25vfWB9PlxuICAgICAgICAgICAgICB7YFske3Jlc2lkdWUucmVzbm99OiBpc0NnPyAke3Jlc2lkdWUuaXNDZygpfSwgXFxcbiAgICAgICAgICAgICAgaXNEbmE/ICR7cmVzaWR1ZS5pc0RuYSgpfSwgXFxcbiAgICAgICAgICAgICAgaXNIZWxpeD8gJHtyZXNpZHVlLmlzSGVsaXgoKX0sIFxcXG4gICAgICAgICAgICAgIGlzTnVjbGVpYz8gJHtyZXNpZHVlLmlzTnVjbGVpYygpfSwgXFxcbiAgICAgICAgICAgICAgaXNQcm90ZWluPyAke3Jlc2lkdWUuaXNQcm90ZWluKCl9LCBcXFxuICAgICAgICAgICAgICBpc1BvbHltZXI/ICR7cmVzaWR1ZS5pc1BvbHltZXIoKX0sIFxcXG4gICAgICAgICAgICAgIGlzU2FjY2hhcmlkZT8gJHtyZXNpZHVlLmlzU2FjY2hhcmlkZSgpfSwgXFxcbiAgICAgICAgICAgICAgaXNTaGVldD8gJHtyZXNpZHVlLmlzU2hlZXQoKX0sXFxcbiAgICAgICAgICAgICAgaXNUdXJuPyAke3Jlc2lkdWUuaXNUdXJuKCl9YH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgPC9MYWJlbD4sXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxufVxuXG50eXBlIHJlcXVpcmVkUHJvcHMgPSBPbWl0PElJbmZvUGFuZWxQcm9wcywga2V5b2YgdHlwZW9mIEluZm9QYW5lbENsYXNzLmRlZmF1bHRQcm9wcz4gJiBQYXJ0aWFsPElJbmZvUGFuZWxQcm9wcz47XG5cbmNvbnN0IEluZm9QYW5lbCA9IChwcm9wczogcmVxdWlyZWRQcm9wcykgPT4gKFxuICA8U2Vjb25kYXJ5U3RydWN0dXJlQ29udGV4dC5Db25zdW1lcj5cbiAgICB7c2VjU3RydWN0Q29udGV4dCA9PiAoXG4gICAgICA8UmVzaWR1ZUNvbnRleHQuQ29uc3VtZXI+XG4gICAgICAgIHtyZXNpZHVlQ29udGV4dCA9PiA8SW5mb1BhbmVsIHsuLi5wcm9wc30gey4uLnJlc2lkdWVDb250ZXh0fSB7Li4uc2VjU3RydWN0Q29udGV4dH0gLz59XG4gICAgICA8L1Jlc2lkdWVDb250ZXh0LkNvbnN1bWVyPlxuICAgICl9XG4gIDwvU2Vjb25kYXJ5U3RydWN0dXJlQ29udGV4dC5Db25zdW1lcj5cbik7XG5cbmV4cG9ydCB7IEluZm9QYW5lbCB9O1xuIiwiaW1wb3J0IHsgY2xvbmVEZWVwIH0gZnJvbSAnbG9kYXNoJztcbmltcG9ydCAqIGFzIE5HTCBmcm9tICduZ2wnO1xuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgRGltbWVyLCBMb2FkZXIgfSBmcm9tICdzZW1hbnRpYy11aS1yZWFjdCc7XG5pbXBvcnQgeyBWZWN0b3IyIH0gZnJvbSAndGhyZWUnO1xuXG5pbXBvcnQgeyBTZXR0aW5nc1BhbmVsIH0gZnJvbSAnfmNoZWxsLXZpen4vY29tcG9uZW50JztcbmltcG9ydCB7XG4gIElDb3VwbGluZ0NvbnRleHQsXG4gIGluaXRpYWxDb3VwbGluZ0NvbnRleHQsXG4gIGluaXRpYWxSZXNpZHVlQ29udGV4dCxcbiAgaW5pdGlhbFNlY29uZGFyeVN0cnVjdHVyZUNvbnRleHQsXG4gIElSZXNpZHVlQ29udGV4dCxcbiAgSVNlY29uZGFyeVN0cnVjdHVyZUNvbnRleHQsXG4gIFJlc2lkdWVDb250ZXh0Q29uc3VtZXIsXG4gIFJlc2lkdWVTZWxlY3Rpb24sXG4gIFNlY29uZGFyeVN0cnVjdHVyZUNvbnRleHRDb25zdW1lcixcbn0gZnJvbSAnfmNoZWxsLXZpen4vY29udGV4dCc7XG5pbXBvcnQge1xuICBBTUlOT19BQ0lEX1RIUkVFX0xFVFRFUl9DT0RFLFxuICBBTUlOT19BQ0lEU19CWV9USFJFRV9MRVRURVJfQ09ERSxcbiAgQ0hFTExfQ1NTX1NUWUxFLFxuICBDaGVsbFBEQixcbiAgQ2hlbGxXaWRnZXRDb25maWcsXG4gIENPTkZJR1VSQVRJT05fQ09NUE9ORU5UX1RZUEUsXG4gIENPTlRBQ1RfRElTVEFOQ0VfUFJPWElNSVRZLFxuICBSRVNJRFVFX1RZUEUsXG4gIFNFQ09OREFSWV9TVFJVQ1RVUkUsXG59IGZyb20gJ35jaGVsbC12aXp+L2RhdGEnO1xuaW1wb3J0IHtcbiAgY2FwaXRhbGl6ZUZpcnN0TGV0dGVyLFxuICBjcmVhdGVCYWxsU3RpY2tSZXByZXNlbnRhdGlvbixcbiAgY3JlYXRlRGlzdGFuY2VSZXByZXNlbnRhdGlvbixcbiAgY3JlYXRlU2VjU3RydWN0UmVwcmVzZW50YXRpb24sXG59IGZyb20gJ35jaGVsbC12aXp+L2hlbHBlcic7XG5cbmV4cG9ydCB0eXBlIE5HTF9IT1ZFUl9DQl9SRVNVTFRfVFlQRSA9IG51bWJlcjtcblxuZXhwb3J0IHR5cGUgUmVwcmVzZW50YXRpb25EaWN0ID0gTWFwPHN0cmluZywgTkdMLlJlcHJlc2VudGF0aW9uRWxlbWVudFtdPjtcblxuZXhwb3J0IGludGVyZmFjZSBJTkdMQ29tcG9uZW50UHJvcHMge1xuICBiYWNrZ3JvdW5kQ29sb3I6IHN0cmluZyB8IG51bWJlcjtcbiAgY291cGxpbmdDb250ZXh0OiBJQ291cGxpbmdDb250ZXh0O1xuICBkYXRhOiBOR0wuU3RydWN0dXJlIHwgdW5kZWZpbmVkO1xuICBoZWlnaHQ6IG51bWJlciB8IHN0cmluZztcbiAgaXNEYXRhTG9hZGluZzogYm9vbGVhbjtcbiAgbWVhc3VyZWRQcm94aW1pdHk6IENPTlRBQ1RfRElTVEFOQ0VfUFJPWElNSVRZO1xuICByZXNpZHVlQ29udGV4dDogSVJlc2lkdWVDb250ZXh0O1xuICBzZWNvbmRhcnlTdHJ1Y3R1cmVDb250ZXh0OiBJU2Vjb25kYXJ5U3RydWN0dXJlQ29udGV4dDtcbiAgc2hvd0NvbmZpZ3VyYXRpb25zOiBib29sZWFuO1xuICBzdHlsZT86IENIRUxMX0NTU19TVFlMRTtcbiAgd2lkdGg6IG51bWJlciB8IHN0cmluZztcbiAgb25NZWFzdXJlZFByb3hpbWl0eUNoYW5nZT8odmFsdWU6IG51bWJlcik6IHZvaWQ7XG4gIG9uUmVzaXplPyhldmVudD86IFVJRXZlbnQpOiB2b2lkO1xufVxuXG5leHBvcnQgY29uc3QgaW5pdGlhbE5HTFN0YXRlID0ge1xuICBhY3RpdmVSZXByZXNlbnRhdGlvbnM6IG5ldyBBcnJheTxOR0wuUmVwcmVzZW50YXRpb25FbGVtZW50PigpLFxuICBwZGJEYXRhOiB1bmRlZmluZWQgYXMgQ2hlbGxQREIgfCB1bmRlZmluZWQsXG4gIHN0YWdlOiB1bmRlZmluZWQgYXMgTkdMLlN0YWdlIHwgdW5kZWZpbmVkLFxuICBzdHJ1Y3R1cmVDb21wb25lbnQ6IHVuZGVmaW5lZCBhcyBOR0wuU3RydWN0dXJlQ29tcG9uZW50IHwgdW5kZWZpbmVkLFxufTtcblxuZXhwb3J0IHR5cGUgTkdMQ29tcG9uZW50U3RhdGUgPSBSZWFkb25seTx0eXBlb2YgaW5pdGlhbE5HTFN0YXRlPjtcblxuZXhwb3J0IGNsYXNzIE5HTENvbXBvbmVudENsYXNzIGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50PElOR0xDb21wb25lbnRQcm9wcywgTkdMQ29tcG9uZW50U3RhdGU+IHtcbiAgcHVibGljIHN0YXRpYyBkZWZhdWx0UHJvcHMgPSB7XG4gICAgYmFja2dyb3VuZENvbG9yOiAnI2ZmZmZmZicsXG4gICAgY291cGxpbmdDb250ZXh0OiB7IC4uLmluaXRpYWxDb3VwbGluZ0NvbnRleHQgfSxcbiAgICBkYXRhOiB1bmRlZmluZWQsXG4gICAgaGVpZ2h0OiAnMTAwJScsXG4gICAgaXNEYXRhTG9hZGluZzogZmFsc2UsXG4gICAgbWVhc3VyZWRQcm94aW1pdHk6IENPTlRBQ1RfRElTVEFOQ0VfUFJPWElNSVRZLkNfQUxQSEEsXG4gICAgcmVzaWR1ZUNvbnRleHQ6IHsgLi4uaW5pdGlhbFJlc2lkdWVDb250ZXh0IH0sXG4gICAgc2Vjb25kYXJ5U3RydWN0dXJlQ29udGV4dDoge1xuICAgICAgLi4uaW5pdGlhbFNlY29uZGFyeVN0cnVjdHVyZUNvbnRleHQsXG4gICAgfSxcbiAgICBzaG93Q29uZmlndXJhdGlvbnM6IHRydWUsXG4gICAgd2lkdGg6ICcxMDAlJyxcbiAgfTtcbiAgcHVibGljIHJlYWRvbmx5IHN0YXRlOiBOR0xDb21wb25lbnRTdGF0ZSA9IGluaXRpYWxOR0xTdGF0ZTtcblxuICBwdWJsaWMgY2FudmFzOiBIVE1MRWxlbWVudCB8IG51bGwgPSBudWxsO1xuXG4gIGNvbnN0cnVjdG9yKHByb3BzOiBJTkdMQ29tcG9uZW50UHJvcHMpIHtcbiAgICBzdXBlcihwcm9wcyk7XG4gIH1cblxuICBwdWJsaWMgY29tcG9uZW50RGlkTW91bnQoeyBiYWNrZ3JvdW5kQ29sb3IgfSA9IHRoaXMucHJvcHMpIHtcbiAgICBpZiAodGhpcy5jYW52YXMpIHtcbiAgICAgIGNvbnN0IHN0YWdlID0gdGhpcy5nZW5lcmF0ZVN0YWdlKHRoaXMuY2FudmFzLCB7IGJhY2tncm91bmRDb2xvciB9KTtcblxuICAgICAgY29uc3QgeyBkYXRhIH0gPSB0aGlzLnByb3BzO1xuXG4gICAgICB0aGlzLmluaXREYXRhKHN0YWdlLCBkYXRhKTtcblxuICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgIHN0YWdlLFxuICAgICAgfSk7XG4gICAgfVxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCB0aGlzLm9uUmVzaXplSGFuZGxlciwgZmFsc2UpO1xuICB9XG5cbiAgcHVibGljIGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xuICAgIGNvbnN0IHsgc3RhZ2UgfSA9IHRoaXMuc3RhdGU7XG4gICAgaWYgKHN0YWdlKSB7XG4gICAgICBzdGFnZS52aWV3ZXIucmVuZGVyZXIuZm9yY2VDb250ZXh0TG9zcygpO1xuICAgICAgc3RhZ2UuZGlzcG9zZSgpO1xuICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgIGFjdGl2ZVJlcHJlc2VudGF0aW9uczogW10sXG4gICAgICAgIHN0YWdlOiB1bmRlZmluZWQsXG4gICAgICB9KTtcbiAgICB9XG4gICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIHRoaXMub25SZXNpemVIYW5kbGVyKTtcbiAgfVxuXG4gIHB1YmxpYyBjb21wb25lbnREaWRVcGRhdGUocHJldlByb3BzOiBJTkdMQ29tcG9uZW50UHJvcHMsIHByZXZTdGF0ZTogTkdMQ29tcG9uZW50U3RhdGUpIHtcbiAgICBjb25zdCB7IGRhdGEsIG1lYXN1cmVkUHJveGltaXR5IH0gPSB0aGlzLnByb3BzO1xuICAgIGNvbnN0IHsgc3RhZ2UsIHN0cnVjdHVyZUNvbXBvbmVudCB9ID0gdGhpcy5zdGF0ZTtcblxuICAgIGlmIChzdGFnZSAmJiBkYXRhICE9PSBwcmV2UHJvcHMuZGF0YSkge1xuICAgICAgdGhpcy5pbml0RGF0YShzdGFnZSwgZGF0YSk7XG4gICAgfVxuXG4gICAgaWYgKHN0YWdlICYmIGRhdGEgJiYgc3RydWN0dXJlQ29tcG9uZW50KSB7XG4gICAgICBjb25zdCB7IHJlc2lkdWVDb250ZXh0LCBzZWNvbmRhcnlTdHJ1Y3R1cmVDb250ZXh0IH0gPSB0aGlzLnByb3BzO1xuXG4gICAgICBjb25zdCBpc0hpZ2hsaWdodFVwZGF0ZU5lZWRlZCA9XG4gICAgICAgIHJlc2lkdWVDb250ZXh0ICE9PSBwcmV2UHJvcHMucmVzaWR1ZUNvbnRleHQgfHxcbiAgICAgICAgc2Vjb25kYXJ5U3RydWN0dXJlQ29udGV4dCAhPT0gcHJldlByb3BzLnNlY29uZGFyeVN0cnVjdHVyZUNvbnRleHQgfHxcbiAgICAgICAgbWVhc3VyZWRQcm94aW1pdHkgIT09IHByZXZQcm9wcy5tZWFzdXJlZFByb3hpbWl0eTtcbiAgICAgIGlmIChpc0hpZ2hsaWdodFVwZGF0ZU5lZWRlZCkge1xuICAgICAgICBmb3IgKGNvbnN0IHJlcCBvZiB0aGlzLnN0YXRlLmFjdGl2ZVJlcHJlc2VudGF0aW9ucykge1xuICAgICAgICAgIHN0cnVjdHVyZUNvbXBvbmVudC5yZW1vdmVSZXByZXNlbnRhdGlvbihyZXApO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgYWN0aXZlUmVwcmVzZW50YXRpb25zOiB0aGlzLmRlcml2ZUFjdGl2ZVJlcHJlc2VudGF0aW9ucyhzdHJ1Y3R1cmVDb21wb25lbnQsIHRoaXMuc3RhdGUucGRiRGF0YSksXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgc3RhZ2Uudmlld2VyLnJlcXVlc3RSZW5kZXIoKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmVuZGVycyB0aGUgTkdMIGNhbnZhcy5cbiAgICpcbiAgICogQmVjYXVzZSB3ZSBhcmUgd29ya2luZyB3aXRoIFdlYkdMIHZpYSB0aGUgY2FudmFzLCB1cGRhdGluZyB0aGlzIHZpc3VhbGl6YXRpb24gaGFwcGVucyB0aHJvdWdoIHRoZSBjYW52YXMgcmVmZXJlbmNlLlxuICAgKlxuICAgKiBAcmV0dXJucyBUaGUgTkdMIENvbXBvbmVudFxuICAgKi9cbiAgcHVibGljIHJlbmRlcigpIHtcbiAgICBjb25zdCB7IGhlaWdodCwgaXNEYXRhTG9hZGluZywgc2hvd0NvbmZpZ3VyYXRpb25zLCBzdHlsZSwgd2lkdGggfSA9IHRoaXMucHJvcHM7XG5cbiAgICByZXR1cm4gKFxuICAgICAgPERpbW1lci5EaW1tYWJsZSBkaW1tZWQ9e3RydWV9PlxuICAgICAgICA8RGltbWVyIGFjdGl2ZT17aXNEYXRhTG9hZGluZ30+XG4gICAgICAgICAgPExvYWRlciAvPlxuICAgICAgICA8L0RpbW1lcj5cbiAgICAgICAgPFNldHRpbmdzUGFuZWwgY29uZmlndXJhdGlvbnM9e3RoaXMuZ2V0Q29uZmlndXJhdGlvbnMoKX0gc2hvd0NvbmZpZ3VyYXRpb25zPXtzaG93Q29uZmlndXJhdGlvbnN9PlxuICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiTkdMQ29tcG9uZW50XCIgc3R5bGU9e3sgLi4uc3R5bGUsIGhlaWdodCwgd2lkdGggfX0+XG4gICAgICAgICAgICA8ZGl2XG4gICAgICAgICAgICAgIGNsYXNzTmFtZT1cIk5HTENhbnZhc1wiXG4gICAgICAgICAgICAgIG9uS2V5RG93bj17dGhpcy5vbktleURvd259XG4gICAgICAgICAgICAgIG9uTW91c2VMZWF2ZT17dGhpcy5vbkNhbnZhc0xlYXZlfVxuICAgICAgICAgICAgICByZWY9e2VsID0+ICh0aGlzLmNhbnZhcyA9IGVsKX1cbiAgICAgICAgICAgICAgcm9sZT17J2ltZyd9XG4gICAgICAgICAgICAgIHN0eWxlPXt7IGhlaWdodDogJzEwMCUnLCB3aWR0aDogJzEwMCUnIH19XG4gICAgICAgICAgICAvPlxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICA8L1NldHRpbmdzUGFuZWw+XG4gICAgICA8L0RpbW1lci5EaW1tYWJsZT5cbiAgICApO1xuICB9XG5cbiAgcHJvdGVjdGVkIGluaXREYXRhKHN0YWdlOiBOR0wuU3RhZ2UsIHN0cnVjdHVyZT86IE5HTC5TdHJ1Y3R1cmUpIHtcbiAgICBzdGFnZS5yZW1vdmVBbGxDb21wb25lbnRzKCk7XG5cbiAgICBpZiAoc3RydWN0dXJlKSB7XG4gICAgICAvLyAhSU1QT1JUQU5UISBXZSBuZWVkIHRvIGRlZXBseSBjbG9uZSB0aGUgTkdMIGRhdGEhXG4gICAgICAvLyBJZiB3ZSBoYXZlIG11bHRpcGxlIE5HTCBjb21wb25lbnRzIGRpc3BsYXlpbmcgdGhlIHNhbWUgZGF0YSwgcmVtb3ZpbmcgdGhlIGNvbXBvbmVudCB3aWxsIGFmZmVjdFxuICAgICAgLy8gdGhlIG90aGVycyBiZWNhdXNlIHRoZXkgKGludGVybmFsbHkpIGRlbGV0ZSBrZXlzL3JlZmVyZW5jZXMuXG5cbiAgICAgIHRoaXMuYWRkU3RydWN0dXJlVG9TdGFnZShjbG9uZURlZXAoc3RydWN0dXJlKSwgc3RhZ2UpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgcGRiRGF0YTogdW5kZWZpbmVkLFxuICAgICAgICBzdHJ1Y3R1cmVDb21wb25lbnQ6IHVuZGVmaW5lZCxcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIHByb3RlY3RlZCBkZXJpdmVBY3RpdmVSZXByZXNlbnRhdGlvbnMoc3RydWN0dXJlQ29tcG9uZW50OiBOR0wuU3RydWN0dXJlQ29tcG9uZW50LCBwZGJEYXRhPzogQ2hlbGxQREIpIHtcbiAgICBjb25zdCB7IHJlc2lkdWVDb250ZXh0LCBzZWNvbmRhcnlTdHJ1Y3R1cmVDb250ZXh0IH0gPSB0aGlzLnByb3BzO1xuXG4gICAgcmV0dXJuIFtcbiAgICAgIC4uLnRoaXMuaGlnaGxpZ2h0Q2FuZGlkYXRlUmVzaWR1ZXMoXG4gICAgICAgIHN0cnVjdHVyZUNvbXBvbmVudCxcbiAgICAgICAgWy4uLnJlc2lkdWVDb250ZXh0LmNhbmRpZGF0ZVJlc2lkdWVzLCAuLi5yZXNpZHVlQ29udGV4dC5ob3ZlcmVkUmVzaWR1ZXNdXG4gICAgICAgICAgLmZpbHRlcigodmFsdWUsIGluZGV4LCBhcnJheSkgPT4gYXJyYXkuaW5kZXhPZih2YWx1ZSkgPT09IGluZGV4KVxuICAgICAgICAgIC5zb3J0KCksXG4gICAgICAgIHBkYkRhdGEsXG4gICAgICApLFxuICAgICAgLi4udGhpcy5oaWdobGlnaHRMb2NrZWREaXN0YW5jZVBhaXJzKHN0cnVjdHVyZUNvbXBvbmVudCwgcmVzaWR1ZUNvbnRleHQubG9ja2VkUmVzaWR1ZVBhaXJzLCBwZGJEYXRhKSxcbiAgICAgIC4uLnRoaXMuaGlnaGxpZ2h0U2Vjb25kYXJ5U3RydWN0dXJlcyhzdHJ1Y3R1cmVDb21wb25lbnQsIFtcbiAgICAgICAgLi4uc2Vjb25kYXJ5U3RydWN0dXJlQ29udGV4dC5ob3ZlcmVkU2Vjb25kYXJ5U3RydWN0dXJlcyxcbiAgICAgICAgLi4uc2Vjb25kYXJ5U3RydWN0dXJlQ29udGV4dC5zZWxlY3RlZFNlY29uZGFyeVN0cnVjdHVyZXMsXG4gICAgICBdKSxcbiAgICBdO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZHMgYSBOR0wgc3RydWN0dXJlIHRvIHRoZSBzdGFnZS5cbiAgICpcbiAgICogQHBhcmFtIHN0cnVjdHVyZSBBIE5HTCBTdHJ1Y3R1cmUuXG4gICAqIEBwYXJhbSBzdGFnZSBBIE5HTCBTdGFnZS5cbiAgICovXG4gIHByb3RlY3RlZCBhZGRTdHJ1Y3R1cmVUb1N0YWdlKHN0cnVjdHVyZTogTkdMLlN0cnVjdHVyZSwgc3RhZ2U6IE5HTC5TdGFnZSkge1xuICAgIGNvbnN0IHN0cnVjdHVyZUNvbXBvbmVudCA9IHN0YWdlLmFkZENvbXBvbmVudEZyb21PYmplY3Qoc3RydWN0dXJlKTtcblxuICAgIHN0cnVjdHVyZUNvbXBvbmVudC5zdGFnZS5tb3VzZUNvbnRyb2xzLmFkZChcbiAgICAgIE5HTC5Nb3VzZUFjdGlvbnMuSE9WRVJfUElDSyxcbiAgICAgIChhU3RhZ2U6IE5HTC5TdGFnZSwgcGlja2luZ1Byb3h5OiBOR0wuUGlja2luZ1Byb3h5KSA9PiB7XG4gICAgICAgIHRoaXMub25Ib3ZlcihhU3RhZ2UsIHBpY2tpbmdQcm94eSk7XG4gICAgICB9LFxuICAgICk7XG5cbiAgICBzdGFnZS5kZWZhdWx0RmlsZVJlcHJlc2VudGF0aW9uKHN0cnVjdHVyZUNvbXBvbmVudCk7XG4gICAgc3RhZ2Uuc2lnbmFscy5jbGlja2VkLmFkZCh0aGlzLm9uQ2xpY2spO1xuICAgIGNvbnN0IHBkYkRhdGEgPSBDaGVsbFBEQi5jcmVhdGVQREJGcm9tTkdMRGF0YShzdHJ1Y3R1cmUpO1xuICAgIGNvbnN0IGFjdGl2ZVJlcHJlc2VudGF0aW9ucyA9IHRoaXMuZGVyaXZlQWN0aXZlUmVwcmVzZW50YXRpb25zKHN0cnVjdHVyZUNvbXBvbmVudCwgcGRiRGF0YSk7XG4gICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICBhY3RpdmVSZXByZXNlbnRhdGlvbnMsXG4gICAgICBwZGJEYXRhLFxuICAgICAgc3RydWN0dXJlQ29tcG9uZW50LFxuICAgIH0pO1xuICAgIHN0YWdlLnZpZXdlci5yZXF1ZXN0UmVuZGVyKCk7XG4gIH1cblxuICBwcm90ZWN0ZWQgZ2V0Q29uZmlndXJhdGlvbnMgPSAoKSA9PiB7XG4gICAgY29uc3QgeyByZXNpZHVlQ29udGV4dCB9ID0gdGhpcy5wcm9wcztcblxuICAgIHJldHVybiBbXG4gICAgICB7XG4gICAgICAgIG5hbWU6ICdDbGVhciBTZWxlY3Rpb25zJyxcbiAgICAgICAgb25DbGljazogcmVzaWR1ZUNvbnRleHQucmVtb3ZlQWxsTG9ja2VkUmVzaWR1ZVBhaXJzLFxuICAgICAgICB0eXBlOiBDT05GSUdVUkFUSU9OX0NPTVBPTkVOVF9UWVBFLkJVVFRPTixcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGN1cnJlbnQ6IENPTlRBQ1RfRElTVEFOQ0VfUFJPWElNSVRZLkNMT1NFU1QsXG4gICAgICAgIG5hbWU6ICdNZWFzdXJpbmcgUHJveGltaXR5JyxcbiAgICAgICAgb25DaGFuZ2U6IHRoaXMubWVhc3VyZWRQcm94aW1pdHlIYW5kbGVyLFxuICAgICAgICBvcHRpb25zOiBPYmplY3QudmFsdWVzKENPTlRBQ1RfRElTVEFOQ0VfUFJPWElNSVRZKS5tYXAoY2FwaXRhbGl6ZUZpcnN0TGV0dGVyKSxcbiAgICAgICAgdHlwZTogQ09ORklHVVJBVElPTl9DT01QT05FTlRfVFlQRS5SQURJTyxcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGN1cnJlbnQ6ICdkZWZhdWx0JyxcbiAgICAgICAgbmFtZTogJ1N0cnVjdHVyZSBSZXByZXNlbnRhdGlvbiBUeXBlJyxcbiAgICAgICAgb25DaGFuZ2U6ICh2YWx1ZTogbnVtYmVyKSA9PiB7XG4gICAgICAgICAgY29uc3QgeyBzdGFnZSwgc3RydWN0dXJlQ29tcG9uZW50IH0gPSB0aGlzLnN0YXRlO1xuICAgICAgICAgIGNvbnN0IHJlcHMgPSBbJ2RlZmF1bHQnLCAnc3BhY2VmaWxsJywgJ2JhY2tib25lJywgJ2NhcnRvb24nLCAnc3VyZmFjZScsICd0dWJlJ107XG4gICAgICAgICAgaWYgKHN0YWdlICYmIHN0cnVjdHVyZUNvbXBvbmVudCkge1xuICAgICAgICAgICAgc3RydWN0dXJlQ29tcG9uZW50LnJlbW92ZUFsbFJlcHJlc2VudGF0aW9ucygpO1xuICAgICAgICAgICAgaWYgKHZhbHVlID09PSAwKSB7XG4gICAgICAgICAgICAgIHN0YWdlLmRlZmF1bHRGaWxlUmVwcmVzZW50YXRpb24oc3RydWN0dXJlQ29tcG9uZW50KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHN0cnVjdHVyZUNvbXBvbmVudC5hZGRSZXByZXNlbnRhdGlvbihyZXBzW3ZhbHVlXSBhcyBOR0wuU3RydWN0dXJlUmVwcmVzZW50YXRpb25UeXBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICAgICAgICBhY3RpdmVSZXByZXNlbnRhdGlvbnM6IHRoaXMuZGVyaXZlQWN0aXZlUmVwcmVzZW50YXRpb25zKHN0cnVjdHVyZUNvbXBvbmVudCwgdGhpcy5zdGF0ZS5wZGJEYXRhKSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgc3RhZ2Uudmlld2VyLnJlcXVlc3RSZW5kZXIoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIG9wdGlvbnM6IE9iamVjdC52YWx1ZXMoWydEZWZhdWx0JywgJ1NwYWNlZmlsbCcsICdCYWNrYm9uZScsICdDYXJ0b29uJywgJ1N1cmZhY2UnLCAnVHViZSddKSxcbiAgICAgICAgdHlwZTogQ09ORklHVVJBVElPTl9DT01QT05FTlRfVFlQRS5SQURJTyxcbiAgICAgIH0sXG4gICAgXSBhcyBDaGVsbFdpZGdldENvbmZpZ1tdO1xuICB9O1xuXG4gIHByb3RlY3RlZCBvbkNsaWNrID0gKHBpY2tpbmdQcm94eTogTkdMLlBpY2tpbmdQcm94eSkgPT4ge1xuICAgIGNvbnN0IHsgcmVzaWR1ZUNvbnRleHQgfSA9IHRoaXMucHJvcHM7XG4gICAgY29uc3QgeyBzdHJ1Y3R1cmVDb21wb25lbnQgfSA9IHRoaXMuc3RhdGU7XG4gICAgaWYgKHRoaXMuY2FudmFzICYmIHN0cnVjdHVyZUNvbXBvbmVudCkge1xuICAgICAgaWYgKHBpY2tpbmdQcm94eSkge1xuICAgICAgICBjb25zdCBpc0Rpc3RhbmNlUGlja2VyID0gcGlja2luZ1Byb3h5LnBpY2tlciAmJiBwaWNraW5nUHJveHkucGlja2VyLnR5cGUgPT09ICdkaXN0YW5jZSc7XG5cbiAgICAgICAgaWYgKGlzRGlzdGFuY2VQaWNrZXIpIHtcbiAgICAgICAgICBjb25zdCByZXNpZHVlcyA9IFtwaWNraW5nUHJveHkuZGlzdGFuY2UuYXRvbTEucmVzbm8sIHBpY2tpbmdQcm94eS5kaXN0YW5jZS5hdG9tMi5yZXNub107XG4gICAgICAgICAgcmVzaWR1ZUNvbnRleHQucmVtb3ZlTG9ja2VkUmVzaWR1ZVBhaXIocmVzaWR1ZXMpO1xuICAgICAgICB9IGVsc2UgaWYgKHBpY2tpbmdQcm94eS5hdG9tIHx8IHBpY2tpbmdQcm94eS5jbG9zZXN0Qm9uZEF0b20pIHtcbiAgICAgICAgICBjb25zdCBhdG9tID0gcGlja2luZ1Byb3h5LmF0b20gfHwgcGlja2luZ1Byb3h5LmNsb3Nlc3RCb25kQXRvbTtcblxuICAgICAgICAgIGlmIChyZXNpZHVlQ29udGV4dC5jYW5kaWRhdGVSZXNpZHVlcy5sZW5ndGggPj0gMSkge1xuICAgICAgICAgICAgcmVzaWR1ZUNvbnRleHQuYWRkTG9ja2VkUmVzaWR1ZVBhaXIoWy4uLnJlc2lkdWVDb250ZXh0LmNhbmRpZGF0ZVJlc2lkdWVzLCBhdG9tLnJlc25vXSk7XG4gICAgICAgICAgICByZXNpZHVlQ29udGV4dC5yZW1vdmVDYW5kaWRhdGVSZXNpZHVlcygpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXNpZHVlQ29udGV4dC5hZGRDYW5kaWRhdGVSZXNpZHVlcyhbYXRvbS5yZXNub10pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChyZXNpZHVlQ29udGV4dC5jYW5kaWRhdGVSZXNpZHVlcy5sZW5ndGggPj0gMSAmJiByZXNpZHVlQ29udGV4dC5ob3ZlcmVkUmVzaWR1ZXMubGVuZ3RoID49IDEpIHtcbiAgICAgICAgcmVzaWR1ZUNvbnRleHQuaG92ZXJlZFJlc2lkdWVzLmZvckVhY2gocmVzaWR1ZUluZGV4ID0+IHtcbiAgICAgICAgICBjb25zdCBnZXRNaW5EaXN0ID0gKHJlc2lkdWVTdG9yZTogTkdMLlJlc2lkdWVTdG9yZSwgdGFyZ2V0OiBWZWN0b3IyKSA9PiB7XG4gICAgICAgICAgICBsZXQgbWluRGlzdCA9IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSO1xuICAgICAgICAgICAgY29uc3QgYXRvbU9mZnNldCA9IHJlc2lkdWVTdG9yZS5hdG9tT2Zmc2V0W3Jlc2lkdWVJbmRleF07XG4gICAgICAgICAgICBjb25zdCBhdG9tQ291bnQgPSByZXNpZHVlU3RvcmUuYXRvbUNvdW50W3Jlc2lkdWVJbmRleF07XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGF0b21Db3VudDsgKytpKSB7XG4gICAgICAgICAgICAgIGNvbnN0IGF0b21Qcm94eSA9IHN0cnVjdHVyZUNvbXBvbmVudC5zdHJ1Y3R1cmUuZ2V0QXRvbVByb3h5KGF0b21PZmZzZXQgKyBpKTtcbiAgICAgICAgICAgICAgY29uc3QgYXRvbVBvc2l0aW9uID0gc3RydWN0dXJlQ29tcG9uZW50LnN0YWdlLnZpZXdlckNvbnRyb2xzLmdldFBvc2l0aW9uT25DYW52YXMoXG4gICAgICAgICAgICAgICAgYXRvbVByb3h5LnBvc2l0aW9uVG9WZWN0b3IzKCksXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIG1pbkRpc3QgPSBNYXRoLm1pbihtaW5EaXN0LCB0YXJnZXQuZGlzdGFuY2VUbyhhdG9tUG9zaXRpb24pKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIG1pbkRpc3Q7XG4gICAgICAgICAgfTtcblxuICAgICAgICAgIC8vICEgSU1QT1JUQU5UICFcbiAgICAgICAgICAvLyBUaGlzIGlzIGEgcmF0aGVyIGJydXRlIGZvcmNlIGFwcHJvYWNoIHRvIHNlZSBpZiB0aGUgbW91c2UgaXMgY2xvc2UgdG8gYSByZXNpZHVlLlxuICAgICAgICAgIC8vIFRoZSBtYWluIHByb2JsZW0gaXMgX19yZWxpYWJseV9fIGdldHRpbmcgdGhlICh4LHkpIG9mIHdoZXJlIHRoZSB1c2VyIGNsaWNrZWQgYW5kIHRoZSBcInJlc2lkdWVcIiB0aGV5IHdlcmUgY2xvc2VzdCB0by5cbiAgICAgICAgICBjb25zdCB7IGRvd24sIGNhbnZhc1Bvc2l0aW9uLCBwb3NpdGlvbiwgcHJldkNsaWNrQ1AsIHByZXZQb3NpdGlvbiB9ID0gc3RydWN0dXJlQ29tcG9uZW50LnN0YWdlLm1vdXNlT2JzZXJ2ZXI7XG4gICAgICAgICAgY29uc3QgbWluRGlzdGFuY2VzID0gW2Rvd24sIGNhbnZhc1Bvc2l0aW9uLCBwcmV2Q2xpY2tDUCwgcHJldlBvc2l0aW9uLCBwb3NpdGlvbl0ubWFwKHBvcyA9PlxuICAgICAgICAgICAgZ2V0TWluRGlzdChzdHJ1Y3R1cmVDb21wb25lbnQuc3RydWN0dXJlLnJlc2lkdWVTdG9yZSwgcG9zKSxcbiAgICAgICAgICApO1xuXG4gICAgICAgICAgLy8gU2hvcnRoYW5kIHRvIG1ha2UgaXQgY2xlYXJlciB0aGF0IHRoaXMgbWV0aG9kIGlzIGp1c3QgY2hlY2tpbmcgaWYgYW55IGRpc3RhbmNlIGlzIHdpdGhpbiAxMDAuXG4gICAgICAgICAgY29uc3QgaXNXaXRoaW5TbmFwcGluZ0Rpc3RhbmNlID0gKGRpc3RhbmNlczogbnVtYmVyW10sIGxpbWl0ID0gMTAwKSA9PlxuICAgICAgICAgICAgZGlzdGFuY2VzLmZpbHRlcihkaXN0ID0+IGRpc3QgPCBsaW1pdCkubGVuZ3RoID49IDE7XG5cbiAgICAgICAgICBpZiAoaXNXaXRoaW5TbmFwcGluZ0Rpc3RhbmNlKG1pbkRpc3RhbmNlcykpIHtcbiAgICAgICAgICAgIHJlc2lkdWVDb250ZXh0LmFkZExvY2tlZFJlc2lkdWVQYWlyKFsuLi5yZXNpZHVlQ29udGV4dC5jYW5kaWRhdGVSZXNpZHVlcywgcmVzaWR1ZUluZGV4XSk7XG4gICAgICAgICAgICByZXNpZHVlQ29udGV4dC5yZW1vdmVDYW5kaWRhdGVSZXNpZHVlcygpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXNpZHVlQ29udGV4dC5yZW1vdmVOb25Mb2NrZWRSZXNpZHVlcygpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBVc2VyIGNsaWNrZWQgb2ZmLXN0cnVjdHVyZSwgc28gY2xlYXIgbm9uLWxvY2tlZCByZXNpZHVlIHN0YXRlLlxuICAgICAgICByZXNpZHVlQ29udGV4dC5yZW1vdmVOb25Mb2NrZWRSZXNpZHVlcygpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBwcm90ZWN0ZWQgb25Ib3ZlcihhU3RhZ2U6IE5HTC5TdGFnZSwgcGlja2luZ1Byb3h5OiBOR0wuUGlja2luZ1Byb3h5KSB7XG4gICAgY29uc3QgeyByZXNpZHVlQ29udGV4dCB9ID0gdGhpcy5wcm9wcztcbiAgICBjb25zdCB7IHN0cnVjdHVyZUNvbXBvbmVudCwgc3RhZ2UgfSA9IHRoaXMuc3RhdGU7XG4gICAgaWYgKHN0YWdlICYmIHN0cnVjdHVyZUNvbXBvbmVudCkge1xuICAgICAgaWYgKHBpY2tpbmdQcm94eSAmJiAocGlja2luZ1Byb3h5LmF0b20gfHwgcGlja2luZ1Byb3h5LmNsb3Nlc3RCb25kQXRvbSkpIHtcbiAgICAgICAgY29uc3QgYXRvbSA9IHBpY2tpbmdQcm94eS5hdG9tIHx8IHBpY2tpbmdQcm94eS5jbG9zZXN0Qm9uZEF0b207XG4gICAgICAgIGNvbnN0IHJlc25hbWUgPSBBTUlOT19BQ0lEU19CWV9USFJFRV9MRVRURVJfQ09ERVthdG9tLnJlc25hbWUgYXMgQU1JTk9fQUNJRF9USFJFRV9MRVRURVJfQ09ERV1cbiAgICAgICAgICA/IEFNSU5PX0FDSURTX0JZX1RIUkVFX0xFVFRFUl9DT0RFW2F0b20ucmVzbmFtZSBhcyBBTUlOT19BQ0lEX1RIUkVFX0xFVFRFUl9DT0RFXS5zaW5nbGVMZXR0ZXJDb2RlXG4gICAgICAgICAgOiBhdG9tLnJlc25hbWU7XG4gICAgICAgIHN0YWdlLnRvb2x0aXAudGV4dENvbnRlbnQgPSBgJHthdG9tLnJlc25vfSR7cmVzbmFtZX1gO1xuICAgICAgICByZXNpZHVlQ29udGV4dC5hZGRIb3ZlcmVkUmVzaWR1ZXMoW2F0b20ucmVzbm9dKTtcbiAgICAgIH0gZWxzZSBpZiAocmVzaWR1ZUNvbnRleHQuY2FuZGlkYXRlUmVzaWR1ZXMubGVuZ3RoID09PSAwICYmIHJlc2lkdWVDb250ZXh0LmhvdmVyZWRSZXNpZHVlcy5sZW5ndGggIT09IDApIHtcbiAgICAgICAgcmVzaWR1ZUNvbnRleHQucmVtb3ZlSG92ZXJlZFJlc2lkdWVzKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcHJvdGVjdGVkIG1lYXN1cmVkUHJveGltaXR5SGFuZGxlciA9ICh2YWx1ZTogbnVtYmVyKSA9PiB7XG4gICAgY29uc3QgeyBvbk1lYXN1cmVkUHJveGltaXR5Q2hhbmdlIH0gPSB0aGlzLnByb3BzO1xuICAgIGlmIChvbk1lYXN1cmVkUHJveGltaXR5Q2hhbmdlKSB7XG4gICAgICBvbk1lYXN1cmVkUHJveGltaXR5Q2hhbmdlKHZhbHVlKTtcbiAgICB9XG4gIH07XG5cbiAgcHJvdGVjdGVkIGdldERpc3RhbmNlUmVwRm9yUmVzaWR1ZXMoXG4gICAgc3RydWN0dXJlQ29tcG9uZW50OiBOR0wuU3RydWN0dXJlQ29tcG9uZW50LFxuICAgIHJlc2lkdWVzOiBSRVNJRFVFX1RZUEVbXSxcbiAgICBwZGJEYXRhOiBDaGVsbFBEQixcbiAgKSB7XG4gICAgY29uc3QgeyBtZWFzdXJlZFByb3hpbWl0eSB9ID0gdGhpcy5wcm9wcztcblxuICAgIGlmIChtZWFzdXJlZFByb3hpbWl0eSA9PT0gQ09OVEFDVF9ESVNUQU5DRV9QUk9YSU1JVFkuQ19BTFBIQSkge1xuICAgICAgcmV0dXJuIGNyZWF0ZURpc3RhbmNlUmVwcmVzZW50YXRpb24oc3RydWN0dXJlQ29tcG9uZW50LCBgJHtyZXNpZHVlcy5qb2luKCcuQ0EsICcpfS5DQWApO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCB7IGF0b21JbmRleEksIGF0b21JbmRleEogfSA9IHBkYkRhdGEuZ2V0TWluRGlzdEJldHdlZW5SZXNpZHVlcyhyZXNpZHVlc1swXSwgcmVzaWR1ZXNbMV0pO1xuXG4gICAgICByZXR1cm4gY3JlYXRlRGlzdGFuY2VSZXByZXNlbnRhdGlvbihzdHJ1Y3R1cmVDb21wb25lbnQsIFthdG9tSW5kZXhJLCBhdG9tSW5kZXhKXSk7XG4gICAgfVxuICB9XG5cbiAgcHJvdGVjdGVkIGhpZ2hsaWdodENhbmRpZGF0ZVJlc2lkdWVzKFxuICAgIHN0cnVjdHVyZUNvbXBvbmVudDogTkdMLlN0cnVjdHVyZUNvbXBvbmVudCxcbiAgICByZXNpZHVlczogUkVTSURVRV9UWVBFW10sXG4gICAgcGRiRGF0YT86IENoZWxsUERCLFxuICApIHtcbiAgICBjb25zdCByZXBzID0gbmV3IEFycmF5PE5HTC5SZXByZXNlbnRhdGlvbkVsZW1lbnQ+KCk7XG5cbiAgICBpZiAocmVzaWR1ZXMubGVuZ3RoID49IDEpIHtcbiAgICAgIHJlcHMucHVzaChjcmVhdGVCYWxsU3RpY2tSZXByZXNlbnRhdGlvbihzdHJ1Y3R1cmVDb21wb25lbnQsIHJlc2lkdWVzKSk7XG4gICAgICBpZiAocmVzaWR1ZXMubGVuZ3RoID49IDIgJiYgcGRiRGF0YSkge1xuICAgICAgICByZXBzLnB1c2godGhpcy5nZXREaXN0YW5jZVJlcEZvclJlc2lkdWVzKHN0cnVjdHVyZUNvbXBvbmVudCwgcmVzaWR1ZXMsIHBkYkRhdGEpKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcmVwcztcbiAgfVxuXG4gIHByb3RlY3RlZCBoaWdobGlnaHRMb2NrZWREaXN0YW5jZVBhaXJzKFxuICAgIHN0cnVjdHVyZUNvbXBvbmVudDogTkdMLlN0cnVjdHVyZUNvbXBvbmVudCxcbiAgICBsb2NrZWRSZXNpZHVlczogUmVzaWR1ZVNlbGVjdGlvbixcbiAgICBwZGJEYXRhPzogQ2hlbGxQREIsXG4gICkge1xuICAgIGNvbnN0IHJlcHMgPSBuZXcgQXJyYXk8TkdMLlJlcHJlc2VudGF0aW9uRWxlbWVudD4oKTtcblxuICAgIGxvY2tlZFJlc2lkdWVzLmZvckVhY2gocmVzaWR1ZXMgPT4ge1xuICAgICAgcmVwcy5wdXNoKGNyZWF0ZUJhbGxTdGlja1JlcHJlc2VudGF0aW9uKHN0cnVjdHVyZUNvbXBvbmVudCwgcmVzaWR1ZXMpKTtcblxuICAgICAgaWYgKHJlc2lkdWVzLmxlbmd0aCA+PSAyICYmIHBkYkRhdGEpIHtcbiAgICAgICAgcmVwcy5wdXNoKHRoaXMuZ2V0RGlzdGFuY2VSZXBGb3JSZXNpZHVlcyhzdHJ1Y3R1cmVDb21wb25lbnQsIHJlc2lkdWVzLCBwZGJEYXRhKSk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gcmVwcztcbiAgfVxuXG4gIHByb3RlY3RlZCBoaWdobGlnaHRTZWNvbmRhcnlTdHJ1Y3R1cmVzKFxuICAgIHN0cnVjdHVyZUNvbXBvbmVudDogTkdMLlN0cnVjdHVyZUNvbXBvbmVudCxcbiAgICBzZWNvbmRhcnlTdHJ1Y3R1cmVzOiBTRUNPTkRBUllfU1RSVUNUVVJFLFxuICApIHtcbiAgICBjb25zdCByZXBzID0gbmV3IEFycmF5PE5HTC5SZXByZXNlbnRhdGlvbkVsZW1lbnQ+KCk7XG5cbiAgICBmb3IgKGNvbnN0IHN0cnVjdHVyZSBvZiBzZWNvbmRhcnlTdHJ1Y3R1cmVzKSB7XG4gICAgICByZXBzLnB1c2goY3JlYXRlU2VjU3RydWN0UmVwcmVzZW50YXRpb24oc3RydWN0dXJlQ29tcG9uZW50LCBzdHJ1Y3R1cmUpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVwcztcbiAgfVxuXG4gIHByb3RlY3RlZCBvbkNhbnZhc0xlYXZlID0gKCkgPT4ge1xuICAgIGNvbnN0IHsgcmVzaWR1ZUNvbnRleHQgfSA9IHRoaXMucHJvcHM7XG4gICAgcmVzaWR1ZUNvbnRleHQucmVtb3ZlTm9uTG9ja2VkUmVzaWR1ZXMoKTtcbiAgfTtcblxuICBwcm90ZWN0ZWQgb25SZXNpemVIYW5kbGVyID0gKGV2ZW50PzogVUlFdmVudCkgPT4ge1xuICAgIGNvbnN0IHsgb25SZXNpemUgfSA9IHRoaXMucHJvcHM7XG4gICAgY29uc3QgeyBzdGFnZSB9ID0gdGhpcy5zdGF0ZTtcbiAgICBpZiAoc3RhZ2UpIHtcbiAgICAgIHN0YWdlLmhhbmRsZVJlc2l6ZSgpO1xuICAgIH1cbiAgICBpZiAob25SZXNpemUpIHtcbiAgICAgIG9uUmVzaXplKGV2ZW50KTtcbiAgICB9XG4gIH07XG5cbiAgcHJvdGVjdGVkIG9uS2V5RG93biA9IChlOiBSZWFjdC5LZXlib2FyZEV2ZW50KSA9PiB7XG4gICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIGNvbnN0IEVTQ19LRVlfQ09ERSA9IDI3O1xuXG4gICAgaWYgKGUud2hpY2ggPT09IEVTQ19LRVlfQ09ERSB8fCBlLmtleUNvZGUgPT09IEVTQ19LRVlfQ09ERSkge1xuICAgICAgY29uc3QgeyByZXNpZHVlQ29udGV4dCB9ID0gdGhpcy5wcm9wcztcbiAgICAgIHJlc2lkdWVDb250ZXh0LnJlbW92ZU5vbkxvY2tlZFJlc2lkdWVzKCk7XG4gICAgfVxuICB9O1xuXG4gIHByb3RlY3RlZCBnZW5lcmF0ZVN0YWdlID0gKGNhbnZhczogSFRNTEVsZW1lbnQsIHBhcmFtcz86IE5HTC5QYXJ0aWFsPE5HTC5JU3RhZ2VQYXJhbWV0ZXJzPikgPT4ge1xuICAgIGNvbnN0IHN0YWdlID0gbmV3IE5HTC5TdGFnZShjYW52YXMsIHBhcmFtcyk7XG5cbiAgICAvLyAhSU1QT1JUQU5UISBUaGlzIGlzIG5lZWRlZCB0byBwcmV2ZW50IHRoZSBjYW52YXMgc2hpZnRpbmcgd2hlbiB0aGUgdXNlciBjbGlja3MgdGhlIGNhbnZhcy5cbiAgICAvLyBJdCdzIHVuY2xlYXIgd2h5IHRoZSBmb2N1cyBkb2VzIHRoaXMsIGJ1dCBpdCdzIHVuZGVzaXJhYmxlLlxuICAgIHN0YWdlLmtleUJlaGF2aW9yLmRvbUVsZW1lbnQuZm9jdXMgPSAoKSA9PiB7XG4gICAgICByZXR1cm47XG4gICAgfTtcblxuICAgIHJldHVybiBzdGFnZTtcbiAgfTtcbn1cblxudHlwZSByZXF1aXJlZFByb3BzID0gT21pdDxJTkdMQ29tcG9uZW50UHJvcHMsIGtleW9mIHR5cGVvZiBOR0xDb21wb25lbnRDbGFzcy5kZWZhdWx0UHJvcHM+ICZcbiAgUGFydGlhbDxJTkdMQ29tcG9uZW50UHJvcHM+O1xuXG5jb25zdCBOR0xDb21wb25lbnQgPSAocHJvcHM6IHJlcXVpcmVkUHJvcHMpID0+IChcbiAgPFJlc2lkdWVDb250ZXh0Q29uc3VtZXI+XG4gICAge3Jlc2lkdWVDb250ZXh0ID0+IChcbiAgICAgIDxTZWNvbmRhcnlTdHJ1Y3R1cmVDb250ZXh0Q29uc3VtZXI+XG4gICAgICAgIHtzZWNvbmRhcnlTdHJ1Y3R1cmVDb250ZXh0ID0+IChcbiAgICAgICAgICA8TkdMQ29tcG9uZW50Q2xhc3NcbiAgICAgICAgICAgIHJlc2lkdWVDb250ZXh0PXtyZXNpZHVlQ29udGV4dH1cbiAgICAgICAgICAgIHNlY29uZGFyeVN0cnVjdHVyZUNvbnRleHQ9e3NlY29uZGFyeVN0cnVjdHVyZUNvbnRleHR9XG4gICAgICAgICAgICB7Li4ucHJvcHN9XG4gICAgICAgICAgLz5cbiAgICAgICAgKX1cbiAgICAgIDwvU2Vjb25kYXJ5U3RydWN0dXJlQ29udGV4dENvbnN1bWVyPlxuICAgICl9XG4gIDwvUmVzaWR1ZUNvbnRleHRDb25zdW1lcj5cbik7XG5cbmV4cG9ydCB7IE5HTENvbXBvbmVudCB9O1xuIiwiaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xuXG5pbXBvcnQgeyBDb250YWN0TWFwLCBnZW5lcmF0ZUNoYXJ0RGF0YUVudHJ5LCBJQ29udGFjdE1hcENoYXJ0RGF0YSB9IGZyb20gJ35jaGVsbC12aXp+L2NvbXBvbmVudCc7XG5pbXBvcnQge1xuICBDSEVMTF9DU1NfU1RZTEUsXG4gIENoZWxsV2lkZ2V0Q29uZmlnLFxuICBDT05GSUdVUkFUSU9OX0NPTVBPTkVOVF9UWVBFLFxuICBDb3VwbGluZ0NvbnRhaW5lcixcbiAgSUNvbnRhY3RNYXBEYXRhLFxuICBTRUNPTkRBUllfU1RSVUNUVVJFLFxufSBmcm9tICd+Y2hlbGwtdml6fi9kYXRhJztcblxuZXhwb3J0IGludGVyZmFjZSBJUHJlZGljdGVkQ29udGFjdE1hcFByb3BzIHtcbiAgY29ycmVjdENvbG9yOiBzdHJpbmc7XG4gIGRhdGE6IElDb250YWN0TWFwRGF0YTtcbiAgaGVpZ2h0OiBudW1iZXIgfCBzdHJpbmc7XG4gIGluY29ycmVjdENvbG9yOiBzdHJpbmc7XG4gIGlzRGF0YUxvYWRpbmc6IGJvb2xlYW47XG4gIHN0eWxlPzogQ0hFTExfQ1NTX1NUWUxFO1xuICB3aWR0aDogbnVtYmVyIHwgc3RyaW5nO1xufVxuXG5leHBvcnQgY29uc3QgaW5pdGlhbFByZWRpY3RlZENvbnRhY3RNYXBTdGF0ZSA9IHtcbiAgbGluZWFyRGlzdEZpbHRlcjogNSxcbiAgbnVtUHJlZGljdGlvbnNUb1Nob3c6IC0xLFxuICBwb2ludHNUb1Bsb3Q6IFtdIGFzIElDb250YWN0TWFwQ2hhcnREYXRhW10sXG59O1xuXG5leHBvcnQgdHlwZSBQcmVkaWN0ZWRDb250YWN0TWFwU3RhdGUgPSB0eXBlb2YgaW5pdGlhbFByZWRpY3RlZENvbnRhY3RNYXBTdGF0ZTtcblxuZXhwb3J0IGNsYXNzIFByZWRpY3RlZENvbnRhY3RNYXAgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQ8SVByZWRpY3RlZENvbnRhY3RNYXBQcm9wcywgUHJlZGljdGVkQ29udGFjdE1hcFN0YXRlPiB7XG4gIHB1YmxpYyBzdGF0aWMgZGVmYXVsdFByb3BzID0ge1xuICAgIGNvcnJlY3RDb2xvcjogJyNmZjAwMDAnLFxuICAgIGRhdGE6IHtcbiAgICAgIGNvdXBsaW5nU2NvcmVzOiBuZXcgQ291cGxpbmdDb250YWluZXIoKSxcbiAgICAgIHNlY29uZGFyeVN0cnVjdHVyZXM6IG5ldyBBcnJheTxTRUNPTkRBUllfU1RSVUNUVVJFPigpLFxuICAgIH0sXG4gICAgaGVpZ2h0OiAnMTAwJScsXG4gICAgaW5jb3JyZWN0Q29sb3I6ICcjMDAwMDAwJyxcbiAgICBpc0RhdGFMb2FkaW5nOiBmYWxzZSxcbiAgICB3aWR0aDogJzEwMCUnLFxuICB9O1xuXG4gIHB1YmxpYyByZWFkb25seSBzdGF0ZTogUHJlZGljdGVkQ29udGFjdE1hcFN0YXRlID0gaW5pdGlhbFByZWRpY3RlZENvbnRhY3RNYXBTdGF0ZTtcblxuICBjb25zdHJ1Y3Rvcihwcm9wczogSVByZWRpY3RlZENvbnRhY3RNYXBQcm9wcykge1xuICAgIHN1cGVyKHByb3BzKTtcbiAgfVxuXG4gIHB1YmxpYyBvbkxpbmVhckRpc3RGaWx0ZXJDaGFuZ2UgPSAoKSA9PiAodmFsdWU6IG51bWJlcikgPT4ge1xuICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgbGluZWFyRGlzdEZpbHRlcjogdmFsdWUsXG4gICAgfSk7XG4gIH07XG5cbiAgcHVibGljIG9uTnVtUHJlZGljdGlvbnNUb1Nob3dDaGFuZ2UgPSAoKSA9PiAodmFsdWU6IG51bWJlcikgPT4ge1xuICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgbnVtUHJlZGljdGlvbnNUb1Nob3c6IHZhbHVlLFxuICAgIH0pO1xuICB9O1xuXG4gIHB1YmxpYyBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICB0aGlzLnNldHVwRGF0YSh0cnVlKTtcbiAgfVxuXG4gIHB1YmxpYyBjb21wb25lbnREaWRVcGRhdGUocHJldlByb3BzOiBJUHJlZGljdGVkQ29udGFjdE1hcFByb3BzLCBwcmV2U3RhdGU6IFByZWRpY3RlZENvbnRhY3RNYXBTdGF0ZSkge1xuICAgIGNvbnN0IHsgZGF0YSB9ID0gdGhpcy5wcm9wcztcbiAgICBjb25zdCB7IGxpbmVhckRpc3RGaWx0ZXIsIG51bVByZWRpY3Rpb25zVG9TaG93IH0gPSB0aGlzLnN0YXRlO1xuXG4gICAgY29uc3QgaXNSZWNvbXB1dGVOZWVkZWQgPVxuICAgICAgZGF0YS5jb3VwbGluZ1Njb3JlcyAhPT0gcHJldlByb3BzLmRhdGEuY291cGxpbmdTY29yZXMgfHxcbiAgICAgIGxpbmVhckRpc3RGaWx0ZXIgIT09IHByZXZTdGF0ZS5saW5lYXJEaXN0RmlsdGVyIHx8XG4gICAgICBudW1QcmVkaWN0aW9uc1RvU2hvdyAhPT0gcHJldlN0YXRlLm51bVByZWRpY3Rpb25zVG9TaG93O1xuICAgIGlmIChpc1JlY29tcHV0ZU5lZWRlZCkge1xuICAgICAgdGhpcy5zZXR1cERhdGEoZGF0YS5jb3VwbGluZ1Njb3JlcyAhPT0gcHJldlByb3BzLmRhdGEuY291cGxpbmdTY29yZXMpO1xuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyByZW5kZXIoKSB7XG4gICAgY29uc3QgeyBkYXRhLCBzdHlsZSwgLi4ucGFzc1Rocm91Z2hQcm9wcyB9ID0gdGhpcy5wcm9wcztcbiAgICBjb25zdCB7IHBvaW50c1RvUGxvdCB9ID0gdGhpcy5zdGF0ZTtcblxuICAgIHJldHVybiAoXG4gICAgICA8ZGl2IGNsYXNzTmFtZT1cIlByZWRpY3RlZENvbnRhY3RNYXBDb21wb25lbnRcIiBzdHlsZT17c3R5bGV9PlxuICAgICAgICA8Q29udGFjdE1hcFxuICAgICAgICAgIGNvbmZpZ3VyYXRpb25zPXt0aGlzLmdldENvbnRhY3RNYXBDb25maWdzKCl9XG4gICAgICAgICAgZGF0YT17e1xuICAgICAgICAgICAgY291cGxpbmdTY29yZXM6IGRhdGEuY291cGxpbmdTY29yZXMsXG4gICAgICAgICAgICBwZGJEYXRhOiBkYXRhLnBkYkRhdGEsXG4gICAgICAgICAgICBzZWNvbmRhcnlTdHJ1Y3R1cmVzOiBkYXRhLnBkYkRhdGEgPyBkYXRhLnBkYkRhdGEuc2Vjb25kYXJ5U3RydWN0dXJlU2VjdGlvbnMgOiBbXSxcbiAgICAgICAgICB9fVxuICAgICAgICAgIGZvcm1hdHRlZFBvaW50cz17cG9pbnRzVG9QbG90fVxuICAgICAgICAgIHsuLi5wYXNzVGhyb3VnaFByb3BzfVxuICAgICAgICAvPlxuICAgICAgPC9kaXY+XG4gICAgKTtcbiAgfVxuXG4gIHByb3RlY3RlZCBnZXRDb250YWN0TWFwQ29uZmlncyA9ICgpOiBDaGVsbFdpZGdldENvbmZpZ1tdID0+IFtcbiAgICB7XG4gICAgICBuYW1lOiAnTGluZWFyIERpc3RhbmNlIEZpbHRlciAofGkgLSBqfCknLFxuICAgICAgb25DaGFuZ2U6IHRoaXMub25MaW5lYXJEaXN0RmlsdGVyQ2hhbmdlKCksXG4gICAgICB0eXBlOiBDT05GSUdVUkFUSU9OX0NPTVBPTkVOVF9UWVBFLlNMSURFUixcbiAgICAgIHZhbHVlczoge1xuICAgICAgICBjdXJyZW50OiB0aGlzLnN0YXRlLmxpbmVhckRpc3RGaWx0ZXIsXG4gICAgICAgIG1heDogMTAsXG4gICAgICAgIG1pbjogMSxcbiAgICAgIH0sXG4gICAgfSxcbiAgICB7XG4gICAgICBuYW1lOiAnVG9wIE4gUHJlZGljdGlvbnMgdG8gU2hvdycsXG4gICAgICBvbkNoYW5nZTogdGhpcy5vbk51bVByZWRpY3Rpb25zVG9TaG93Q2hhbmdlKCksXG4gICAgICB0eXBlOiBDT05GSUdVUkFUSU9OX0NPTVBPTkVOVF9UWVBFLlNMSURFUixcbiAgICAgIHZhbHVlczoge1xuICAgICAgICBjdXJyZW50OiB0aGlzLnN0YXRlLm51bVByZWRpY3Rpb25zVG9TaG93LFxuICAgICAgICBtYXg6IHRoaXMucHJvcHMuZGF0YS5jb3VwbGluZ1Njb3Jlcy5jaGFpbkxlbmd0aCxcbiAgICAgICAgbWluOiAxLFxuICAgICAgfSxcbiAgICB9LFxuICBdO1xuXG4gIC8qKlxuICAgKiBTZXR1cHMgdXAgdGhlIHByZWRpY3Rpb24gdmFsdWVzIGZvciB0aGUgZGF0YS5cbiAgICpcbiAgICogQHBhcmFtIGlzTmV3RGF0YSBJcyB0aGlzIGFuIGVudGlyZWx5IG5ldyBkYXRhc2V0P1xuICAgKi9cbiAgcHJvdGVjdGVkIHNldHVwRGF0YShpc05ld0RhdGE6IGJvb2xlYW4pIHtcbiAgICBjb25zdCB7IGNvcnJlY3RDb2xvciwgZGF0YSwgaW5jb3JyZWN0Q29sb3IgfSA9IHRoaXMucHJvcHM7XG4gICAgY29uc3QgeyBsaW5lYXJEaXN0RmlsdGVyLCBudW1QcmVkaWN0aW9uc1RvU2hvdyB9ID0gdGhpcy5zdGF0ZTtcbiAgICBjb25zdCBjb3VwbGluZ1Njb3JlcyA9IGRhdGEucGRiRGF0YVxuICAgICAgPyBkYXRhLnBkYkRhdGEuY29udGFjdEluZm9ybWF0aW9uXG4gICAgICA6IG5ldyBDb3VwbGluZ0NvbnRhaW5lcihkYXRhLmNvdXBsaW5nU2NvcmVzLnJhbmtlZENvbnRhY3RzKTtcblxuICAgIGNvbnN0IHsgY2hhaW5MZW5ndGggfSA9IGNvdXBsaW5nU2NvcmVzO1xuXG4gICAgY29uc3QgYWxsUHJlZGljdGlvbnMgPSBjb3VwbGluZ1Njb3Jlcy5nZXRQcmVkaWN0ZWRDb250YWN0cyhudW1QcmVkaWN0aW9uc1RvU2hvdywgbGluZWFyRGlzdEZpbHRlcik7XG5cbiAgICBjb25zdCBjb3JyZWN0UHJlZGljdGlvblBlcmNlbnQgPSAoKGFsbFByZWRpY3Rpb25zLmNvcnJlY3QubGVuZ3RoIC8gYWxsUHJlZGljdGlvbnMucHJlZGljdGVkLmxlbmd0aCkgKiAxMDApLnRvRml4ZWQoXG4gICAgICAxLFxuICAgICk7XG5cbiAgICBjb25zdCBuZXdQb2ludHM6IElDb250YWN0TWFwQ2hhcnREYXRhW10gPSBbXG4gICAgICBnZW5lcmF0ZUNoYXJ0RGF0YUVudHJ5KFxuICAgICAgICAndGV4dCcsXG4gICAgICAgIGluY29ycmVjdENvbG9yLFxuICAgICAgICAnUHJlZGljdGVkIENvbnRhY3QnLFxuICAgICAgICBgKE49JHtudW1QcmVkaWN0aW9uc1RvU2hvd30sIEw9JHtjaGFpbkxlbmd0aH0pYCxcbiAgICAgICAgNCxcbiAgICAgICAgYWxsUHJlZGljdGlvbnMucHJlZGljdGVkLFxuICAgICAgICB7XG4gICAgICAgICAgdGV4dDogYWxsUHJlZGljdGlvbnMucHJlZGljdGVkLm1hcChwb2ludCA9PiB7XG4gICAgICAgICAgICBjb25zdCBzY29yZSA9IGRhdGEuY291cGxpbmdTY29yZXMuZ2V0Q291cGxpbmdTY29yZShwb2ludC5pLCBwb2ludC5qKTtcblxuICAgICAgICAgICAgcmV0dXJuIHNjb3JlICYmIHNjb3JlLkFfaSAmJiBzY29yZS5BX2pcbiAgICAgICAgICAgICAgPyBgKCR7cG9pbnQuaX0ke3Njb3JlLkFfaX0sICR7cG9pbnQuan0ke3Njb3JlLkFfan0pYFxuICAgICAgICAgICAgICA6IGAoJHtwb2ludC5pfSwgJHtwb2ludC5qfSlgO1xuICAgICAgICAgIH0pLFxuICAgICAgICB9LFxuICAgICAgKSxcbiAgICAgIGdlbmVyYXRlQ2hhcnREYXRhRW50cnkoXG4gICAgICAgICd0ZXh0JyxcbiAgICAgICAgY29ycmVjdENvbG9yLFxuICAgICAgICAnQ29ycmVjdCBQcmVkaWN0aW9uJyxcbiAgICAgICAgYChOPSR7YWxsUHJlZGljdGlvbnMuY29ycmVjdC5sZW5ndGh9LCAke2NvcnJlY3RQcmVkaWN0aW9uUGVyY2VudH0lKWAsXG4gICAgICAgIDYsXG4gICAgICAgIGFsbFByZWRpY3Rpb25zLmNvcnJlY3QsXG4gICAgICAgIHtcbiAgICAgICAgICB0ZXh0OiBhbGxQcmVkaWN0aW9ucy5jb3JyZWN0Lm1hcChwb2ludCA9PiB7XG4gICAgICAgICAgICBjb25zdCBzY29yZSA9IGRhdGEuY291cGxpbmdTY29yZXMuZ2V0Q291cGxpbmdTY29yZShwb2ludC5pLCBwb2ludC5qKTtcblxuICAgICAgICAgICAgcmV0dXJuIHNjb3JlICYmIHNjb3JlLkFfaSAmJiBzY29yZS5BX2pcbiAgICAgICAgICAgICAgPyBgKCR7cG9pbnQuaX0ke3Njb3JlLkFfaX0sICR7cG9pbnQuan0ke3Njb3JlLkFfan0pYFxuICAgICAgICAgICAgICA6IGAoJHtwb2ludC5pfSwgJHtwb2ludC5qfSlgO1xuICAgICAgICAgIH0pLFxuICAgICAgICB9LFxuICAgICAgKSxcbiAgICBdO1xuXG4gICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICBudW1QcmVkaWN0aW9uc1RvU2hvdzogaXNOZXdEYXRhID8gTWF0aC5mbG9vcihjaGFpbkxlbmd0aCAvIDIpIDogbnVtUHJlZGljdGlvbnNUb1Nob3csXG4gICAgICBwb2ludHNUb1Bsb3Q6IG5ld1BvaW50cyxcbiAgICB9KTtcbiAgfVxufVxuIiwiaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xuXG4vLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6IGltcG9ydC1uYW1lXG5pbXBvcnQgSWZyYW1lQ29tbSBmcm9tICdyZWFjdC1pZnJhbWUtY29tbSc7XG5cbmltcG9ydCB7IGluaXRpYWxTcHJpbmdDb250ZXh0LCBJU3ByaW5nQ29udGV4dCwgU3ByaW5nQ29udGV4dCB9IGZyb20gJ35jaGVsbC12aXp+L2NvbnRleHQnO1xuaW1wb3J0IHsgVF9TTkVfREFUQV9UWVBFIH0gZnJvbSAnfmNoZWxsLXZpen4vZGF0YSc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgSVRGcmFtZUNvbXBvbmVudFByb3BzIHtcbiAgZGF0YTogVF9TTkVfREFUQV9UWVBFO1xuICBoZWlnaHQ6IG51bWJlciB8IHN0cmluZztcbiAgcGFkZGluZzogbnVtYmVyIHwgc3RyaW5nO1xuICBwb2ludENvbG9yOiBzdHJpbmc7XG4gIHNwcmluZ0NvbnRleHQ6IElTcHJpbmdDb250ZXh0O1xuICB3aWR0aDogbnVtYmVyIHwgc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIElURnJhbWVDb21wb25lbnRTdGF0ZSB7XG4gIHBvc3RNZXNzYWdlRGF0YTogb2JqZWN0O1xufVxuXG5leHBvcnQgY2xhc3MgVEZyYW1lQ29tcG9uZW50Q2xhc3MgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQ8SVRGcmFtZUNvbXBvbmVudFByb3BzLCBJVEZyYW1lQ29tcG9uZW50U3RhdGU+IHtcbiAgcHVibGljIHN0YXRpYyBkZWZhdWx0UHJvcHMgPSB7XG4gICAgZGF0YTogW1swXSwgWzBdXSxcbiAgICBoZWlnaHQ6IDQwMCxcbiAgICBwYWRkaW5nOiAwLFxuICAgIHBvaW50Q29sb3I6ICcjMDAwMDAwJyxcbiAgICBzcHJpbmdDb250ZXh0OiB7XG4gICAgICAuLi5pbml0aWFsU3ByaW5nQ29udGV4dCxcbiAgICB9LFxuICAgIHdpZHRoOiA0MDAsXG4gIH07XG5cbiAgcHJvdGVjdGVkIGlGcmFtZVJlZjogSWZyYW1lQ29tbSB8IG51bGwgPSBudWxsO1xuXG4gIGNvbnN0cnVjdG9yKHByb3BzOiBJVEZyYW1lQ29tcG9uZW50UHJvcHMpIHtcbiAgICBzdXBlcihwcm9wcyk7XG4gICAgY29uc3QgeyBzcHJpbmdDb250ZXh0LCBkYXRhLCBwYWRkaW5nLCBwb2ludENvbG9yIH0gPSBwcm9wcztcbiAgICB0aGlzLnN0YXRlID0ge1xuICAgICAgcG9zdE1lc3NhZ2VEYXRhOiB7XG4gICAgICAgIHBheWxvYWQ6IHtcbiAgICAgICAgICBkYXRhLFxuICAgICAgICAgIHBhZGRpbmcsXG4gICAgICAgICAgcG9pbnRDb2xvcixcbiAgICAgICAgICBzcHJpbmdDb250ZXh0LFxuICAgICAgICB9LFxuICAgICAgICB0eXBlOiAnbG9hZGVkJyxcbiAgICAgIH0sXG4gICAgfTtcbiAgfVxuXG4gIHB1YmxpYyBjb21wb25lbnREaWRVcGRhdGUocHJldlByb3BzOiBJVEZyYW1lQ29tcG9uZW50UHJvcHMpIHtcbiAgICBjb25zdCB7IGRhdGEsIHBhZGRpbmcsIHBvaW50Q29sb3IsIHNwcmluZ0NvbnRleHQgfSA9IHRoaXMucHJvcHM7XG5cbiAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgIHBvc3RNZXNzYWdlRGF0YToge1xuICAgICAgICBwYXlsb2FkOiB7XG4gICAgICAgICAgZGF0YSxcbiAgICAgICAgICBwYWRkaW5nLFxuICAgICAgICAgIHBvaW50Q29sb3IsXG4gICAgICAgICAgc3ByaW5nQ29udGV4dCxcbiAgICAgICAgfSxcbiAgICAgICAgdHlwZTogJ2xvYWRlZCcsXG4gICAgICB9LFxuICAgIH0pO1xuXG4gICAgaWYgKHNwcmluZ0NvbnRleHQgJiYgc3ByaW5nQ29udGV4dCAhPT0gcHJldlByb3BzLnNwcmluZ0NvbnRleHQpIHtcbiAgICAgIHRoaXMuZm9yY2VVcGRhdGUoKTtcbiAgICB9XG4gIH1cblxuICBwdWJsaWMgY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyhuZXh0UHJvcHM6IElURnJhbWVDb21wb25lbnRQcm9wcykge1xuICAgIGxldCBwYXlsb2FkID0ge307XG4gICAgT2JqZWN0LmVudHJpZXMobmV4dFByb3BzKS5mb3JFYWNoKHBhaXIgPT4ge1xuICAgICAgY29uc3Qga2V5ID0gcGFpclsnMCddO1xuICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgaWYgKG5leHRQcm9wc1trZXldICE9PSB0aGlzLnByb3BzW2tleV0pIHtcbiAgICAgICAgcGF5bG9hZCA9IHtcbiAgICAgICAgICAuLi5wYXlsb2FkLFxuICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICBba2V5XTogbmV4dFByb3BzW2tleV0sXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgIHBvc3RNZXNzYWdlRGF0YToge1xuICAgICAgICBwYXlsb2FkLFxuICAgICAgICB0eXBlOiAnbG9hZGVkJyxcbiAgICAgIH0sXG4gICAgfSk7XG4gIH1cblxuICBwdWJsaWMgc2hvdWxkQ29tcG9uZW50VXBkYXRlKG5leHRQcm9wczogSVRGcmFtZUNvbXBvbmVudFByb3BzKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIG5leHRQcm9wcy5zcHJpbmdDb250ZXh0LmN1cnJlbnRDZWxscyAmJlxuICAgICAgbmV4dFByb3BzLnNwcmluZ0NvbnRleHQuY3VycmVudENlbGxzICE9PSB0aGlzLnByb3BzLnNwcmluZ0NvbnRleHQuY3VycmVudENlbGxzXG4gICAgKTtcbiAgfVxuXG4gIHB1YmxpYyByZW5kZXIoKSB7XG4gICAgY29uc3QgeyBoZWlnaHQsIHdpZHRoIH0gPSB0aGlzLnByb3BzO1xuICAgIGNvbnN0IGF0dHJpYnV0ZXMgPSB7XG4gICAgICBoZWlnaHQsXG4gICAgICBzcmM6ICdodHRwOi8vbG9jYWxob3N0OjgwODAvVENvbnRhaW5lci5odG1sJyxcbiAgICAgIHdpZHRoLFxuICAgIH07XG5cbiAgICByZXR1cm4gPElmcmFtZUNvbW0gYXR0cmlidXRlcz17YXR0cmlidXRlc30gcG9zdE1lc3NhZ2VEYXRhPXt0aGlzLnN0YXRlLnBvc3RNZXNzYWdlRGF0YX0gLz47XG4gIH1cbn1cblxudHlwZSByZXF1aXJlZFByb3BzID0gT21pdDxJVEZyYW1lQ29tcG9uZW50UHJvcHMsIGtleW9mIHR5cGVvZiBURnJhbWVDb21wb25lbnRDbGFzcy5kZWZhdWx0UHJvcHM+ICZcbiAgUGFydGlhbDxJVEZyYW1lQ29tcG9uZW50UHJvcHM+O1xuXG5leHBvcnQgY29uc3QgVEZyYW1lQ29tcG9uZW50ID0gKHByb3BzOiByZXF1aXJlZFByb3BzKSA9PiAoXG4gIDxTcHJpbmdDb250ZXh0LkNvbnN1bWVyPlxuICAgIHtzcHJpbmdDb250ZXh0ID0+IDxURnJhbWVDb21wb25lbnRDbGFzcyB7Li4ucHJvcHN9IHNwcmluZ0NvbnRleHQ9e3NwcmluZ0NvbnRleHR9IC8+fVxuICA8L1NwcmluZ0NvbnRleHQuQ29uc3VtZXI+XG4pO1xuIiwiaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xuXG5pbXBvcnQgeyBkZWZhdWx0UGxvdGx5TGF5b3V0LCBQbG90bHlDaGFydCB9IGZyb20gJ35jaGVsbC12aXp+L2NvbXBvbmVudCc7XG5pbXBvcnQgeyBDaGVsbENoYXJ0RXZlbnQsIElQbG90bHlEYXRhIH0gZnJvbSAnfmNoZWxsLXZpen4vZGF0YSc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgSVRlbnNvckNvbXBvbmVudFByb3BzIHtcbiAgb25TZWxlY3RlZENhbGxiYWNrPzogKChldmVudDogQ2hlbGxDaGFydEV2ZW50KSA9PiB2b2lkKTtcbiAgcG9pbnRzVG9QbG90OiBBcnJheTxQYXJ0aWFsPElQbG90bHlEYXRhPj47XG59XG5cbmNsYXNzIFRlbnNvclRDb21wb25lbnRDbGFzcyBleHRlbmRzIFJlYWN0LkNvbXBvbmVudDxJVGVuc29yQ29tcG9uZW50UHJvcHM+IHtcbiAgcHVibGljIHN0YXRpYyBkZWZhdWx0UHJvcHMgPSB7XG4gICAgcG9pbnRzVG9QbG90OiBbXSxcbiAgICBzdHlsZToge1xuICAgICAgcGFkZGluZzogMCxcbiAgICB9LFxuICB9O1xuXG4gIHByb3RlY3RlZCBjYW52YXNDb250ZXh0OiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQgfCBudWxsID0gbnVsbDtcblxuICBjb25zdHJ1Y3Rvcihwcm9wczogSVRlbnNvckNvbXBvbmVudFByb3BzKSB7XG4gICAgc3VwZXIocHJvcHMpO1xuICB9XG5cbiAgcHVibGljIHJlbmRlcigpIHtcbiAgICBjb25zdCB7IHBvaW50c1RvUGxvdCB9ID0gdGhpcy5wcm9wcztcblxuICAgIHJldHVybiAoXG4gICAgICA8UGxvdGx5Q2hhcnRcbiAgICAgICAgZGF0YT17cG9pbnRzVG9QbG90fVxuICAgICAgICBsYXlvdXQ9e3tcbiAgICAgICAgICAuLi5kZWZhdWx0UGxvdGx5TGF5b3V0LFxuICAgICAgICAgIGRyYWdtb2RlOiAnc2VsZWN0JyxcbiAgICAgICAgICBtYXJnaW46IHtcbiAgICAgICAgICAgIGI6IDIwLFxuICAgICAgICAgIH0sXG4gICAgICAgICAgeGF4aXM6IHsgYXV0b3JhbmdlOiBmYWxzZSwgcmFuZ2U6IFswLCAxXSwgc2hvd2xpbmU6IHRydWUgfSxcbiAgICAgICAgICB5YXhpczogeyBhdXRvcmFuZ2U6IGZhbHNlLCByYW5nZTogWzAsIDFdLCBzaG93bGluZTogdHJ1ZSB9LFxuICAgICAgICB9fVxuICAgICAgICBvblNlbGVjdGVkQ2FsbGJhY2s9e3RoaXMucHJvcHMub25TZWxlY3RlZENhbGxiYWNrfVxuICAgICAgLz5cbiAgICApO1xuICB9XG59XG5cbnR5cGUgcmVxdWlyZWRQcm9wcyA9IE9taXQ8SVRlbnNvckNvbXBvbmVudFByb3BzLCBrZXlvZiB0eXBlb2YgVGVuc29yVENvbXBvbmVudENsYXNzLmRlZmF1bHRQcm9wcz4gJlxuICBQYXJ0aWFsPElUZW5zb3JDb21wb25lbnRQcm9wcz47XG5cbmV4cG9ydCBjb25zdCBUZW5zb3JUQ29tcG9uZW50ID0gKHByb3BzOiByZXF1aXJlZFByb3BzKSA9PiA8VGVuc29yVENvbXBvbmVudENsYXNzIHsuLi5wcm9wc30gLz47XG4iLCJpbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBDYXJkLCBEcm9wZG93biwgRHJvcGRvd25JdGVtUHJvcHMsIERyb3Bkb3duUHJvcHMgfSBmcm9tICdzZW1hbnRpYy11aS1yZWFjdCc7XG5cbmltcG9ydCB7IEluZm9QYW5lbCwgTkdMQ29tcG9uZW50LCBQcmVkaWN0ZWRDb250YWN0TWFwLCBURnJhbWVDb21wb25lbnQgfSBmcm9tICd+Y2hlbGwtdml6fi9jb21wb25lbnQnO1xuaW1wb3J0IHsgU3ByaW5nQ29udGFpbmVyLCBUZW5zb3JUQ29udGFpbmVyIH0gZnJvbSAnfmNoZWxsLXZpen4vY29udGFpbmVyJztcbmltcG9ydCB7IENIRUxMX0RBVEFfVFlQRSwgSUNvbnRhY3RNYXBEYXRhLCBOR0xfREFUQV9UWVBFLCBUX1NORV9EQVRBX1RZUEUsIFZJWl9UWVBFIH0gZnJvbSAnfmNoZWxsLXZpen4vZGF0YSc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgSVZpelBhbmVsUHJvcHMge1xuICBkYXRhOiBQYXJ0aWFsPHsgW0sgaW4gVklaX1RZUEVdOiBDSEVMTF9EQVRBX1RZUEUgfT47XG4gIGhlaWdodDogbnVtYmVyO1xuICBpbml0aWFsVml6OiBWSVpfVFlQRTtcbiAgcGFkZGluZzogbnVtYmVyO1xuICBzdXBwb3J0ZWRWaXN1YWxpemF0aW9uczogVklaX1RZUEVbXTtcbiAgd2lkdGg6IG51bWJlcjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBJVml6UGFuZWxTdGF0ZSB7XG4gIHNlbGVjdGVkVml6OiBWSVpfVFlQRTtcbn1cblxuLyoqXG4gKiBBIHNpbmdsZSB2aXN1YWxpemF0aW9uIHBhbmVsIGFsbG93aW5nIGEgdXNlciB0byBzZWxlY3QgaG93IHRoZXkgd2lzaCB0byB2aWV3IGRhdGEuXG4gKlxuICogQGV4cG9ydFxuICogQGV4dGVuZHMge1JlYWN0LkNvbXBvbmVudDxWaXpQYW5lbFByb3BzLCBWaXpQYW5lbFN0YXRlPn1cbiAqL1xuZXhwb3J0IGNsYXNzIFZpelNlbGVjdG9yUGFuZWwgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQ8SVZpelBhbmVsUHJvcHMsIElWaXpQYW5lbFN0YXRlPiB7XG4gIHB1YmxpYyBzdGF0aWMgZGVmYXVsdFByb3BzID0ge1xuICAgIGRhdGE6IG5ldyBPYmplY3QoKSxcbiAgICBoZWlnaHQ6IDQ1MCxcbiAgICBpbml0aWFsVml6OiBWSVpfVFlQRVsnVC1TTkUnXSxcbiAgICBwYWRkaW5nOiAxNSxcbiAgICBzdXBwb3J0ZWRWaXN1YWxpemF0aW9uczogW10sXG4gICAgd2lkdGg6IDQ1MCxcbiAgfTtcblxuICBjb25zdHJ1Y3Rvcihwcm9wczogSVZpelBhbmVsUHJvcHMpIHtcbiAgICBzdXBlcihwcm9wcyk7XG4gICAgdGhpcy5zdGF0ZSA9IHtcbiAgICAgIHNlbGVjdGVkVml6OiBwcm9wcy5pbml0aWFsVml6LFxuICAgIH07XG4gIH1cblxuICBwdWJsaWMgcmVuZGVyKCkge1xuICAgIC8vIE4uQi4gV2UgYXJlIG9ubHkgc2V0dGluZyB0aGUgd2lkdGggb2YgdGhlIFZpelNlbGVjdG9yUGFuZWwsIGV4cGxpY2l0bHkgbGVhdmluZyBvdXQgdGhlIGhlaWdodC5cbiAgICAvLyBUaGlzIG1lYW5zIGEgY29tcG9uZW50IGNhbiBvbmx5IGdyb3cgdmVydGljYWxseSwgYnV0IG5vdCBob3Jpem9udGFsbHksIGFuZCBiZSBjb3JyZWN0bHkgc3R5bGVkIGluIGNvbnRhaW5lcnMuXG4gICAgY29uc3QgeyBkYXRhLCBzdXBwb3J0ZWRWaXN1YWxpemF0aW9ucywgd2lkdGggfSA9IHRoaXMucHJvcHM7XG5cbiAgICByZXR1cm4gKFxuICAgICAgPGRpdiBjbGFzc05hbWU9XCJWaXpTZWxlY3RvclBhbmVsXCIgc3R5bGU9e3sgd2lkdGggfX0+XG4gICAgICAgIDxEcm9wZG93blxuICAgICAgICAgIG9wdGlvbnM9e3RoaXMuZ2VuZXJhdGVEcm9wZG93bkl0ZW1zKHN1cHBvcnRlZFZpc3VhbGl6YXRpb25zKX1cbiAgICAgICAgICBmbHVpZD17dHJ1ZX1cbiAgICAgICAgICBvbkNoYW5nZT17dGhpcy5vblZpelNlbGVjdH1cbiAgICAgICAgICBkZWZhdWx0VmFsdWU9e3RoaXMucHJvcHMuaW5pdGlhbFZpen1cbiAgICAgICAgLz5cbiAgICAgICAge1xuICAgICAgICAgIDxDYXJkIGZsdWlkPXt0cnVlfSByYWlzZWQ9e3RydWV9PlxuICAgICAgICAgICAge3RoaXMucmVuZGVyVml6Q29udGFpbmVyKHRoaXMuc3RhdGUuc2VsZWN0ZWRWaXosIGRhdGEpfVxuICAgICAgICAgIDwvQ2FyZD5cbiAgICAgICAgfVxuICAgICAgPC9kaXY+XG4gICAgKTtcbiAgfVxuXG4gIHByb3RlY3RlZCByZW5kZXJWaXpDb250YWluZXIodml6OiBWSVpfVFlQRSwgZGF0YTogUGFydGlhbDx7IFtLIGluIFZJWl9UWVBFXTogQ0hFTExfREFUQV9UWVBFIH0+KSB7XG4gICAgY29uc3QgeyBwYWRkaW5nIH0gPSB0aGlzLnByb3BzO1xuICAgIGNvbnN0IHBhZGRlZEhlaWdodCA9IHRoaXMucHJvcHMuaGVpZ2h0IC0gcGFkZGluZyAqIDI7XG4gICAgY29uc3QgcGFkZGVkV2lkdGggPSB0aGlzLnByb3BzLndpZHRoIC0gcGFkZGluZyAqIDI7XG4gICAgc3dpdGNoICh2aXopIHtcbiAgICAgIGNhc2UgVklaX1RZUEVbJ1QtU05FJ106XG4gICAgICBjYXNlIFZJWl9UWVBFWydURU5TT1ItVC1TTkUnXTpcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICBkYXRhWydURU5TT1ItVC1TTkUnXSAmJiAoXG4gICAgICAgICAgICA8VGVuc29yVENvbnRhaW5lclxuICAgICAgICAgICAgICBzdHlsZT17e1xuICAgICAgICAgICAgICAgIHBhZGRpbmcsXG4gICAgICAgICAgICAgIH19XG4gICAgICAgICAgICAvPlxuICAgICAgICAgIClcbiAgICAgICAgKTtcbiAgICAgIGNhc2UgVklaX1RZUEVbJ1QtU05FLUZSQU1FJ106XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgZGF0YVsnVC1TTkUnXSAmJiAoXG4gICAgICAgICAgICA8VEZyYW1lQ29tcG9uZW50XG4gICAgICAgICAgICAgIGRhdGE9e2RhdGFbJ1QtU05FJ10gYXMgVF9TTkVfREFUQV9UWVBFfVxuICAgICAgICAgICAgICBoZWlnaHQ9e3BhZGRlZEhlaWdodH1cbiAgICAgICAgICAgICAgcGFkZGluZz17cGFkZGluZ31cbiAgICAgICAgICAgICAgd2lkdGg9e3BhZGRlZFdpZHRofVxuICAgICAgICAgICAgLz5cbiAgICAgICAgICApXG4gICAgICAgICk7XG4gICAgICBjYXNlIFZJWl9UWVBFLlNQUklORzpcbiAgICAgICAgcmV0dXJuIDxTcHJpbmdDb250YWluZXIgcGFkZGluZz17cGFkZGluZ30gLz47XG4gICAgICBjYXNlIFZJWl9UWVBFLk5HTDpcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICBkYXRhLk5HTCAmJiAoXG4gICAgICAgICAgICA8TkdMQ29tcG9uZW50XG4gICAgICAgICAgICAgIGRhdGE9e2RhdGEuTkdMIGFzIE5HTF9EQVRBX1RZUEV9XG4gICAgICAgICAgICAgIGhlaWdodD17cGFkZGVkSGVpZ2h0fVxuICAgICAgICAgICAgICBzdHlsZT17eyBwYWRkaW5nIH19XG4gICAgICAgICAgICAgIHdpZHRoPXtwYWRkZWRXaWR0aH1cbiAgICAgICAgICAgIC8+XG4gICAgICAgICAgKVxuICAgICAgICApO1xuICAgICAgY2FzZSBWSVpfVFlQRS5DT05UQUNUX01BUDpcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICBkYXRhWydDb250YWN0IE1hcCddICYmIChcbiAgICAgICAgICAgIDxQcmVkaWN0ZWRDb250YWN0TWFwXG4gICAgICAgICAgICAgIGRhdGE9e2RhdGFbJ0NvbnRhY3QgTWFwJ10gYXMgSUNvbnRhY3RNYXBEYXRhfVxuICAgICAgICAgICAgICBoZWlnaHQ9e3BhZGRlZEhlaWdodH1cbiAgICAgICAgICAgICAgc3R5bGU9e3sgcGFkZGluZyB9fVxuICAgICAgICAgICAgICB3aWR0aD17cGFkZGVkV2lkdGh9XG4gICAgICAgICAgICAvPlxuICAgICAgICAgIClcbiAgICAgICAgKTtcbiAgICAgIGNhc2UgVklaX1RZUEUuSU5GT19QQU5FTDpcbiAgICAgICAgcmV0dXJuIDxJbmZvUGFuZWwgZGF0YT17ZGF0YVsnQ29udGFjdCBNYXAnXSBhcyBQYXJ0aWFsPElDb250YWN0TWFwRGF0YT59IGhlaWdodD17NDAwfSB3aWR0aD17NDAwfSAvPjtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5rbm93biB2aXo6ICR7dml6fWApO1xuICAgIH1cbiAgfVxuXG4gIHByb3RlY3RlZCBvblZpelNlbGVjdCA9IChldmVudDogUmVhY3QuU3ludGhldGljRXZlbnQ8SFRNTEVsZW1lbnQ+LCBkYXRhOiBEcm9wZG93blByb3BzKSA9PiB7XG4gICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICBzZWxlY3RlZFZpejogZGF0YS52YWx1ZSBhcyBWSVpfVFlQRSxcbiAgICB9KTtcbiAgfTtcblxuICBwcm90ZWN0ZWQgZ2VuZXJhdGVEcm9wZG93bkl0ZW1zID0gKHN1cHBvcnRlZFZpc3VhbGl6YXRpb25zOiBWSVpfVFlQRVtdKTogRHJvcGRvd25JdGVtUHJvcHNbXSA9PiB7XG4gICAgcmV0dXJuIHN1cHBvcnRlZFZpc3VhbGl6YXRpb25zXG4gICAgICAubWFwKHZpeiA9PiAoe1xuICAgICAgICBrZXk6IHZpeixcbiAgICAgICAgdGV4dDogdml6LFxuICAgICAgICB2YWx1ZTogdml6LFxuICAgICAgfSkpXG4gICAgICAuc29ydCgoYSwgYikgPT4gYS5rZXkubG9jYWxlQ29tcGFyZShiLmtleSkpO1xuICB9O1xufVxuIiwiaW1wb3J0IHsgRGF0dW0gfSBmcm9tICdwbG90bHkuanMtZ2wyZC1kaXN0JztcblxuaW1wb3J0IHsgQ2hlbGwxRFNlY3Rpb24sIENIRUxMX1BMT1RMWV9EQVRBLCBSRVFVSVJFRF9DSEVMTF9QTE9UTFlfREFUQSB9IGZyb20gJ35jaGVsbC12aXp+L2RhdGEnO1xuXG4vKipcbiAqIFNob3J0aGFuZCB0byByZWZlciB0byBzb21ldGhpbmcgd2l0aCBib3RoIGFuIHggYW5kIHkgYXhpcy5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBJQXhpc01hcHBpbmcge1xuICAvKiogVGhlIHggYXhpcy4gKi9cbiAgeDogQ0hFTExfUExPVExZX0RBVEE7XG4gIC8qKiBUaGUgeSBheGlzLiAqL1xuICB5OiBDSEVMTF9QTE9UTFlfREFUQTtcbn1cblxuLyoqXG4gKiBDbGFzcyB0byByZXByZXNlbnQgYW4gZXh0cmEgeCBhbmQvb3IgeSBheGlzIGZvciBhIFBsb3RseSBjaGFydC5cbiAqL1xuZXhwb3J0IGNsYXNzIEF1eGlsaWFyeUF4aXM8VCBleHRlbmRzIHN0cmluZz4ge1xuICBwcm90ZWN0ZWQgYXhlczogTWFwPFQsIElBeGlzTWFwcGluZz4gPSBuZXcgTWFwKCk7XG4gIHByb3RlY3RlZCBoaWdobGlnaHRlZEF4ZXM6IE1hcDxULCBJQXhpc01hcHBpbmc+ID0gbmV3IE1hcCgpO1xuXG4gIC8qKlxuICAgKiBHZXQgYWxsIHRoZSBheGlzIG9iamVjdHMgYmVsb25naW5nIHRvIHRoaXMgQXV4aWxpYXJ5IEF4aXMuXG4gICAqL1xuICBwdWJsaWMgZ2V0IGF4aXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuYXhlcztcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgYWxsIHRoZSB4LWF4aXMgb2JqZWN0cyBiZWxvbmdpbmcgdG8gdGhpcyBBdXhpbGlhcnkgQXhpcy5cbiAgICovXG4gIHB1YmxpYyBnZXQgeEF4ZXMoKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gbmV3IEFycmF5PFBhcnRpYWw8Q0hFTExfUExPVExZX0RBVEE+PigpO1xuICAgIHRoaXMuYXhlcy5mb3JFYWNoKHZhbHVlID0+IHtcbiAgICAgIHJlc3VsdC5wdXNoKHZhbHVlLngpO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgYWxsIHRoZSBoaWdobGlnaHRlZCB4LWF4aXMgb2JqZWN0cyBiZWxvbmdpbmcgdG8gdGhpcyBBdXhpbGlhcnkgQXhpcy5cbiAgICovXG4gIHB1YmxpYyBnZXQgaGlnaGxpZ2h0ZWRYQXhlcygpIHtcbiAgICBjb25zdCByZXN1bHQgPSBuZXcgQXJyYXk8UGFydGlhbDxDSEVMTF9QTE9UTFlfREFUQT4+KCk7XG4gICAgdGhpcy5oaWdobGlnaHRlZEF4ZXMuZm9yRWFjaCh2YWx1ZSA9PiB7XG4gICAgICByZXN1bHQucHVzaCh2YWx1ZS54KTtcbiAgICB9KTtcblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogR2V0IGFsbCB0aGUgeS1heGlzIG9iamVjdHMgYmVsb25naW5nIHRvIHRoaXMgQXV4aWxpYXJ5IEF4aXMuXG4gICAqL1xuICBwdWJsaWMgZ2V0IHlBeGVzKCkge1xuICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBBcnJheTxQYXJ0aWFsPENIRUxMX1BMT1RMWV9EQVRBPj4oKTtcbiAgICB0aGlzLmF4ZXMuZm9yRWFjaCh2YWx1ZSA9PiB7XG4gICAgICByZXN1bHQucHVzaCh2YWx1ZS55KTtcbiAgICB9KTtcblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogR2V0IGFsbCB0aGUgaGlnaGxpZ2h0ZWQgeS1heGlzIG9iamVjdHMgYmVsb25naW5nIHRvIHRoaXMgQXV4aWxpYXJ5IEF4aXMuXG4gICAqL1xuICBwdWJsaWMgZ2V0IGhpZ2hsaWdodGVkWUF4ZXMoKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gbmV3IEFycmF5PFBhcnRpYWw8Q0hFTExfUExPVExZX0RBVEE+PigpO1xuICAgIHRoaXMuaGlnaGxpZ2h0ZWRBeGVzLmZvckVhY2godmFsdWUgPT4ge1xuICAgICAgcmVzdWx0LnB1c2godmFsdWUueSk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgQXV4aWxpYXJ5QXhpcy5cbiAgICogQHBhcmFtIHNlY3Rpb25zIFRoZSB1bmRlcmx5aW5nIGRhdGEgdG8gYmUgcmVwcmVzZW50ZWQgYnkgdGhlc2UgYXhlcy5cbiAgICogQHBhcmFtIFtheGlzSW5kZXg9Ml0gVGhlIGluZGV4IG9mIHRoaXMgYXhpcywgaWYgdGhlcmUgYXJlIG11bHRpcGxlIGF1eGlsaWFyeSBheGVzLlxuICAgKiBAcGFyYW0gW2RlZmF1bHRDb2xvcj0nYmxhY2snXSBXaGF0IGNvbG9yIHNob3VsZCB0aGUgYXhpcyBiZSBieSBkZWZhdWx0P1xuICAgKiBAcGFyYW0gW2NvbG9yTWFwXSBBbGxvd3Mgc3BlY2lmaWMgZGF0YSBwaWVjZXMgdG8gYmUgY29sb3JlZC5cbiAgICogQHBhcmFtIFtkYXRhVHJhbnNmb3JtRm5dIERldGVybWluZSBob3cgYSBzZWN0aW9uIGlzIHRvIGJlIHRyYW5zZm9ybWVkIHRvIHRoZSBtYWluIGFuZCBvcHBvc2l0ZSBheGlzLlxuICAgKiAgRm9yIGV4YW1wbGUsIGZvciBhIHNpbmUgd2F2ZSwgdGhlIG1haW4gYXhpcyBpbmNyZW1lbnRzIGJ5IDEgYnV0IHRoZSBvcHBvc2l0ZSBuZWVkcyB0byBiZSBpbmNyZWFzZWQgYnkgYSBNYXRoLnNpbigpIGNhbGwuXG4gICAqIEBwYXJhbSBbZmlsdGVyRm49KCkgPT4gZmFsc2VdIEZ1bmN0aW9uIHRvIGFsbG93IGNlcnRhaW4gZWxlbWVudHMgdG8gYmUgZmlsdGVyZWQgb3V0IGFuZCB0aHVzIG5vdCBzaG93IHVwIG9uIHRoZSBheGlzLlxuICAgKi9cbiAgY29uc3RydWN0b3IoXG4gICAgcmVhZG9ubHkgc2VjdGlvbnM6IEFycmF5PENoZWxsMURTZWN0aW9uPFQ+PixcbiAgICByZWFkb25seSBheGlzSW5kZXg6IG51bWJlciA9IDIsXG4gICAgcmVhZG9ubHkgZGVmYXVsdENvbG9yID0gJ2JsYWNrJyxcbiAgICByZWFkb25seSBjb2xvck1hcD86IHsgW2tleTogc3RyaW5nXTogc3RyaW5nIH0sXG4gICAgcmVhZG9ubHkgZGF0YVRyYW5zZm9ybUZuPzoge1xuICAgICAgW2tleTogc3RyaW5nXTogKHNlY3Rpb246IENoZWxsMURTZWN0aW9uPFQ+LCBpbmRleDogbnVtYmVyKSA9PiB7IG1haW46IG51bWJlcjsgb3Bwb3NpdGU6IG51bWJlciB9O1xuICAgIH0sXG4gICAgcmVhZG9ubHkgZmlsdGVyRm46IChzZWN0aW9uOiBDaGVsbDFEU2VjdGlvbjxUPikgPT4gYm9vbGVhbiA9ICgpID0+IGZhbHNlLFxuICApIHtcbiAgICB0aGlzLnNldHVwQXV4aWxpYXJ5QXhpcygpO1xuICB9XG5cbiAgcHVibGljIGdldEF4aXNCeUlkKGlkOiBUKSB7XG4gICAgcmV0dXJuIHRoaXMuYXhlcy5nZXQoaWQpO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSB0aGUgQXV4aWxpYXJ5IEF4aXMuXG4gICAqL1xuICBwcm90ZWN0ZWQgc2V0dXBBdXhpbGlhcnlBeGlzKCkge1xuICAgIGZvciAoY29uc3Qgc2VjdGlvbiBvZiB0aGlzLnNlY3Rpb25zKSB7XG4gICAgICBpZiAodGhpcy5maWx0ZXJGbihzZWN0aW9uKSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgeyBsYWJlbCB9ID0gc2VjdGlvbjtcbiAgICAgIGlmICghdGhpcy5heGVzLmhhcyhsYWJlbCkpIHtcbiAgICAgICAgdGhpcy5heGVzLnNldChsYWJlbCwge1xuICAgICAgICAgIHg6IHRoaXMuZ2VuZXJhdGVYQXhpc1NlZ21lbnQobGFiZWwpLFxuICAgICAgICAgIHk6IHRoaXMuZ2VuZXJhdGVZQXhpc1NlZ21lbnQobGFiZWwpLFxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgaWYgKCF0aGlzLmhpZ2hsaWdodGVkQXhlcy5oYXMobGFiZWwpKSB7XG4gICAgICAgIHRoaXMuaGlnaGxpZ2h0ZWRBeGVzLnNldChsYWJlbCwge1xuICAgICAgICAgIHg6IHRoaXMuZ2VuZXJhdGVIaWdobGlnaHRlZFhBeGlzU2VnbWVudChsYWJlbCksXG4gICAgICAgICAgeTogdGhpcy5nZW5lcmF0ZUhpZ2hsaWdodGVkWUF4aXNTZWdtZW50KGxhYmVsKSxcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGxhYmVsQXhpcyA9IHRoaXMuYXhlcy5nZXQobGFiZWwpO1xuICAgICAgY29uc3QgaGlnaGxpZ2h0QXhpcyA9IHRoaXMuaGlnaGxpZ2h0ZWRBeGVzLmdldChsYWJlbCk7XG4gICAgICBpZiAobGFiZWxBeGlzICYmIGhpZ2hsaWdodEF4aXMpIHtcbiAgICAgICAgY29uc3QgcG9pbnRzID0gdGhpcy5kZXJpdmVQb2ludHNJbkF4aXMoc2VjdGlvbik7XG4gICAgICAgIChsYWJlbEF4aXMueC54IGFzIERhdHVtW10pLnB1c2goLi4ucG9pbnRzLm1haW4pO1xuICAgICAgICAobGFiZWxBeGlzLngueSBhcyBEYXR1bVtdKS5wdXNoKC4uLnBvaW50cy5vcHBvc2l0ZSk7XG4gICAgICAgIChsYWJlbEF4aXMueS55IGFzIERhdHVtW10pLnB1c2goLi4ucG9pbnRzLm1haW4pO1xuICAgICAgICAobGFiZWxBeGlzLnkueCBhcyBEYXR1bVtdKS5wdXNoKC4uLnBvaW50cy5vcHBvc2l0ZSk7XG5cbiAgICAgICAgY29uc3QgaGlnaGxpZ2h0ZWRQb2ludHMgPSB0aGlzLmRlcml2ZUhpZ2hsaWdodGVkUG9pbnRzSW5BeGlzKHNlY3Rpb24pO1xuICAgICAgICAoaGlnaGxpZ2h0QXhpcy54LnggYXMgRGF0dW1bXSkucHVzaCguLi5oaWdobGlnaHRlZFBvaW50cy5tYWluKTtcbiAgICAgICAgKGhpZ2hsaWdodEF4aXMueC55IGFzIERhdHVtW10pLnB1c2goLi4uaGlnaGxpZ2h0ZWRQb2ludHMub3Bwb3NpdGUpO1xuICAgICAgICAoaGlnaGxpZ2h0QXhpcy55LnkgYXMgRGF0dW1bXSkucHVzaCguLi5oaWdobGlnaHRlZFBvaW50cy5tYWluKTtcbiAgICAgICAgKGhpZ2hsaWdodEF4aXMueS54IGFzIERhdHVtW10pLnB1c2goLi4uaGlnaGxpZ2h0ZWRQb2ludHMub3Bwb3NpdGUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBQbG90bHkgZGF0YSBzcGVjaWZpYyBmb3IgdGhlIHggYXhpcy5cbiAgICpcbiAgICogQHBhcmFtIGtleSBUaGUgbGFiZWwgZm9yIHRoaXMgcGllY2Ugb2YgZGF0YS5cbiAgICovXG4gIHByb3RlY3RlZCBnZW5lcmF0ZVhBeGlzU2VnbWVudCA9IChrZXk6IFQpOiBDSEVMTF9QTE9UTFlfREFUQSA9PiAoe1xuICAgIC4uLnRoaXMuYXV4aWxpYXJ5QXhpc0RlZmF1bHRzKGtleSksXG4gICAgb3JpZW50YXRpb246ICdoJyxcbiAgICB4YXhpczogJ3gnLFxuICAgIHlheGlzOiBgeSR7dGhpcy5heGlzSW5kZXh9YCxcbiAgfSk7XG5cbiAgLyoqXG4gICAqIFBsb3RseSBkYXRhIHNwZWNpZmljIGZvciB0aGUgaGlnaGxpZ2h0ZWQgeCBheGlzLlxuICAgKlxuICAgKiBAcGFyYW0ga2V5IFRoZSBsYWJlbCBmb3IgdGhpcyBwaWVjZSBvZiBkYXRhLlxuICAgKi9cbiAgcHJvdGVjdGVkIGdlbmVyYXRlSGlnaGxpZ2h0ZWRYQXhpc1NlZ21lbnQgPSAoa2V5OiBUKTogQ0hFTExfUExPVExZX0RBVEEgPT4gKHtcbiAgICAuLi50aGlzLmhpZ2hsaWdodGVkQXV4aWxpYXJ5QXhpc0RlZmF1bHRzKGtleSksXG4gICAgb3JpZW50YXRpb246ICdoJyxcbiAgICB4YXhpczogJ3gnLFxuICAgIHlheGlzOiBgeSR7dGhpcy5heGlzSW5kZXh9YCxcbiAgfSk7XG5cbiAgLyoqXG4gICAqIFBsb3RseSBkYXRhIHNwZWNpZmljIGZvciB0aGUgeSBheGlzLlxuICAgKlxuICAgKiBAcGFyYW0ga2V5IFRoZSBsYWJlbCBmb3IgdGhpcyBwaWVjZSBvZiBkYXRhLlxuICAgKi9cbiAgcHJvdGVjdGVkIGdlbmVyYXRlWUF4aXNTZWdtZW50ID0gKGtleTogVCk6IENIRUxMX1BMT1RMWV9EQVRBID0+ICh7XG4gICAgLi4udGhpcy5hdXhpbGlhcnlBeGlzRGVmYXVsdHMoa2V5KSxcbiAgICBvcmllbnRhdGlvbjogJ3YnLFxuICAgIHhheGlzOiBgeCR7dGhpcy5heGlzSW5kZXh9YCxcbiAgICB5YXhpczogJ3knLFxuICB9KTtcblxuICAvKipcbiAgICogUGxvdGx5IGRhdGEgc3BlY2lmaWMgZm9yIHRoZSBoaWdobGlnaHRlZCB5IGF4aXMuXG4gICAqXG4gICAqIEBwYXJhbSBrZXkgVGhlIGxhYmVsIGZvciB0aGlzIHBpZWNlIG9mIGRhdGEuXG4gICAqL1xuICBwcm90ZWN0ZWQgZ2VuZXJhdGVIaWdobGlnaHRlZFlBeGlzU2VnbWVudCA9IChrZXk6IFQpOiBDSEVMTF9QTE9UTFlfREFUQSA9PiAoe1xuICAgIC4uLnRoaXMuaGlnaGxpZ2h0ZWRBdXhpbGlhcnlBeGlzRGVmYXVsdHMoa2V5KSxcbiAgICBvcmllbnRhdGlvbjogJ3YnLFxuICAgIHhheGlzOiBgeCR7dGhpcy5heGlzSW5kZXh9YCxcbiAgICB5YXhpczogJ3knLFxuICB9KTtcblxuICAvKipcbiAgICogRGVmYXVsdCBwbG90bHkgZGF0YSBmb3IgYW4gYXhpcy5cbiAgICpcbiAgICogQHBhcmFtIGtleSBUaGUgbGFiZWwgZm9yIHRoaXMgcGllY2Ugb2YgZGF0YS5cbiAgICovXG4gIHByb3RlY3RlZCBhdXhpbGlhcnlBeGlzRGVmYXVsdHMgPSAoa2V5OiBUKTogUkVRVUlSRURfQ0hFTExfUExPVExZX0RBVEEgPT4gKHtcbiAgICBjb25uZWN0Z2FwczogZmFsc2UsXG4gICAgaG92ZXJpbmZvOiAnbm9uZScsXG4gICAgbGluZToge1xuICAgICAgY29sb3I6IHRoaXMuY29sb3JNYXAgJiYgdGhpcy5jb2xvck1hcFtrZXldID8gdGhpcy5jb2xvck1hcFtrZXldIDogdGhpcy5kZWZhdWx0Q29sb3IsXG4gICAgICBzaGFwZTogJ3NwbGluZScsXG4gICAgICBzbW9vdGhpbmc6IDEuMyxcbiAgICAgIHdpZHRoOiAxLjUsXG4gICAgfSxcbiAgICBtYXJrZXI6IHtcbiAgICAgIHN5bWJvbDogW10sXG4gICAgfSxcbiAgICBtb2RlOiAnbGluZXMnLFxuICAgIG5hbWU6IGtleSxcbiAgICBzaG93bGVnZW5kOiBmYWxzZSxcbiAgICB0eXBlOiAnc2NhdHRlcicsXG4gICAgeDogW10sXG4gICAgeTogW10sXG4gIH0pO1xuXG4gIC8qKlxuICAgKiBEZWZhdWx0IHBsb3RseSBkYXRhIGZvciBhIGhpZ2hsaWdodGVkIGF4aXMuXG4gICAqXG4gICAqIEBwYXJhbSBrZXkgVGhlIGxhYmVsIGZvciB0aGlzIHBpZWNlIG9mIGRhdGEuXG4gICAqL1xuICBwcm90ZWN0ZWQgaGlnaGxpZ2h0ZWRBdXhpbGlhcnlBeGlzRGVmYXVsdHMgPSAoa2V5OiBUKTogQ0hFTExfUExPVExZX0RBVEEgPT4gKHtcbiAgICAuLi50aGlzLmF1eGlsaWFyeUF4aXNEZWZhdWx0cyhrZXkpLFxuICAgIGZpbGw6ICd0b3NlbGYnLFxuICAgIGxpbmU6IHtcbiAgICAgIGNvbG9yOiB0aGlzLmNvbG9yTWFwICYmIHRoaXMuY29sb3JNYXBba2V5XSA/IHRoaXMuY29sb3JNYXBba2V5XSA6IHRoaXMuZGVmYXVsdENvbG9yLFxuICAgICAgd2lkdGg6IDAsXG4gICAgfSxcbiAgfSk7XG5cbiAgLyoqXG4gICAqIERldGVybWluZXMgdGhlIHBvaW50cyB0aGF0IG1ha2UgdXAgdGhlIGF4aXMgZm9yIGJvdGggdGhlIG1haW4gYW5kIG9wcG9zaXRlIGF4aXMgc2lkZS5cbiAgICogQHBhcmFtIHNlY3Rpb24gVGhlIHNlY3Rpb24gb2YgZGF0YSB0byBkZXJpdmUgcG9pbnRzIGZvci5cbiAgICovXG4gIHByb3RlY3RlZCBkZXJpdmVQb2ludHNJbkF4aXMgPSAoc2VjdGlvbjogQ2hlbGwxRFNlY3Rpb248VD4pID0+IHtcbiAgICBjb25zdCByZXN1bHQgPSB7XG4gICAgICBtYWluOiBbc2VjdGlvbi5zdGFydF0sXG4gICAgICBvcHBvc2l0ZTogW251bGxdIGFzIEFycmF5PG51bWJlciB8IG51bGw+LFxuICAgIH07XG5cbiAgICBmb3IgKGxldCBpID0gc2VjdGlvbi5zdGFydDsgaSA8PSBzZWN0aW9uLmVuZDsgKytpKSB7XG4gICAgICBjb25zdCB0cmFuc2Zvcm1SZXN1bHQgPVxuICAgICAgICB0aGlzLmRhdGFUcmFuc2Zvcm1GbiAmJiB0aGlzLmRhdGFUcmFuc2Zvcm1GbltzZWN0aW9uLmxhYmVsXVxuICAgICAgICAgID8gdGhpcy5kYXRhVHJhbnNmb3JtRm5bc2VjdGlvbi5sYWJlbF0oc2VjdGlvbiwgaSlcbiAgICAgICAgICA6IHsgbWFpbjogaSwgb3Bwb3NpdGU6IC0xIH07XG4gICAgICByZXN1bHQubWFpbi5wdXNoKHRyYW5zZm9ybVJlc3VsdC5tYWluKTtcbiAgICAgIHJlc3VsdC5vcHBvc2l0ZS5wdXNoKHRyYW5zZm9ybVJlc3VsdC5vcHBvc2l0ZSk7XG4gICAgfVxuXG4gICAgcmVzdWx0Lm1haW4ucHVzaChzZWN0aW9uLmVuZCk7XG4gICAgcmVzdWx0Lm9wcG9zaXRlLnB1c2gobnVsbCk7XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIHByb3RlY3RlZCBkZXJpdmVIaWdobGlnaHRlZFBvaW50c0luQXhpcyA9IChzZWN0aW9uOiBDaGVsbDFEU2VjdGlvbjxUPikgPT4ge1xuICAgIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAgIG1haW46IFtzZWN0aW9uLnN0YXJ0XSxcbiAgICAgIG9wcG9zaXRlOiBbbnVsbF0gYXMgQXJyYXk8bnVtYmVyIHwgbnVsbD4sXG4gICAgfTtcblxuICAgIHJlc3VsdC5tYWluLnB1c2goc2VjdGlvbi5zdGFydCk7XG4gICAgcmVzdWx0Lm9wcG9zaXRlLnB1c2goLTEpO1xuXG4gICAgcmVzdWx0Lm1haW4ucHVzaChzZWN0aW9uLnN0YXJ0KTtcbiAgICByZXN1bHQub3Bwb3NpdGUucHVzaCgxKTtcblxuICAgIHJlc3VsdC5tYWluLnB1c2goc2VjdGlvbi5lbmQpO1xuICAgIHJlc3VsdC5vcHBvc2l0ZS5wdXNoKDEpO1xuXG4gICAgcmVzdWx0Lm1haW4ucHVzaChzZWN0aW9uLmVuZCk7XG4gICAgcmVzdWx0Lm9wcG9zaXRlLnB1c2goLTEpO1xuXG4gICAgcmVzdWx0Lm1haW4ucHVzaChzZWN0aW9uLmVuZCk7XG4gICAgcmVzdWx0Lm9wcG9zaXRlLnB1c2gobnVsbCk7XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xufVxuIiwiaW1wb3J0ICogYXMgcGxvdGx5IGZyb20gJ3Bsb3RseS5qcy1nbDJkLWRpc3QnO1xuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xuXG5pbXBvcnQgeyBCdXR0b24sIEljb24gfSBmcm9tICdzZW1hbnRpYy11aS1yZWFjdCc7XG5pbXBvcnQgeyBBdXhpbGlhcnlBeGlzLCBQbG90bHlDaGFydCwgU2Vjb25kYXJ5U3RydWN0dXJlQXhpcywgU2V0dGluZ3NQYW5lbCB9IGZyb20gJ35jaGVsbC12aXp+L2NvbXBvbmVudCc7XG5pbXBvcnQgeyBDaGVsbFdpZGdldENvbmZpZywgSVBsb3RseURhdGEsIFJFU0lEVUVfVFlQRSwgU0VDT05EQVJZX1NUUlVDVFVSRSB9IGZyb20gJ35jaGVsbC12aXp+L2RhdGEnO1xuaW1wb3J0IHsgZ2VuZXJhdGVTY2F0dGVyR0xEYXRhIH0gZnJvbSAnfmNoZWxsLXZpen4vaGVscGVyJztcblxuZXhwb3J0IGludGVyZmFjZSBJQ29udGFjdE1hcENoYXJ0UHJvcHMge1xuICBjYW5kaWRhdGVSZXNpZHVlczogUkVTSURVRV9UWVBFW107XG4gIGNvbmZpZ3VyYXRpb25zOiBDaGVsbFdpZGdldENvbmZpZ1tdO1xuICBjb250YWN0RGF0YTogSUNvbnRhY3RNYXBDaGFydERhdGFbXTtcbiAgaGVpZ2h0OiBudW1iZXIgfCBzdHJpbmc7XG4gIGxlZ2VuZE1vZGlmaWVyczoge1xuICAgIHk6IG51bWJlcjtcbiAgfTtcbiAgbWFyZ2luTW9kaWZpZXJzOiB7XG4gICAgYjogbnVtYmVyO1xuICAgIGw6IG51bWJlcjtcbiAgfTtcbiAgcmFuZ2U6IG51bWJlcjtcbiAgc2Vjb25kYXJ5U3RydWN0dXJlczogU0VDT05EQVJZX1NUUlVDVFVSRVtdO1xuICBzZWxlY3RlZFNlY29uZGFyeVN0cnVjdHVyZXM6IFNFQ09OREFSWV9TVFJVQ1RVUkVbXTtcbiAgc2VsZWN0ZWRTZWNvbmRhcnlTdHJ1Y3R1cmVzQ29sb3I6IHN0cmluZztcbiAgc2hvd0NvbmZpZ3VyYXRpb25zOiBib29sZWFuO1xuICB3aWR0aDogbnVtYmVyIHwgc3RyaW5nO1xuICBkYXRhVHJhbnNmb3JtRm4oZW50cnk6IElDb250YWN0TWFwQ2hhcnREYXRhLCBtaXJyb3JQb2ludHM6IGJvb2xlYW4pOiBQYXJ0aWFsPElQbG90bHlEYXRhPjtcbiAgb25DbGlja0NhbGxiYWNrPyguLi5hcmdzOiBhbnlbXSk6IHZvaWQ7XG4gIG9uSG92ZXJDYWxsYmFjaz8oLi4uYXJnczogYW55W10pOiB2b2lkO1xuICBvblNlbGVjdGVkQ2FsbGJhY2s/KC4uLmFyZ3M6IGFueVtdKTogdm9pZDtcbiAgb25VbkhvdmVyQ2FsbGJhY2s/KC4uLmFyZ3M6IGFueVtdKTogdm9pZDtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBJQ29udGFjdE1hcENoYXJ0U3RhdGUge1xuICBudW1MZWdlbmRzOiBudW1iZXI7XG4gIHBsb3RseURhdGE6IEFycmF5PFBhcnRpYWw8SVBsb3RseURhdGE+PjtcbiAgc2hvd2xlZ2VuZDogYm9vbGVhbjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBJQ29udGFjdE1hcENoYXJ0RGF0YSBleHRlbmRzIFBhcnRpYWw8SVBsb3RseURhdGE+IHtcbiAgbmFtZTogc3RyaW5nO1xuICBub2RlU2l6ZTogbnVtYmVyO1xuICBwb2ludHM6IElDb250YWN0TWFwQ2hhcnRQb2ludFtdO1xuICBzdWJ0aXRsZT86IHN0cmluZztcbn1cblxuZXhwb3J0IGNvbnN0IGdlbmVyYXRlQ2hhcnREYXRhRW50cnkgPSAoXG4gIGhvdmVyaW5mbzogcGxvdGx5LlNjYXR0ZXJEYXRhWydob3ZlcmluZm8nXSxcbiAgY29sb3I6IHN0cmluZyB8IHsgc3RhcnQ6IHN0cmluZzsgZW5kOiBzdHJpbmcgfSxcbiAgbmFtZTogc3RyaW5nLFxuICBzdWJ0aXRsZTogc3RyaW5nLFxuICBub2RlU2l6ZTogbnVtYmVyLFxuICBwb2ludHM6IElDb250YWN0TWFwQ2hhcnRQb2ludFtdLFxuICBleHRyYTogUGFydGlhbDxJUGxvdGx5RGF0YT4gPSB7fSxcbik6IElDb250YWN0TWFwQ2hhcnREYXRhID0+ICh7XG4gIGhvdmVyaW5mbyxcbiAgbWFya2VyOlxuICAgIHR5cGVvZiBjb2xvciA9PT0gJ3N0cmluZydcbiAgICAgID8geyBjb2xvcjogbmV3IEFycmF5KHBvaW50cy5sZW5ndGggKiAyKS5maWxsKGNvbG9yKSB9XG4gICAgICA6IHtcbiAgICAgICAgICBjb2xvcnNjYWxlOiBbXG4gICAgICAgICAgICBbMCwgJ3JnYigxMiw1MCwxMDIpJ10sXG4gICAgICAgICAgICBbMC4xLCAncmdiKDE3LDgzLDE1MCknXSxcbiAgICAgICAgICAgIFswLjIsICdyZ2IoNDAsMTE0LDE3NSknXSxcbiAgICAgICAgICAgIFswLjMsICdyZ2IoNzEsMTQ3LDE5MyknXSxcbiAgICAgICAgICAgIFswLjQsICdyZ2IoMTExLDE3NSwyMDkpJ10sXG4gICAgICAgICAgICBbMC41LCAncmdiKDE2MCwyMDIsMjIyKSddLFxuICAgICAgICAgICAgWzAuNiwgJ3JnYigyMDAsMjE5LDIzNyknXSxcbiAgICAgICAgICAgIFswLjcsICdyZ2IoMjI0LDIzNSwyNDYpJ10sXG4gICAgICAgICAgICBbMC44LCAncmdiKDI0NywyNTEsMjU1KSddLFxuICAgICAgICAgICAgWzAuOSwgJ3JnYigyNDksMjUzLDI1NSknXSxcbiAgICAgICAgICAgIFsxLCAncmdiKDI1NSwyNTUsMjU1KSddLFxuICAgICAgICAgIF0sXG4gICAgICAgIH0sXG4gIG1vZGU6ICdsaW5lcyttYXJrZXJzJyxcbiAgbmFtZSxcbiAgbm9kZVNpemUsXG4gIHBvaW50cyxcbiAgc3VidGl0bGUsXG4gIC4uLmV4dHJhLFxufSk7XG5cbmV4cG9ydCBpbnRlcmZhY2UgSUNvbnRhY3RNYXBDaGFydFBvaW50IHtcbiAgZGlzdD86IG51bWJlcjtcbiAgaTogbnVtYmVyO1xuICBqOiBudW1iZXI7XG59XG5cbi8qKlxuICogSW50ZXJtZWRpYXJ5IGJldHdlZW4gYSBDb250YWN0TWFwIGFuZCBhIFBsb3RseUNoYXJ0LlxuICpcbiAqIFdpbGwgdHJhbnNmb3JtIGRhdGEgYW5kIHNldHVwIGxheW91dCBmcm9tIHNjaWVuY2UvY2hlbGwgZGF0YSB0eXBlIGludG8gdGhlIFBsb3RseSB0eXBlLlxuICogQGV4dGVuZHMge1JlYWN0LkNvbXBvbmVudDxJQ29udGFjdE1hcENoYXJ0UHJvcHMsIGFueT59XG4gKi9cbmV4cG9ydCBjbGFzcyBDb250YWN0TWFwQ2hhcnQgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQ8SUNvbnRhY3RNYXBDaGFydFByb3BzLCBJQ29udGFjdE1hcENoYXJ0U3RhdGU+IHtcbiAgcHVibGljIHN0YXRpYyBkZWZhdWx0UHJvcHMgPSB7XG4gICAgY2FuZGlkYXRlUmVzaWR1ZXM6IG5ldyBBcnJheTxSRVNJRFVFX1RZUEU+KCksXG4gICAgY29uZmlndXJhdGlvbnM6IG5ldyBBcnJheTxDaGVsbFdpZGdldENvbmZpZz4oKSxcbiAgICBkYXRhVHJhbnNmb3JtRm46IGdlbmVyYXRlU2NhdHRlckdMRGF0YSxcbiAgICBoZWlnaHQ6ICcxMDAlJyxcbiAgICBsZWdlbmRNb2RpZmllcnM6IHtcbiAgICAgIHk6IC0wLjQsXG4gICAgfSxcbiAgICBtYXJnaW5Nb2RpZmllcnM6IHtcbiAgICAgIGI6IDY1LFxuICAgICAgbDogNjUsXG4gICAgfSxcbiAgICByYW5nZTogMTAwLFxuICAgIHNlY29uZGFyeVN0cnVjdHVyZXM6IFtdLFxuICAgIHNlbGVjdGVkU2Vjb25kYXJ5U3RydWN0dXJlczogW10sXG4gICAgc2VsZWN0ZWRTZWNvbmRhcnlTdHJ1Y3R1cmVzQ29sb3I6ICcjZmViODNmJyxcbiAgICBzaG93Q29uZmlndXJhdGlvbnM6IHRydWUsXG4gICAgd2lkdGg6ICcxMDAlJyxcbiAgfTtcblxuICBjb25zdHJ1Y3Rvcihwcm9wczogSUNvbnRhY3RNYXBDaGFydFByb3BzKSB7XG4gICAgc3VwZXIocHJvcHMpO1xuICAgIHRoaXMuc3RhdGUgPSB7XG4gICAgICBudW1MZWdlbmRzOiAwLFxuICAgICAgcGxvdGx5RGF0YTogW10sXG4gICAgICBzaG93bGVnZW5kOiBmYWxzZSxcbiAgICB9O1xuICB9XG5cbiAgcHVibGljIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgIHRoaXMuc2V0dXBEYXRhKCk7XG4gIH1cblxuICBwdWJsaWMgY29tcG9uZW50RGlkVXBkYXRlKHByZXZQcm9wczogSUNvbnRhY3RNYXBDaGFydFByb3BzKSB7XG4gICAgY29uc3QgeyBjb250YWN0RGF0YSwgc2Vjb25kYXJ5U3RydWN0dXJlcywgc2VsZWN0ZWRTZWNvbmRhcnlTdHJ1Y3R1cmVzIH0gPSB0aGlzLnByb3BzO1xuICAgIGlmIChcbiAgICAgIHByZXZQcm9wcy5jb250YWN0RGF0YSAhPT0gY29udGFjdERhdGEgfHxcbiAgICAgIHByZXZQcm9wcy5zZWNvbmRhcnlTdHJ1Y3R1cmVzICE9PSBzZWNvbmRhcnlTdHJ1Y3R1cmVzIHx8XG4gICAgICBwcmV2UHJvcHMuc2VsZWN0ZWRTZWNvbmRhcnlTdHJ1Y3R1cmVzICE9PSBzZWxlY3RlZFNlY29uZGFyeVN0cnVjdHVyZXNcbiAgICApIHtcbiAgICAgIHRoaXMuc2V0dXBEYXRhKCk7XG4gICAgfVxuICB9XG5cbiAgcHVibGljIHJlbmRlcigpIHtcbiAgICBjb25zdCB7XG4gICAgICBjb25maWd1cmF0aW9ucyxcbiAgICAgIGNvbnRhY3REYXRhLFxuICAgICAgbGVnZW5kTW9kaWZpZXJzLFxuICAgICAgbWFyZ2luTW9kaWZpZXJzLFxuICAgICAgcmFuZ2UsXG4gICAgICBzaG93Q29uZmlndXJhdGlvbnMsXG4gICAgICAuLi5wYXNzVGhyb3VnaFByb3BzXG4gICAgfSA9IHRoaXMucHJvcHM7XG4gICAgY29uc3QgeyBwbG90bHlEYXRhLCBzaG93bGVnZW5kIH0gPSB0aGlzLnN0YXRlO1xuXG4gICAgcmV0dXJuIChcbiAgICAgIDxTZXR0aW5nc1BhbmVsIGNvbmZpZ3VyYXRpb25zPXtjb25maWd1cmF0aW9uc30gc2hvd0NvbmZpZ3VyYXRpb25zPXtzaG93Q29uZmlndXJhdGlvbnN9PlxuICAgICAgICA8QnV0dG9uXG4gICAgICAgICAgYmFzaWM9e3RydWV9XG4gICAgICAgICAgZmxvYXRlZD17J2xlZnQnfVxuICAgICAgICAgIGljb249ezxJY29uIG5hbWU9eydxdWVzdGlvbiBjaXJjbGUgb3V0bGluZSd9IHNpemU9eydsYXJnZSd9IC8+fVxuICAgICAgICAgIG9uQ2xpY2s9e3RoaXMudG9nZ2xlTGVnZW5kVmlzaWJpbGl0eX1cbiAgICAgICAgICBzdHlsZT17eyBmbG9hdDogJ2xlZnQnLCBtYXJnaW46ICcwIDAgMCAxNXB4JywgcG9zaXRpb246ICdyZWxhdGl2ZScsIHRvcDogJzUwMHB4JywgekluZGV4OiA5OTkgfX1cbiAgICAgICAgLz5cbiAgICAgICAgPFBsb3RseUNoYXJ0XG4gICAgICAgICAgZGF0YT17cGxvdGx5RGF0YX1cbiAgICAgICAgICBsYXlvdXQ9e3tcbiAgICAgICAgICAgIGxlZ2VuZDoge1xuICAgICAgICAgICAgICBvcmllbnRhdGlvbjogJ2gnLFxuICAgICAgICAgICAgICB5OiBsZWdlbmRNb2RpZmllcnMueSxcbiAgICAgICAgICAgICAgeWFuY2hvcjogJ2JvdHRvbScsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbWFyZ2luOiB7XG4gICAgICAgICAgICAgIGI6IG1hcmdpbk1vZGlmaWVycy5iLFxuICAgICAgICAgICAgICBsOiBtYXJnaW5Nb2RpZmllcnMubCxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzaG93bGVnZW5kLFxuICAgICAgICAgICAgeGF4aXM6IHtcbiAgICAgICAgICAgICAgYXV0b3JhbmdlOiB0cnVlLFxuICAgICAgICAgICAgICBmaXhlZHJhbmdlOiB0cnVlLFxuICAgICAgICAgICAgICBudGlja3M6IDEwLFxuICAgICAgICAgICAgICByYW5nZTogWzAsIDMzMDAwXSxcbiAgICAgICAgICAgICAgcmFuZ2Vtb2RlOiAnbm9ubmVnYXRpdmUnLFxuICAgICAgICAgICAgICBzaG93bGluZTogdHJ1ZSxcbiAgICAgICAgICAgICAgdGlja21vZGU6ICdhdXRvJyxcbiAgICAgICAgICAgICAgdGl0bGU6ICdSZXNpZHVlICMnLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHlheGlzOiB7XG4gICAgICAgICAgICAgIGF1dG9yYW5nZTogJ3JldmVyc2VkJyxcbiAgICAgICAgICAgICAgZml4ZWRyYW5nZTogdHJ1ZSxcbiAgICAgICAgICAgICAgbnRpY2tzOiAxMCxcbiAgICAgICAgICAgICAgcmFuZ2U6IFswLCAzMzAwMF0sXG4gICAgICAgICAgICAgIHJhbmdlbW9kZTogJ25vbm5lZ2F0aXZlJyxcbiAgICAgICAgICAgICAgc2hvd2xpbmU6IHRydWUsXG4gICAgICAgICAgICAgIHRpY2ttb2RlOiAnYXV0bycsXG4gICAgICAgICAgICAgIHRpdGxlOiAnUmVzaWR1ZSAjJyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgfX1cbiAgICAgICAgICB7Li4ucGFzc1Rocm91Z2hQcm9wc31cbiAgICAgICAgLz5cbiAgICAgIDwvU2V0dGluZ3NQYW5lbD5cbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdXAgdGhlIGNoYXJ0IGFuZCBheGlzIGRhdGEgZm9yIHRoZSBDb250YWN0TWFwLlxuICAgKlxuICAgKiBUcmFuc2Zvcm1zIGFsbCBkYXRhIGZyb20gY2hlbGwgdGVybWlub2xvZ3kgdG8gZGF0YSBwcm9wZXJseSBmb3JtYXR0ZWQgZm9yIFBsb3RseSBjb25zdW1wdGlvbi5cbiAgICovXG4gIHByb3RlY3RlZCBzZXR1cERhdGEoKSB7XG4gICAgY29uc3QgeyBjb250YWN0RGF0YSwgZGF0YVRyYW5zZm9ybUZuLCBzZWNvbmRhcnlTdHJ1Y3R1cmVzLCBzZWxlY3RlZFNlY29uZGFyeVN0cnVjdHVyZXMgfSA9IHRoaXMucHJvcHM7XG4gICAgY29uc3QgcGxvdGx5RGF0YSA9IFsuLi5jb250YWN0RGF0YS5tYXAoZW50cnkgPT4gZGF0YVRyYW5zZm9ybUZuKGVudHJ5LCB0cnVlKSldO1xuICAgIHNlY29uZGFyeVN0cnVjdHVyZXMuZm9yRWFjaCgoc2Vjb25kYXJ5U3RydWN0dXJlLCBpbmRleCkgPT4ge1xuICAgICAgY29uc3QgYXhpcyA9IG5ldyBTZWNvbmRhcnlTdHJ1Y3R1cmVBeGlzKHNlY29uZGFyeVN0cnVjdHVyZSwgMywgaW5kZXggKyAyKTtcbiAgICAgIHBsb3RseURhdGEucHVzaCguLi5heGlzLnhBeGVzLCAuLi5heGlzLnlBeGVzKTtcbiAgICB9KTtcblxuICAgIGNvbnN0IGhpZ2hsaWdodGVkQXhlcyA9IG5ldyBBcnJheTxQYXJ0aWFsPElQbG90bHlEYXRhPj4oKTtcbiAgICBzZWxlY3RlZFNlY29uZGFyeVN0cnVjdHVyZXMuZm9yRWFjaCgoc2VsZWN0ZWRTdHJ1Y3R1cmUsIGluZGV4KSA9PiB7XG4gICAgICBjb25zdCBheGlzID0gbmV3IEF1eGlsaWFyeUF4aXMoc2VsZWN0ZWRTdHJ1Y3R1cmUsIGluZGV4ICsgMiwgJ29yYW5nZScpO1xuICAgICAgaGlnaGxpZ2h0ZWRBeGVzLnB1c2goLi4uYXhpcy5oaWdobGlnaHRlZFhBeGVzLCAuLi5heGlzLmhpZ2hsaWdodGVkWUF4ZXMpO1xuICAgIH0pO1xuXG4gICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICBudW1MZWdlbmRzOiBuZXcgU2V0KFxuICAgICAgICBwbG90bHlEYXRhLmZpbHRlcihkYXR1bSA9PiBkYXR1bS5zaG93bGVnZW5kICE9PSBmYWxzZSAmJiBkYXR1bS5uYW1lICE9PSB1bmRlZmluZWQpLm1hcChsZWdlbmQgPT4gbGVnZW5kLm5hbWUpLFxuICAgICAgKS5zaXplLFxuICAgICAgLy8gTWFrZXMgc3VyZSB0aGF0IGhpZ2hsaWdodGVkIGF4aXMgaXMgYmVoaW5kIHRoZSBheGlzLlxuICAgICAgcGxvdGx5RGF0YTogWy4uLmhpZ2hsaWdodGVkQXhlcywgLi4ucGxvdGx5RGF0YV0sXG4gICAgfSk7XG4gIH1cblxuICBwcm90ZWN0ZWQgdG9nZ2xlTGVnZW5kVmlzaWJpbGl0eSA9ICgpID0+IHtcbiAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgIHNob3dsZWdlbmQ6ICF0aGlzLnN0YXRlLnNob3dsZWdlbmQsXG4gICAgfSk7XG4gIH07XG59XG4iLCJpbXBvcnQgKiBhcyBJbW11dGFibGUgZnJvbSAnaW1tdXRhYmxlJztcbmltcG9ydCB7IGlzRXF1YWwgfSBmcm9tICdsb2Rhc2gnO1xuaW1wb3J0ICogYXMgcGxvdGx5IGZyb20gJ3Bsb3RseS5qcy1nbDJkLWRpc3QnO1xuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgRGltbWVyLCBMb2FkZXIgfSBmcm9tICdzZW1hbnRpYy11aS1yZWFjdCc7XG5cbmltcG9ydCB7XG4gIENIRUxMX0NIQVJUX0VWRU5UX1RZUEUsXG4gIENIRUxMX0NIQVJUX1BJRUNFLFxuICBDSEVMTF9DU1NfU1RZTEUsXG4gIENoZWxsQ2hhcnRFdmVudCxcbiAgSVBsb3RseURhdGEsXG4gIElQbG90bHlMYXlvdXQsXG59IGZyb20gJ35jaGVsbC12aXp+L2RhdGEnO1xuXG5leHBvcnQgaW50ZXJmYWNlIElQbG90bHlDaGFydFByb3BzIHtcbiAgY29uZmlnPzogUGFydGlhbDxQbG90bHkuQ29uZmlnPjtcbiAgZGF0YTogQXJyYXk8UGFydGlhbDxJUGxvdGx5RGF0YT4+O1xuICBoZWlnaHQ/OiBudW1iZXIgfCBzdHJpbmc7XG4gIGxheW91dD86IFBhcnRpYWw8SVBsb3RseUxheW91dD47XG4gIG9uQWZ0ZXJQbG90Q2FsbGJhY2s/OiAoKGV2ZW50OiBDaGVsbENoYXJ0RXZlbnQpID0+IHZvaWQpO1xuICBvbkNsaWNrQ2FsbGJhY2s/OiAoKGV2ZW50OiBDaGVsbENoYXJ0RXZlbnQpID0+IHZvaWQpO1xuICBvbkRvdWJsZUNsaWNrQ2FsbGJhY2s/OiAoKGV2ZW50OiBDaGVsbENoYXJ0RXZlbnQpID0+IHZvaWQpO1xuICBvbkhvdmVyQ2FsbGJhY2s/OiAoKGV2ZW50OiBDaGVsbENoYXJ0RXZlbnQpID0+IHZvaWQpO1xuICBvblNlbGVjdGVkQ2FsbGJhY2s/OiAoKGV2ZW50OiBDaGVsbENoYXJ0RXZlbnQpID0+IHZvaWQpO1xuICBvblVuSG92ZXJDYWxsYmFjaz86ICgoZXZlbnQ6IENoZWxsQ2hhcnRFdmVudCkgPT4gdm9pZCk7XG4gIG9uUmVsYXlvdXRDYWxsYmFjaz86ICgoZXZlbnQ6IENoZWxsQ2hhcnRFdmVudCkgPT4gdm9pZCk7XG4gIHNob3dMb2FkZXI/OiBib29sZWFuO1xuICBzdHlsZT86IENIRUxMX0NTU19TVFlMRTtcbiAgd2lkdGg/OiBudW1iZXIgfCBzdHJpbmc7XG59XG5cbmV4cG9ydCBjb25zdCBkZWZhdWx0UGxvdGx5Q29uZmlnOiBQYXJ0aWFsPFBsb3RseS5Db25maWc+ID0ge1xuICBkaXNwbGF5TW9kZUJhcjogZmFsc2UsXG4gIGRvdWJsZUNsaWNrOiAncmVzZXQnLFxuICBzY3JvbGxab29tOiB0cnVlLFxuICBzaG93QXhpc0RyYWdIYW5kbGVzOiBmYWxzZSxcbiAgc3RhdGljUGxvdDogZmFsc2UsXG4gIC8vIG1vZGVCYXJCdXR0b25zOiBbWyd6b29tT3V0MmQnLCAnem9vbUluMmQnXSwgWydyZXNldFNjYWxlMmQnLCAnYXV0b1NjYWxlMmQnXSwgWydzZWxlY3QyZCcsICdwYW4yZCddXSxcbn07XG5cbmV4cG9ydCBjb25zdCBkZWZhdWx0UGxvdGx5TGF5b3V0OiBQYXJ0aWFsPElQbG90bHlMYXlvdXQ+ID0ge1xuICBhdXRvc2l6ZTogdHJ1ZSxcbiAgZHJhZ21vZGU6ICd6b29tJyxcbiAgaG92ZXJtb2RlOiAnY2xvc2VzdCcsXG4gIGxlZ2VuZDoge30sXG4gIG1hcmdpbjoge1xuICAgIGI6IDEwLFxuICAgIGw6IDQwLFxuICAgIHI6IDEwLFxuICAgIHQ6IDEwLFxuICB9LFxuICBzaG93bGVnZW5kOiBmYWxzZSxcbiAgdGl0bGU6ICcnLFxufTtcblxuLyoqXG4gKiBSZWFjdCB3cmFwcGVyIGZvciBhIFBsb3RseSBDaGFydC5cbiAqXG4gKiBAZGVzY3JpcHRpb25cbiAqIEJhc2VkIHVwb246IGh0dHBzOi8vZ2l0aHViLmNvbS9kYXZpZGN0ai9yZWFjdC1wbG90bHlqcy10c1xuICpcbiAqIEBleHBvcnRcbiAqIEBleHRlbmRzIHtSZWFjdC5Db21wb25lbnQ8SVBsb3RseUNoYXJ0UHJvcHMsIGFueT59XG4gKi9cbmV4cG9ydCBjbGFzcyBQbG90bHlDaGFydCBleHRlbmRzIFJlYWN0LkNvbXBvbmVudDxJUGxvdGx5Q2hhcnRQcm9wcywgYW55PiB7XG4gIHB1YmxpYyBzdGF0aWMgZGVmYXVsdFByb3BzID0ge1xuICAgIGNvbmZpZzoge30sXG4gICAgZGF0YTogW10sXG4gICAgaGVpZ2h0OiAnMTAwJScsXG4gICAgbGF5b3V0OiB7fSxcbiAgICBzaG93TG9hZGVyOiB0cnVlLFxuICAgIHdpZHRoOiAnMTAwJScsXG4gIH07XG5cbiAgcHVibGljIHBsb3RseUNhbnZhczogcGxvdGx5LlBsb3RseUhUTUxFbGVtZW50IHwgbnVsbCA9IG51bGw7XG4gIC8vIE1ha2VzIHN1cmUgc2luZ2xlIGNsaWNrIGlzbid0IGZpcmVkIHdoZW4gZG91YmxlIGNsaWNrIGlzIGluIGZsaWdodC4gUmVxdWlyZWQgZHVlIHRvIGh0dHBzOi8vZ2l0aHViLmNvbS9wbG90bHkvcGxvdGx5LmpzL2lzc3Vlcy8xNTQ2XG4gIHByb3RlY3RlZCBpc0RvdWJsZUNsaWNrSW5Qcm9ncmVzcyA9IGZhbHNlO1xuICBwcm90ZWN0ZWQgY2FudmFzUmVmOiBIVE1MRGl2RWxlbWVudCB8IG51bGwgPSBudWxsO1xuICBwcm90ZWN0ZWQgcGxvdGx5Rm9ybWF0dGVkRGF0YTogQXJyYXk8UGFydGlhbDxJUGxvdGx5RGF0YT4+ID0gW107XG4gIHByb3RlY3RlZCByZW5kZXJUaW1lb3V0OiB1bmRlZmluZWQgfCBOb2RlSlMuVGltZXIgfCBudW1iZXI7XG4gIHByb3RlY3RlZCBzYXZlZEF4aXNab29tPzogeyB4YXhpczogcGxvdGx5LlBsb3RBeGlzOyB5YXhpczogcGxvdGx5LlBsb3RBeGlzIH07XG5cbiAgLyoqXG4gICAqIFNldHVwIGFsbCB0aGUgZXZlbnQgbGlzdGVuZXJzIGZvciB0aGUgcGxvdGx5IGNhbnZhcy5cbiAgICovXG4gIHB1YmxpYyBhdHRhY2hMaXN0ZW5lcnMoKSB7XG4gICAgaWYgKHRoaXMucGxvdGx5Q2FudmFzKSB7XG4gICAgICB0aGlzLnBsb3RseUNhbnZhcy5vbigncGxvdGx5X2FmdGVycGxvdCcsIHRoaXMub25BZnRlclBsb3QpO1xuICAgICAgdGhpcy5wbG90bHlDYW52YXMub24oJ3Bsb3RseV9jbGljaycsIHRoaXMub25DbGljayk7XG4gICAgICB0aGlzLnBsb3RseUNhbnZhcy5vbigncGxvdGx5X2RvdWJsZWNsaWNrJywgdGhpcy5vbkRvdWJsZUNsaWNrKTtcbiAgICAgIHRoaXMucGxvdGx5Q2FudmFzLm9uKCdwbG90bHlfaG92ZXInLCB0aGlzLm9uSG92ZXIpO1xuICAgICAgdGhpcy5wbG90bHlDYW52YXMub24oJ3Bsb3RseV9yZWxheW91dCcsIHRoaXMub25SZWxheW91dCBhcyBhbnkpO1xuICAgICAgdGhpcy5wbG90bHlDYW52YXMub24oJ3Bsb3RseV9zZWxlY3RlZCcsIHRoaXMub25TZWxlY3QpO1xuICAgICAgdGhpcy5wbG90bHlDYW52YXMub24oJ3Bsb3RseV91bmhvdmVyJywgdGhpcy5vblVuSG92ZXIpO1xuICAgIH1cbiAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigncmVzaXplJywgdGhpcy5yZXNpemUpO1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCB0aGlzLnJlc2l6ZSk7XG4gIH1cblxuICAvKipcbiAgICogUmVzaXplcyB0aGUgaW5uZXIgUGxvdGx5IGNhbnZhcy5cbiAgICovXG4gIHB1YmxpYyByZXNpemUgPSAoKSA9PiB7XG4gICAgaWYgKHRoaXMucGxvdGx5Q2FudmFzKSB7XG4gICAgICBwbG90bHkuUGxvdHMucmVzaXplKHRoaXMucGxvdGx5Q2FudmFzKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFNlbmRzIGEgZHJhdyBjYWxsIHRvIFBsb3RseSBzaW5jZSBpdCBpcyB1c2luZyBjYW52YXMvV2ViR0wgd2hpY2ggaXMgb3V0c2lkZSBvZiB0aGUgbG9jdXMgb2YgY29udHJvbCBmb3IgUmVhY3QuXG4gICAqL1xuICBwdWJsaWMgZHJhdyA9IGFzeW5jICgpID0+IHtcbiAgICBjb25zdCB7IGNvbmZpZywgbGF5b3V0IH0gPSB0aGlzLnByb3BzO1xuICAgIGlmICh0aGlzLnBsb3RseUNhbnZhcyAmJiB0aGlzLmNhbnZhc1JlZikge1xuICAgICAgY29uc3QgbWVyZ2VkTGF5b3V0ID0gdGhpcy5nZXRNZXJnZWRMYXlvdXQobGF5b3V0LCB0aGlzLnBsb3RseUZvcm1hdHRlZERhdGEpO1xuICAgICAgY29uc3QgbWVyZ2VkQ29uZmlnID0gdGhpcy5nZXRNZXJnZWRDb25maWcoY29uZmlnKTtcbiAgICAgIC8vIGNvbnNvbGUubG9nKG1lcmdlZExheW91dCk7XG4gICAgICAvLyBjb25zb2xlLmxvZyhtZXJnZWRDb25maWcpO1xuICAgICAgdGhpcy5wbG90bHlDYW52YXMgPSBhd2FpdCBwbG90bHkucmVhY3QodGhpcy5jYW52YXNSZWYsIHRoaXMucGxvdGx5Rm9ybWF0dGVkRGF0YSwgbWVyZ2VkTGF5b3V0LCBtZXJnZWRDb25maWcpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogRGV0ZXJtaW5lcyBpZiB3ZSBzaG91bGQgc2VuZCBhIGRyYXcgY2FsbCB0byBQbG90bHkgYmFzZWQgb24gaWYgZGF0YSBoYXMgYWN0dWFsbHkgY2hhbmdlZC5cbiAgICpcbiAgICogQHBhcmFtIHByZXZQcm9wcyBUaGUgcHJldmlvdXMgcHJvcHMgZm9yIHRoZSBQbG90bHlDaGFydC5cbiAgICovXG4gIHB1YmxpYyBhc3luYyBjb21wb25lbnREaWRVcGRhdGUocHJldlByb3BzOiBJUGxvdGx5Q2hhcnRQcm9wcykge1xuICAgIGNvbnN0IHsgZGF0YSwgbGF5b3V0LCBjb25maWcgfSA9IHRoaXMucHJvcHM7XG4gICAgaWYgKCFpc0VxdWFsKGRhdGEsIHByZXZQcm9wcy5kYXRhKSB8fCAhaXNFcXVhbChsYXlvdXQsIHByZXZQcm9wcy5sYXlvdXQpIHx8ICFpc0VxdWFsKGNvbmZpZywgcHJldlByb3BzLmNvbmZpZykpIHtcbiAgICAgIHRoaXMucGxvdGx5Rm9ybWF0dGVkRGF0YSA9IGlzRXF1YWwoZGF0YSwgcHJldlByb3BzLmRhdGEpXG4gICAgICAgID8gdGhpcy5wbG90bHlGb3JtYXR0ZWREYXRhXG4gICAgICAgIDogKChJbW11dGFibGUuZnJvbUpTKGRhdGEpIGFzIEltbXV0YWJsZS5MaXN0PGtleW9mIElQbG90bHlEYXRhPikudG9KUygpIGFzIElQbG90bHlEYXRhW10pO1xuICAgICAgYXdhaXQgdGhpcy5kcmF3KCk7XG4gICAgfVxuICB9XG5cbiAgcHVibGljIGFzeW5jIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgIC8qXG4gICAgY29uc3QgcmVuZGVyVGltZW91dCA9IGFzeW5jICgpID0+IHtcbiAgICAgIGlmICh0aGlzLmNhbnZhc1JlZiAmJiB0aGlzLnBsb3RseUNhbnZhcykge1xuICAgICAgICBhd2FpdCB0aGlzLmRyYXcoKTtcbiAgICAgICAgdGhpcy5yZW5kZXJUaW1lb3V0ID0gc2V0VGltZW91dChyZW5kZXJUaW1lb3V0LCA1MCk7XG4gICAgICB9XG4gICAgfTtcbiAgICB0aGlzLnJlbmRlclRpbWVvdXQgPSBzZXRUaW1lb3V0KHJlbmRlclRpbWVvdXQsIDUwKTtcbiAgICAqL1xuXG4gICAgaWYgKHRoaXMuY2FudmFzUmVmICYmICF0aGlzLnBsb3RseUNhbnZhcykge1xuICAgICAgY29uc3QgeyBkYXRhIH0gPSB0aGlzLnByb3BzO1xuICAgICAgLy8gIUltcG9ydGFudCEgVGhpcyBpcyB0byBtYWtlIGEgREVFUCBDT1BZIG9mIHRoZSBkYXRhIGJlY2F1c2UgUGxvdGx5IHdpbGwgbW9kaWZ5IGl0LCB0aHVzIGNhdXNpbmcgZmFsc2UgcG9zaXRpdmUgZGF0YSB1cGRhdGVzLlxuICAgICAgY29uc3QgaW1tdXRhYmxlRGF0YSA9IEltbXV0YWJsZS5mcm9tSlMoZGF0YSkgYXMgSW1tdXRhYmxlLkxpc3Q8a2V5b2YgSVBsb3RseURhdGE+O1xuICAgICAgdGhpcy5wbG90bHlGb3JtYXR0ZWREYXRhID0gaW1tdXRhYmxlRGF0YS50b0pTKCkgYXMgSVBsb3RseURhdGFbXTtcblxuICAgICAgdGhpcy5wbG90bHlDYW52YXMgPSBhd2FpdCBwbG90bHkucmVhY3QodGhpcy5jYW52YXNSZWYsIHRoaXMucGxvdGx5Rm9ybWF0dGVkRGF0YSk7XG5cbiAgICAgIHRoaXMuYXR0YWNoTGlzdGVuZXJzKCk7XG4gICAgICBhd2FpdCB0aGlzLmRyYXcoKTtcbiAgICB9XG4gIH1cblxuICBwdWJsaWMgY29tcG9uZW50V2lsbFVubW91bnQoKSB7XG4gICAgaWYgKHRoaXMucmVuZGVyVGltZW91dCkge1xuICAgICAgY2xlYXJUaW1lb3V0KHRoaXMucmVuZGVyVGltZW91dCBhcyBudW1iZXIpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLnBsb3RseUNhbnZhcykge1xuICAgICAgcGxvdGx5LnB1cmdlKHRoaXMucGxvdGx5Q2FudmFzKTtcbiAgICAgIHRoaXMucGxvdGx5Q2FudmFzID0gbnVsbDtcbiAgICAgIHRoaXMuY2FudmFzUmVmID0gbnVsbDtcbiAgICB9XG4gICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIHRoaXMucmVzaXplKTtcbiAgfVxuXG4gIHB1YmxpYyByZW5kZXIoKSB7XG4gICAgY29uc3QgeyBoZWlnaHQsIHNob3dMb2FkZXIsIHN0eWxlLCB3aWR0aCB9ID0gdGhpcy5wcm9wcztcblxuICAgIHJldHVybiAoXG4gICAgICA8PlxuICAgICAgICB7c2hvd0xvYWRlciAmJiAoXG4gICAgICAgICAgPERpbW1lciBhY3RpdmU9eyF0aGlzLmlzRGF0YUxvYWRlZCgpfT5cbiAgICAgICAgICAgIDxMb2FkZXIgLz5cbiAgICAgICAgICA8L0RpbW1lcj5cbiAgICAgICAgKX1cbiAgICAgICAgPGRpdlxuICAgICAgICAgIGNsYXNzTmFtZT17J3Bsb3RseS1jaGFydCd9XG4gICAgICAgICAgcmVmPXtub2RlID0+ICh0aGlzLmNhbnZhc1JlZiA9IG5vZGUgPyBub2RlIDogbnVsbCl9XG4gICAgICAgICAgc3R5bGU9e3sgbWFyZ2luQm90dG9tOiA1LCAuLi5zdHlsZSwgaGVpZ2h0LCB3aWR0aCB9fVxuICAgICAgICAvPlxuICAgICAgPC8+XG4gICAgKTtcbiAgfVxuXG4gIHByb3RlY3RlZCBkZXJpdmVDaGFydFBpZWNlID0gKHhEYXR1bTogUGxvdGx5LkRhdHVtLCB5RGF0dW06IFBsb3RseS5EYXR1bSwgZGF0YT86IHBsb3RseS5TY2F0dGVyRGF0YSkgPT4ge1xuICAgIGNvbnN0IHggPSB4RGF0dW0gYXMgbnVtYmVyO1xuICAgIGNvbnN0IHkgPSB5RGF0dW0gYXMgbnVtYmVyO1xuXG4gICAgaWYgKGRhdGEpIHtcbiAgICAgIGNvbnN0IGlzRXh0cmFYQXhpcyA9IGRhdGEueGF4aXMgJiYgZGF0YS54YXhpcyAhPT0gJ3gnO1xuICAgICAgY29uc3QgaXNFeHRyYVlBeGlzID0gZGF0YS55YXhpcyAmJiBkYXRhLnlheGlzICE9PSAneSc7XG4gICAgICBpZiAoaXNFeHRyYVhBeGlzIHx8IGlzRXh0cmFZQXhpcykge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGNoYXJ0UGllY2U6IENIRUxMX0NIQVJUX1BJRUNFLkFYSVMsXG4gICAgICAgICAgc2VsZWN0ZWRQb2ludHM6IGlzRXh0cmFYQXhpcyA/IFt5XSA6IFt4XSxcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgY2hhcnRQaWVjZTogQ0hFTExfQ0hBUlRfUElFQ0UuUE9JTlQsXG4gICAgICBzZWxlY3RlZFBvaW50czogW3gsIHldLFxuICAgIH07XG4gIH07XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlIGF4aXMgZGF0YSBmb3IgdGhvc2UgYmV5b25kIHRoZSBvcmlnaW5hbCB4L3lheGlzLlxuICAgKlxuICAgKiBAcGFyYW0gaWRzIEFsbCBvZiB0aGUgYXhpcyBpZHMgYXNzb2NpYXRlZCB3aXRoIHBsb3RseSBkYXRhLlxuICAgKi9cbiAgcHJvdGVjdGVkIGdlbmVyYXRlRXh0cmFQbG90bHlBeGlzID0gKGlkczogU2V0PHN0cmluZz4pOiBQYXJ0aWFsPElQbG90bHlMYXlvdXQ+ID0+IHtcbiAgICByZXR1cm4gQXJyYXkuZnJvbShpZHMudmFsdWVzKCkpXG4gICAgICAuZmlsdGVyKGlkID0+IGlkLmxlbmd0aCA+PSAyKSAvLyBJZ25vcmVzIHsgeGF4aXM6IHggfSBhbmQgeyB5YXhpczogeSB9LlxuICAgICAgLm1hcChpZCA9PiB0aGlzLmdlbmVyYXRlRXh0cmFQbG90bHlBeGlzRnJvbUlkKGlkKSlcbiAgICAgIC5yZWR1Y2UoKHByZXYsIGN1cnIpID0+IHtcbiAgICAgICAgcmV0dXJuIHsgLi4ucHJldiwgLi4uY3VyciB9O1xuICAgICAgfSwge30pO1xuICB9O1xuXG4gIHByb3RlY3RlZCBnZW5lcmF0ZUV4dHJhUGxvdGx5QXhpc0Zyb21JZChpZDogc3RyaW5nKTogeyBba2V5OiBzdHJpbmddOiBQYXJ0aWFsPFBsb3RseS5MYXlvdXRBeGlzPiB9IHtcbiAgICBjb25zdCBheGlzSWQgPSBpZC5zdWJzdHIoMCwgMSkgYXMgJ3gnIHwgJ3knO1xuICAgIGNvbnN0IGF4aXNOdW0gPSBOdW1iZXIucGFyc2VJbnQoaWQuc3Vic3RyKDEpLCAxMCk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgW2Ake2F4aXNJZH1heGlzJHtheGlzTnVtfWBdOiB7XG4gICAgICAgIC8vIFRPRE8gSGF2ZSB0aGlzIG51bWJlciAtIDAuMDUgLSBiZSBjb25maWd1cmFibGUuIFJlcXVpcmVzIHNvbWUgZGVzaWduIHdvcmsgdG8gbG9vayBnb29kIGZvciB2YXJpb3VzIG51bWJlcnMgb2YgdG90YWwgYXhlcy5cbiAgICAgICAgZG9tYWluOiBbMSAtIChheGlzTnVtIC0gMSkgKiAwLjA1LCAxIC0gKGF4aXNOdW0gLSAyKSAqIDAuMDVdLFxuICAgICAgICB2aXNpYmxlOiBmYWxzZSxcbiAgICAgIH0sXG4gICAgfTtcbiAgfVxuXG4gIHByb3RlY3RlZCBnZXRNZXJnZWRDb25maWcgPSAoY29uZmlnOiBQYXJ0aWFsPFBsb3RseS5Db25maWc+ID0ge30pOiBQbG90bHkuQ29uZmlnID0+IHtcbiAgICBjb25zdCBjb3BpZWRDb25maWcgPSBJbW11dGFibGUuZnJvbUpTKHsgLi4uZGVmYXVsdFBsb3RseUNvbmZpZyB9KSBhcyBJbW11dGFibGUuTGlzdDxrZXlvZiBQbG90bHkuQ29uZmlnPjtcbiAgICBjb25zdCBpbW11dGFibGVDb25maWdGcm9tSnMgPSBJbW11dGFibGUuZnJvbUpTKHsgLi4uY29uZmlnIH0pIGFzIEltbXV0YWJsZS5MaXN0PGtleW9mIFBsb3RseS5Db25maWc+O1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLmNvcGllZENvbmZpZy5tZXJnZURlZXAoaW1tdXRhYmxlQ29uZmlnRnJvbUpzKS50b0pTKCksXG4gICAgfTtcbiAgfTtcblxuICBwcm90ZWN0ZWQgZ2V0TWVyZ2VkTGF5b3V0ID0gKFxuICAgIGxheW91dDogUGFydGlhbDxQbG90bHkuTGF5b3V0PiA9IHt9LFxuICAgIHBsb3RseUZvcm1hdHRlZERhdGE6IEFycmF5PFBhcnRpYWw8SVBsb3RseURhdGE+PiA9IFtdLFxuICApID0+IHtcbiAgICBjb25zdCBjb3BpZWRMYXlvdXQgPSBJbW11dGFibGUuZnJvbUpTKHsgLi4ubGF5b3V0IH0pIGFzIEltbXV0YWJsZS5MaXN0PGtleW9mIFBsb3RseS5MYXlvdXQ+O1xuICAgIGNvbnN0IGNvcGllZExheW91dEZyb21EYXRhID0gSW1tdXRhYmxlLmZyb21KUyh7XG4gICAgICAuLi5kZWZhdWx0UGxvdGx5TGF5b3V0LFxuICAgICAgLi4udGhpcy5kZXJpdmVBeGlzUGFyYW1zKHBsb3RseUZvcm1hdHRlZERhdGEpLFxuICAgIH0pIGFzIEltbXV0YWJsZS5MaXN0PGtleW9mIFBsb3RseS5MYXlvdXQ+O1xuXG4gICAgY29uc3QgcmVzdWx0OiBQYXJ0aWFsPFBsb3RseS5MYXlvdXQ+ID0ge1xuICAgICAgLi4uY29waWVkTGF5b3V0RnJvbURhdGEubWVyZ2VEZWVwKGNvcGllZExheW91dCkudG9KUygpLFxuICAgIH07XG5cbiAgICBpZiAodGhpcy5zYXZlZEF4aXNab29tICYmIHJlc3VsdC54YXhpcyAmJiByZXN1bHQueWF4aXMpIHtcbiAgICAgIHJlc3VsdC54YXhpcy5yYW5nZSA9IHRoaXMuc2F2ZWRBeGlzWm9vbS54YXhpcy5yYW5nZTtcbiAgICAgIHJlc3VsdC55YXhpcy5yYW5nZSA9IHRoaXMuc2F2ZWRBeGlzWm9vbS55YXhpcy5yYW5nZTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIC8qKlxuICAgKiBDcmVhdGUgWzAtbl0gcGxvdGx5IGF4ZXMgZ2l2ZW4gc29tZSBwbG90bHkgZGF0YS5cbiAgICpcbiAgICogQHBhcmFtIGFsbERhdGEgVGhlIGFscmVhZHkgZm9ybWF0dGVkIFBsb3RseSBkYXRhIC0gbWVhbmluZyBlYWNoIGRhdGEgc2hvdWxkIGhhdmUgdGhlIHByb3BlciBheGlzIGFscmVhZHkgYXNzaWduZWQuXG4gICAqIEByZXR1cm5zIEEgb2JqZWN0IGNvbnRhaW5pbmcgeGF4aXMgYW5kIHlheGlzIGZpZWxkcywgYXMgd2VsbCBhcyB4YXhpcyMgYW5kIHlheGlzIyBmaWVsZHMgd2hlcmUgIyBpcyBkZXJpdmVkIGZyb20gdGhlIGdpdmVuIGRhdGEuXG4gICAqL1xuICBwcm90ZWN0ZWQgZGVyaXZlQXhpc1BhcmFtcyhhbGxEYXRhOiBBcnJheTxQYXJ0aWFsPElQbG90bHlEYXRhPj4pOiBQYXJ0aWFsPElQbG90bHlMYXlvdXQ+IHtcbiAgICBjb25zdCB1bmlxdWVYQXhpc0lkcyA9IG5ldyBTZXQ8c3RyaW5nPigpO1xuICAgIGNvbnN0IHVuaXF1ZVlBeGlzSWRzID0gbmV3IFNldDxzdHJpbmc+KCk7XG5cbiAgICBmb3IgKGNvbnN0IGRhdGEgb2YgYWxsRGF0YSkge1xuICAgICAgY29uc3QgeyB4YXhpcywgeWF4aXMgfSA9IGRhdGE7XG4gICAgICBpZiAoeGF4aXMpIHtcbiAgICAgICAgdW5pcXVlWEF4aXNJZHMuYWRkKHhheGlzKTtcbiAgICAgIH1cbiAgICAgIGlmICh5YXhpcykge1xuICAgICAgICB1bmlxdWVZQXhpc0lkcy5hZGQoeWF4aXMpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFRPRE8gSGF2ZSB0aGUgc3BhY2luZyBudW1iZXIgLSAwLjA1IC0gYmUgY29uZmlndXJhYmxlLiBSZXF1aXJlcyBzb21lIGRlc2lnbiB3b3JrIHRvIGxvb2sgZ29vZCBmb3IgdmFyaW91cyBudW1iZXJzIG9mIHRvdGFsIGF4ZXMuXG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLnRoaXMuZ2VuZXJhdGVFeHRyYVBsb3RseUF4aXModW5pcXVlWEF4aXNJZHMpLFxuICAgICAgLi4udGhpcy5nZW5lcmF0ZUV4dHJhUGxvdGx5QXhpcyh1bmlxdWVZQXhpc0lkcyksXG4gICAgICB4YXhpczoge1xuICAgICAgICBkb21haW46IFswLCAxIC0gdW5pcXVlWEF4aXNJZHMuc2l6ZSAqIDAuMDVdLFxuICAgICAgICByYW5nZTogWzMwXSxcbiAgICAgICAgemVyb2xpbmU6IGZhbHNlLFxuICAgICAgfSxcbiAgICAgIHlheGlzOiB7XG4gICAgICAgIGRvbWFpbjogWzAsIDEgLSB1bmlxdWVYQXhpc0lkcy5zaXplICogMC4wNV0sXG4gICAgICAgIHJhbmdlOiBbMzBdLFxuICAgICAgICB6ZXJvbGluZTogZmFsc2UsXG4gICAgICB9LFxuICAgIH07XG4gIH1cblxuICBwcm90ZWN0ZWQgb25BZnRlclBsb3QgPSAoKSA9PiB7XG4gICAgY29uc3QgeyBvbkFmdGVyUGxvdENhbGxiYWNrIH0gPSB0aGlzLnByb3BzO1xuICAgIGlmIChvbkFmdGVyUGxvdENhbGxiYWNrKSB7XG4gICAgICBvbkFmdGVyUGxvdENhbGxiYWNrKG5ldyBDaGVsbENoYXJ0RXZlbnQoQ0hFTExfQ0hBUlRfRVZFTlRfVFlQRS5BRlRFUl9QTE9UKSk7XG4gICAgfVxuICB9O1xuXG4gIHByb3RlY3RlZCBvbkNsaWNrID0gKGV2ZW50OiBwbG90bHkuUGxvdE1vdXNlRXZlbnQpID0+IHtcbiAgICBjb25zdCBzaG91bGRIYW5kbGVDbGljayA9XG4gICAgICB0aGlzLmlzRG91YmxlQ2xpY2tJblByb2dyZXNzID09PSBmYWxzZSAmJiBldmVudC5wb2ludHMgIT09IHVuZGVmaW5lZCAmJiBldmVudC5wb2ludHMubGVuZ3RoID4gMDtcbiAgICBpZiAoc2hvdWxkSGFuZGxlQ2xpY2spIHtcbiAgICAgIGNvbnN0IHsgb25DbGlja0NhbGxiYWNrIH0gPSB0aGlzLnByb3BzO1xuICAgICAgaWYgKG9uQ2xpY2tDYWxsYmFjaykge1xuICAgICAgICBjb25zdCB4ID0gZXZlbnQucG9pbnRzWzBdLnggPyBldmVudC5wb2ludHNbMF0ueCA6IChldmVudC5wb2ludHNbMF0uZGF0YS54WzBdIGFzIG51bWJlcik7XG4gICAgICAgIGNvbnN0IHkgPSBldmVudC5wb2ludHNbMF0ueSA/IGV2ZW50LnBvaW50c1swXS55IDogKGV2ZW50LnBvaW50c1swXS5kYXRhLnlbMF0gYXMgbnVtYmVyKTtcbiAgICAgICAgY29uc3QgeyBjaGFydFBpZWNlLCBzZWxlY3RlZFBvaW50cyB9ID0gdGhpcy5kZXJpdmVDaGFydFBpZWNlKHgsIHksIGV2ZW50LnBvaW50c1swXS5kYXRhKTtcbiAgICAgICAgb25DbGlja0NhbGxiYWNrKG5ldyBDaGVsbENoYXJ0RXZlbnQoQ0hFTExfQ0hBUlRfRVZFTlRfVFlQRS5DTElDSywgY2hhcnRQaWVjZSwgc2VsZWN0ZWRQb2ludHMpKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgcHJvdGVjdGVkIG9uRG91YmxlQ2xpY2sgPSAoKSA9PiB7XG4gICAgdGhpcy5pc0RvdWJsZUNsaWNrSW5Qcm9ncmVzcyA9IHRydWU7XG4gICAgY29uc3QgeyBvbkRvdWJsZUNsaWNrQ2FsbGJhY2sgfSA9IHRoaXMucHJvcHM7XG4gICAgaWYgKG9uRG91YmxlQ2xpY2tDYWxsYmFjaykge1xuICAgICAgb25Eb3VibGVDbGlja0NhbGxiYWNrKG5ldyBDaGVsbENoYXJ0RXZlbnQoQ0hFTExfQ0hBUlRfRVZFTlRfVFlQRS5ET1VCTEVfQ0xJQ0spKTtcbiAgICB9XG4gIH07XG5cbiAgcHJvdGVjdGVkIG9uSG92ZXIgPSAoZXZlbnQ6IHBsb3RseS5QbG90TW91c2VFdmVudCkgPT4ge1xuICAgIGNvbnN0IHsgb25Ib3ZlckNhbGxiYWNrIH0gPSB0aGlzLnByb3BzO1xuICAgIGlmIChldmVudC5wb2ludHMgJiYgZXZlbnQucG9pbnRzWzBdICYmIG9uSG92ZXJDYWxsYmFjaykge1xuICAgICAgY29uc3QgeCA9IGV2ZW50LnBvaW50c1swXS54ID8gZXZlbnQucG9pbnRzWzBdLnggOiAoZXZlbnQucG9pbnRzWzBdLmRhdGEueFswXSBhcyBudW1iZXIpO1xuICAgICAgY29uc3QgeSA9IGV2ZW50LnBvaW50c1swXS55ID8gZXZlbnQucG9pbnRzWzBdLnkgOiAoZXZlbnQucG9pbnRzWzBdLmRhdGEueVswXSBhcyBudW1iZXIpO1xuICAgICAgY29uc3QgeyBjaGFydFBpZWNlLCBzZWxlY3RlZFBvaW50cyB9ID0gdGhpcy5kZXJpdmVDaGFydFBpZWNlKHgsIHksIGV2ZW50LnBvaW50c1swXS5kYXRhKTtcbiAgICAgIG9uSG92ZXJDYWxsYmFjayhuZXcgQ2hlbGxDaGFydEV2ZW50KENIRUxMX0NIQVJUX0VWRU5UX1RZUEUuSE9WRVIsIGNoYXJ0UGllY2UsIHNlbGVjdGVkUG9pbnRzKSk7XG4gICAgfVxuICB9O1xuXG4gIHByb3RlY3RlZCBvblJlbGF5b3V0ID0gKGV2ZW50OiBwbG90bHkuUGxvdFJlbGF5b3V0RXZlbnQgJiB7IFtrZXk6IHN0cmluZ106IG51bWJlciB9KSA9PiB7XG4gICAgdGhpcy5pc0RvdWJsZUNsaWNrSW5Qcm9ncmVzcyA9IGZhbHNlO1xuICAgIC8vICFJTVBPUlRBTlQhIFllcywgdGhlc2UgbnVtYmVycyBoYXZlIHRvIGJlIGFjY2Vzc2VkIGxpa2UgdGhpcywgc2VlOlxuICAgIC8vIGh0dHBzOi8vcGxvdC5seS9qYXZhc2NyaXB0L3Bsb3RseWpzLWZ1bmN0aW9uLXJlZmVyZW5jZS8jcGxvdGx5cmVzdHlsZVxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9wbG90bHkvcGxvdGx5LmpzL2lzc3Vlcy8yODQzXG4gICAgY29uc3QgYXhpc0tleXMgPSBbJ3hheGlzLnJhbmdlWzBdJywgJ3hheGlzLnJhbmdlWzFdJywgJ3lheGlzLnJhbmdlWzBdJywgJ3lheGlzLnJhbmdlWzFdJ107XG4gICAgY29uc3QgaXNFdmVudEZvcm1hdHRlZENvcnJlY3QgPVxuICAgICAgZXZlbnQgIT09IHVuZGVmaW5lZCAmJiBheGlzS2V5cy5yZWR1Y2UoKHByZXYsIGN1cikgPT4gcHJldiAmJiBldmVudFtjdXJdICE9PSB1bmRlZmluZWQsIHRydWUpID09PSB0cnVlO1xuICAgIHRoaXMuc2F2ZWRBeGlzWm9vbSA9IGlzRXZlbnRGb3JtYXR0ZWRDb3JyZWN0XG4gICAgICA/IHtcbiAgICAgICAgICB4YXhpczoge1xuICAgICAgICAgICAgYXV0b3JhbmdlOiBmYWxzZSxcbiAgICAgICAgICAgIHJhbmdlOiBbZXZlbnRbYXhpc0tleXNbMF1dLCBldmVudFtheGlzS2V5c1sxXV1dLFxuICAgICAgICAgIH0sXG4gICAgICAgICAgeWF4aXM6IHtcbiAgICAgICAgICAgIGF1dG9yYW5nZTogZmFsc2UsXG4gICAgICAgICAgICByYW5nZTogW2V2ZW50W2F4aXNLZXlzWzJdXSwgZXZlbnRbYXhpc0tleXNbM11dXSxcbiAgICAgICAgICB9LFxuICAgICAgICB9XG4gICAgICA6IHVuZGVmaW5lZDtcbiAgICBjb25zdCB7IG9uUmVsYXlvdXRDYWxsYmFjayB9ID0gdGhpcy5wcm9wcztcbiAgICBpZiAob25SZWxheW91dENhbGxiYWNrKSB7XG4gICAgICBvblJlbGF5b3V0Q2FsbGJhY2sobmV3IENoZWxsQ2hhcnRFdmVudChDSEVMTF9DSEFSVF9FVkVOVF9UWVBFLlJFTEFZT1VUKSk7XG4gICAgfVxuICB9O1xuXG4gIHByb3RlY3RlZCBvblNlbGVjdCA9IGFzeW5jIChldmVudDogcGxvdGx5LlBsb3RTZWxlY3Rpb25FdmVudCkgPT4ge1xuICAgIGNvbnN0IHsgb25TZWxlY3RlZENhbGxiYWNrIH0gPSB0aGlzLnByb3BzO1xuICAgIGlmIChldmVudCAmJiBvblNlbGVjdGVkQ2FsbGJhY2spIHtcbiAgICAgIGxldCBhbGxQb2ludHMgPSBuZXcgQXJyYXk8bnVtYmVyPigpO1xuICAgICAgaWYgKGV2ZW50LnBvaW50cy5sZW5ndGggPj0gMSkge1xuICAgICAgICBhbGxQb2ludHMgPSBldmVudC5wb2ludHMucmVkdWNlKChwcmV2LCBjdXIpID0+IHtcbiAgICAgICAgICBwcmV2LnB1c2goLi4uW2N1ci54IGFzIG51bWJlciwgY3VyLnkgYXMgbnVtYmVyXSk7XG5cbiAgICAgICAgICByZXR1cm4gcHJldjtcbiAgICAgICAgfSwgYWxsUG9pbnRzKTtcbiAgICAgIH0gZWxzZSBpZiAoZXZlbnQucmFuZ2UpIHtcbiAgICAgICAgLy8gSWYgaXQgaXMgYSByYW5nZSwgaXQgaXMgYSBib3ggYW5kIHNvIHRoZSBjb29yZGluYXRlcyBjYW4gYmUgZGlyZWN0bHkgYWNjZXNzZWQgbGlrZSBzby5cbiAgICAgICAgYWxsUG9pbnRzLnB1c2goZXZlbnQucmFuZ2UueFswXSwgZXZlbnQucmFuZ2UueVswXSwgZXZlbnQucmFuZ2UueFsxXSwgZXZlbnQucmFuZ2UueVsxXSk7XG4gICAgICB9XG4gICAgICBjb25zdCB7IGNoYXJ0UGllY2UgfSA9XG4gICAgICAgIGFsbFBvaW50cy5sZW5ndGggPiAwXG4gICAgICAgICAgPyB0aGlzLmRlcml2ZUNoYXJ0UGllY2UoYWxsUG9pbnRzWzBdLCBhbGxQb2ludHNbMV0pXG4gICAgICAgICAgOiB7IGNoYXJ0UGllY2U6IENIRUxMX0NIQVJUX1BJRUNFLlBPSU5UIH07XG4gICAgICBvblNlbGVjdGVkQ2FsbGJhY2sobmV3IENoZWxsQ2hhcnRFdmVudChDSEVMTF9DSEFSVF9FVkVOVF9UWVBFLlNFTEVDVElPTiwgY2hhcnRQaWVjZSwgYWxsUG9pbnRzLCBldmVudCkpO1xuICAgIH1cbiAgICBhd2FpdCB0aGlzLmRyYXcoKTtcbiAgfTtcblxuICBwcm90ZWN0ZWQgb25VbkhvdmVyID0gKGV2ZW50OiBwbG90bHkuUGxvdE1vdXNlRXZlbnQpID0+IHtcbiAgICBjb25zdCB7IG9uVW5Ib3ZlckNhbGxiYWNrIH0gPSB0aGlzLnByb3BzO1xuICAgIGlmIChldmVudCAmJiBvblVuSG92ZXJDYWxsYmFjaykge1xuICAgICAgY29uc3QgeyBkYXRhLCB4LCB5IH0gPSBldmVudC5wb2ludHNbMF07XG4gICAgICBjb25zdCB7IGNoYXJ0UGllY2UsIHNlbGVjdGVkUG9pbnRzIH0gPSB0aGlzLmRlcml2ZUNoYXJ0UGllY2UoeCwgeSwgZGF0YSk7XG4gICAgICBvblVuSG92ZXJDYWxsYmFjayhuZXcgQ2hlbGxDaGFydEV2ZW50KENIRUxMX0NIQVJUX0VWRU5UX1RZUEUuVU5IT1ZFUiwgY2hhcnRQaWVjZSwgc2VsZWN0ZWRQb2ludHMpKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIElzIHRoZSBkYXRhIHJlYWR5IHRvIGJlIHBsb3R0ZWQ/XG4gICAqL1xuICBwcml2YXRlIGlzRGF0YUxvYWRlZCgpIHtcbiAgICByZXR1cm4gKFxuICAgICAgdGhpcy5wcm9wcy5kYXRhLmxlbmd0aCA+IDAgfHxcbiAgICAgIHRoaXMucGxvdGx5Rm9ybWF0dGVkRGF0YS5maWx0ZXIoZGF0YVBvaW50ID0+IGRhdGFQb2ludC54ICYmIGRhdGFQb2ludC54Lmxlbmd0aCA+PSAxKS5sZW5ndGggPiAwXG4gICAgKTtcbiAgfVxufVxuIiwiLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm5vLXJlbGF0aXZlLWltcG9ydHNcbmltcG9ydCB7IEF1eGlsaWFyeUF4aXMgfSBmcm9tICcuLyc7XG5cbi8vIGltcG9ydCB7IEF1eGlsaWFyeUF4aXMgfSBmcm9tICd+Y2hlbGwtdml6fi9jb21wb25lbnQnOyAvLyBUT0RPIEZpeCB0aGUgY2lyY3VsYXIgZGVwZW5kZW5jeSB0aGlzIGNhdXNlcy5cblxuaW1wb3J0IHtcbiAgSVBsb3RseURhdGEsXG4gIFNFQ09OREFSWV9TVFJVQ1RVUkUsXG4gIFNFQ09OREFSWV9TVFJVQ1RVUkVfS0VZUyxcbiAgU0VDT05EQVJZX1NUUlVDVFVSRV9TRUNUSU9OLFxufSBmcm9tICd+Y2hlbGwtdml6fi9kYXRhJztcblxuLyoqXG4gKiBDbGFzcyB0byByZXByZXNlbnQgdGhlIHggYW5kIHkgYXhpcyBmb3IgYSBzZWNvbmRhcnkgc3RydWN0dXJlIG9uIGEgUGxvdGx5IGdyYXBoLlxuICpcbiAqIEBleHBvcnRcbiAqL1xuZXhwb3J0IGNsYXNzIFNlY29uZGFyeVN0cnVjdHVyZUF4aXMgZXh0ZW5kcyBBdXhpbGlhcnlBeGlzPFNFQ09OREFSWV9TVFJVQ1RVUkVfS0VZUz4ge1xuICBwcm90ZWN0ZWQgc3RhdGljIGNlbnRlclNlY3Rpb25Qb3NpdGlvbkZuID0gKHNlY3Rpb246IFNFQ09OREFSWV9TVFJVQ1RVUkVfU0VDVElPTiwgaW5kZXg6IG51bWJlcikgPT4gKHtcbiAgICBtYWluOiBpbmRleCxcbiAgICBvcHBvc2l0ZTogMCxcbiAgfSk7XG5cbiAgY29uc3RydWN0b3IoXG4gICAgcmVhZG9ubHkgc2VjdGlvbnM6IFNFQ09OREFSWV9TVFJVQ1RVUkUsXG4gICAgcmVhZG9ubHkgbWluaW11bVJlcXVpcmVkUmVzaWR1ZXM6IG51bWJlciA9IDMsXG4gICAgcmVhZG9ubHkgYXhpc0luZGV4OiBudW1iZXIgPSAyLFxuICAgIHJlYWRvbmx5IGRlZmF1bHRDb2xvciA9ICdibGFjaycsXG4gICAgcmVhZG9ubHkgY29sb3JNYXA6IHsgW2tleTogc3RyaW5nXTogc3RyaW5nIH0gPSB7XG4gICAgICBDOiAncmVkJyxcbiAgICAgIEU6ICdncmVlbicsXG4gICAgICBIOiAnYmx1ZScsXG4gICAgfSxcbiAgICByZWFkb25seSBkYXRhVHJhbnNmb3JtRm4gPSB7XG4gICAgICBDOiBTZWNvbmRhcnlTdHJ1Y3R1cmVBeGlzLmNlbnRlclNlY3Rpb25Qb3NpdGlvbkZuLFxuICAgICAgRTogU2Vjb25kYXJ5U3RydWN0dXJlQXhpcy5jZW50ZXJTZWN0aW9uUG9zaXRpb25GbixcbiAgICAgIEg6IChzZWN0aW9uOiBTRUNPTkRBUllfU1RSVUNUVVJFX1NFQ1RJT04sIGluZGV4OiBudW1iZXIpID0+ICh7XG4gICAgICAgIG1haW46IGluZGV4LFxuICAgICAgICBvcHBvc2l0ZTogTWF0aC5zaW4oaW5kZXgpLFxuICAgICAgfSksXG4gICAgfSxcbiAgICByZWFkb25seSBmaWx0ZXJGbiA9IChzZWN0aW9uOiBTRUNPTkRBUllfU1RSVUNUVVJFX1NFQ1RJT04pID0+IHNlY3Rpb24ubGVuZ3RoIDw9IG1pbmltdW1SZXF1aXJlZFJlc2lkdWVzLFxuICApIHtcbiAgICBzdXBlcihzZWN0aW9ucywgYXhpc0luZGV4LCBkZWZhdWx0Q29sb3IsIGNvbG9yTWFwLCBkYXRhVHJhbnNmb3JtRm4sIGZpbHRlckZuKTtcbiAgfVxuXG4gIHByb3RlY3RlZCBzZXR1cEF1eGlsaWFyeUF4aXMoKSB7XG4gICAgc3VwZXIuc2V0dXBBdXhpbGlhcnlBeGlzKCk7XG4gICAgY29uc3Qgc2hlZXRBeGlzID0gdGhpcy5nZXRBeGlzQnlJZCgnRScpO1xuICAgIGNvbnN0IEJMQU5LX0xJTkUgPSAnbGluZS1uZSc7XG4gICAgY29uc3QgVFJJQU5HTEVfUklHSFQgPSAndHJpYW5nbGUtcmlnaHQnO1xuICAgIGNvbnN0IFRSSUFOR0xFX0RPV04gPSAndHJpYW5nbGUtZG93bic7XG5cbiAgICBpZiAoc2hlZXRBeGlzICYmIHNoZWV0QXhpcy54LnggJiYgc2hlZXRBeGlzLngueSkge1xuICAgICAgY29uc3Qgc3ltYm9scyA9IHtcbiAgICAgICAgbWFpbjogbmV3IEFycmF5PHN0cmluZz4oc2hlZXRBeGlzLngueC5sZW5ndGgpLmZpbGwoQkxBTktfTElORSksXG4gICAgICAgIG9wcG9zaXRlOiBuZXcgQXJyYXk8c3RyaW5nPihzaGVldEF4aXMueC54Lmxlbmd0aCkuZmlsbChCTEFOS19MSU5FKSxcbiAgICAgIH07XG5cbiAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgc2hlZXRBeGlzLngueC5sZW5ndGggLSAxOyArK2kpIHtcbiAgICAgICAgaWYgKHNoZWV0QXhpcy54LnlbaSArIDFdID09PSBudWxsKSB7XG4gICAgICAgICAgc3ltYm9scy5tYWluW2ldID0gVFJJQU5HTEVfUklHSFQ7XG4gICAgICAgICAgc3ltYm9scy5vcHBvc2l0ZVtpXSA9IFRSSUFOR0xFX0RPV047XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgc2hlZXRBeGlzLnggPSB7XG4gICAgICAgIC4uLnNoZWV0QXhpcy54LFxuICAgICAgICAuLi50aGlzLmdlbmVyYXRlQmV0YVNoZWV0U3R5bGUoc2hlZXRBeGlzLngsIHN5bWJvbHMubWFpbiksXG4gICAgICB9O1xuXG4gICAgICBzaGVldEF4aXMueSA9IHtcbiAgICAgICAgLi4uc2hlZXRBeGlzLnksXG4gICAgICAgIC4uLnRoaXMuZ2VuZXJhdGVCZXRhU2hlZXRTdHlsZShzaGVldEF4aXMueSwgc3ltYm9scy5vcHBvc2l0ZSksXG4gICAgICB9O1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZSB0aGUgUGxvdGx5IGxheW91dCBzcGVjaWZpYyB0byBiZXRhIHNoZWV0IHJlcHJlc2VudGF0aW9uLlxuICAgKlxuICAgKiBAcGFyYW0gZGF0YSBEYXRhIGZvciB0aGlzIGF4aXMuXG4gICAqIEBwYXJhbSBzeW1ib2xzIFRoZSBzeW1ib2xzIHRoYXQgbWFrZSB1cCB0aGlzIGF4aXMuIFNob3VsZCBiZSBhbiBhcnJheSBvZiBlbXB0eSBsaW5lcyB3aXRoIGFuIGFycm93IGF0IHRoZSBlbmQuXG4gICAqIEByZXR1cm5zIFBsb3RseSBsYXlvdXQgc3BlY2lmaWMgdG8gYmV0YSBzaGVldCByZXByZXNlbnRhdGlvbi5cbiAgICovXG4gIHByb3RlY3RlZCBnZW5lcmF0ZUJldGFTaGVldFN0eWxlKGRhdGE6IFBhcnRpYWw8SVBsb3RseURhdGE+LCBzeW1ib2xzOiBzdHJpbmdbXSk6IFBhcnRpYWw8SVBsb3RseURhdGE+IHtcbiAgICByZXR1cm4ge1xuICAgICAgbGluZToge1xuICAgICAgICAuLi5kYXRhLmxpbmUsXG4gICAgICAgIHdpZHRoOiA1LFxuICAgICAgfSxcbiAgICAgIG1hcmtlcjoge1xuICAgICAgICAuLi5kYXRhLm1hcmtlcixcbiAgICAgICAgY29sb3I6IHRoaXMuY29sb3JNYXAuRSxcbiAgICAgICAgc2l6ZTogMTAsXG4gICAgICAgIHN5bWJvbDogc3ltYm9scyxcbiAgICAgIH0sXG4gICAgICBtb2RlOiAnbGluZXMrbWFya2VycycsXG4gICAgfTtcbiAgfVxufVxuIiwiZXhwb3J0ICogZnJvbSAnLi9QbG90bHlDaGFydCc7XG5leHBvcnQgKiBmcm9tICcuL0F1eGlsaWFyeUF4aXMnO1xuZXhwb3J0ICogZnJvbSAnLi9Db250YWN0TWFwQ2hhcnQnO1xuZXhwb3J0ICogZnJvbSAnLi9TZWNvbmRhcnlTdHJ1Y3R1cmVBeGlzJztcbiIsImV4cG9ydCAqIGZyb20gJy4vY2hhcnQnO1xuZXhwb3J0ICogZnJvbSAnLi93aWRnZXQnO1xuXG5leHBvcnQgKiBmcm9tICcuL0NvbnRhY3RNYXAnO1xuZXhwb3J0ICogZnJvbSAnLi9GZWF0dXJlVmlld2VyJztcbmV4cG9ydCAqIGZyb20gJy4vSW5mb1BhbmVsJztcbmV4cG9ydCAqIGZyb20gJy4vTkdMQ29tcG9uZW50JztcbmV4cG9ydCAqIGZyb20gJy4vUHJlZGljdGVkQ29udGFjdE1hcCc7XG5leHBvcnQgKiBmcm9tICcuL1RlbnNvclRDb21wb25lbnQnO1xuZXhwb3J0ICogZnJvbSAnLi9URnJhbWVDb21wb25lbnQnO1xuZXhwb3J0ICogZnJvbSAnLi9WaXpTZWxlY3RvclBhbmVsJztcbiIsImltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IERyb3Bkb3duIH0gZnJvbSAnc2VtYW50aWMtdWktcmVhY3QnO1xuXG5leHBvcnQgaW50ZXJmYWNlIElDYXRlZ29yeVNlbGVjdG9yUHJvcHMge1xuICAvKiogQ2F0ZWdvcmllcyB0byBzZWxlY3QgZnJvbS4gKi9cbiAgY2F0ZWdvcmllczogc3RyaW5nW107XG4gIC8qKiBDYWxsYmFjayBmb3Igd2hlbiBhIG5ldyBjYXRlZ29yeSBpcyBzZWxlY3RlZC4gKi9cbiAgb25DYXRlZ29yeUNoYW5nZT8oZXZlbnQ6IFJlYWN0LlN5bnRoZXRpY0V2ZW50PGFueT4sIGRhdGE6IG9iamVjdCk6IHZvaWQ7XG59XG5cbi8qKlxuICogQ2xhc3MgdG8gcmVwcmVzZW50IGEgZHJvcGRvd24uXG4gKlxuICogQGV4dGVuZHMge1JlYWN0LkNvbXBvbmVudDxJQ2F0ZWdvcnlTZWxlY3RvclByb3BzLCBhbnk+fVxuICovXG5leHBvcnQgY2xhc3MgQ2F0ZWdvcnlTZWxlY3RvciBleHRlbmRzIFJlYWN0LkNvbXBvbmVudDxJQ2F0ZWdvcnlTZWxlY3RvclByb3BzLCBhbnk+IHtcbiAgcHVibGljIHN0YXRpYyBkZWZhdWx0UHJvcHMgPSB7XG4gICAgY2F0ZWdvcmllczogW10sXG4gIH07XG5cbiAgY29uc3RydWN0b3IocHJvcHM6IElDYXRlZ29yeVNlbGVjdG9yUHJvcHMpIHtcbiAgICBzdXBlcihwcm9wcyk7XG4gIH1cblxuICBwdWJsaWMgcmVuZGVyKCkge1xuICAgIHJldHVybiAoXG4gICAgICB0aGlzLnByb3BzLmNhdGVnb3JpZXMgJiYgKFxuICAgICAgICA8RHJvcGRvd25cbiAgICAgICAgICBmbHVpZD17dHJ1ZX1cbiAgICAgICAgICBvbkNoYW5nZT17dGhpcy5wcm9wcy5vbkNhdGVnb3J5Q2hhbmdlfVxuICAgICAgICAgIG9wdGlvbnM9e1tcbiAgICAgICAgICAgIC4uLnRoaXMucHJvcHMuY2F0ZWdvcmllcy5tYXAoY2F0ID0+IHtcbiAgICAgICAgICAgICAgcmV0dXJuIHsga2V5OiBjYXQsIHRleHQ6IGNhdCwgdmFsdWU6IGNhdCB9O1xuICAgICAgICAgICAgfSksXG4gICAgICAgICAgXX1cbiAgICAgICAgICBwbGFjZWhvbGRlcj17J1NlbGVjdCBDYXRlZ29yeSd9XG4gICAgICAgICAgc2VhcmNoPXt0cnVlfVxuICAgICAgICAvPlxuICAgICAgKVxuICAgICk7XG4gIH1cbn1cbiIsImltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IENoZWNrYm94UHJvcHMsIEZvcm0sIEdyaWQgfSBmcm9tICdzZW1hbnRpYy11aS1yZWFjdCc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgSUNoZWxsUmFkaW9Hcm91cFByb3BzIHtcbiAgZGlzYWJsZWQ6IGJvb2xlYW47XG4gIGlkOiBzdHJpbmc7XG4gIG9wdGlvbnM6IHN0cmluZ1tdO1xuICBzdHlsZTogUmVhY3QuQ1NTUHJvcGVydGllcztcbiAgdGl0bGU6IHN0cmluZztcbiAgb25DaGFuZ2U/KHZhbHVlOiBhbnkpOiB2b2lkO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIElDaGVsbFJhZGlvR3JvdXBTdGF0ZSB7XG4gIHNlbGVjdGVkSW5kZXg6IG51bWJlcjtcbn1cblxuZXhwb3J0IGNsYXNzIENoZWxsUmFkaW9Hcm91cCBleHRlbmRzIFJlYWN0LkNvbXBvbmVudDxJQ2hlbGxSYWRpb0dyb3VwUHJvcHMsIElDaGVsbFJhZGlvR3JvdXBTdGF0ZT4ge1xuICBwdWJsaWMgc3RhdGljIGRlZmF1bHRQcm9wcyA9IHtcbiAgICBkaXNhYmxlZDogZmFsc2UsXG4gICAgc3R5bGU6IHt9LFxuICAgIHRpdGxlOiAnSG93IHRvIGNhbGN1bGF0ZSBkaXN0YW5jZSBiZXR3ZWVuIHR3byByZXNpZHVlczonLFxuICB9O1xuXG4gIGNvbnN0cnVjdG9yKHByb3BzOiBJQ2hlbGxSYWRpb0dyb3VwUHJvcHMpIHtcbiAgICBzdXBlcihwcm9wcyk7XG4gICAgdGhpcy5zdGF0ZSA9IHtcbiAgICAgIHNlbGVjdGVkSW5kZXg6IDAsXG4gICAgfTtcbiAgfVxuXG4gIHB1YmxpYyBoYW5kbGVDaGFuZ2UgPSAoaW5kZXg6IG51bWJlcikgPT4gKGV2ZW50OiBSZWFjdC5Gb3JtRXZlbnQ8SFRNTElucHV0RWxlbWVudD4sIGRhdGE6IENoZWNrYm94UHJvcHMpID0+IHtcbiAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgIHNlbGVjdGVkSW5kZXg6IGluZGV4LFxuICAgIH0pO1xuXG4gICAgaWYgKHRoaXMucHJvcHMub25DaGFuZ2UpIHtcbiAgICAgIHRoaXMucHJvcHMub25DaGFuZ2UoaW5kZXgpO1xuICAgIH1cbiAgfTtcblxuICBwdWJsaWMgcmVuZGVyKCkge1xuICAgIGNvbnN0IHsgZGlzYWJsZWQsIGlkLCBvcHRpb25zLCBzdHlsZSwgdGl0bGUgfSA9IHRoaXMucHJvcHM7XG5cbiAgICByZXR1cm4gKFxuICAgICAgPEZvcm0gc3R5bGU9e3N0eWxlfT5cbiAgICAgICAgPEZvcm0uRmllbGQ+e3RpdGxlfTwvRm9ybS5GaWVsZD5cbiAgICAgICAge3RoaXMucmVuZGVyT3B0aW9ucyhpZCwgb3B0aW9ucywgZGlzYWJsZWQsIHN0eWxlKX1cbiAgICAgIDwvRm9ybT5cbiAgICApO1xuICB9XG5cbiAgcHJvdGVjdGVkIHJlbmRlck9wdGlvbnMgPSAoaWQ6IHN0cmluZywgb3B0aW9uczogc3RyaW5nW10sIGRpc2FibGVkOiBib29sZWFuLCBzdHlsZTogUmVhY3QuQ1NTUHJvcGVydGllcykgPT4gKFxuICAgIDxHcmlkIGNlbnRlcmVkPXt0cnVlfSBjb2x1bW5zPXsyfSByZWxheGVkPXt0cnVlfSBwYWRkZWQ9e3RydWV9PlxuICAgICAge29wdGlvbnMubWFwKChvcHRpb24sIGluZGV4KSA9PiAoXG4gICAgICAgIDxHcmlkLkNvbHVtbiBrZXk9e2Ake2lkfS0ke29wdGlvbn1gfSB0ZXh0QWxpZ249eydjZW50ZXInfT5cbiAgICAgICAgICA8Rm9ybS5SYWRpb1xuICAgICAgICAgICAgY2hlY2tlZD17dGhpcy5zdGF0ZS5zZWxlY3RlZEluZGV4ID09PSBpbmRleH1cbiAgICAgICAgICAgIGRpc2FibGVkPXtkaXNhYmxlZH1cbiAgICAgICAgICAgIGxhYmVsPXt7IGNoaWxkcmVuOiBvcHRpb24sIHN0eWxlIH19XG4gICAgICAgICAgICBuYW1lPXtvcHRpb259XG4gICAgICAgICAgICBvbkNoYW5nZT17dGhpcy5oYW5kbGVDaGFuZ2UoaW5kZXgpfVxuICAgICAgICAgICAgdmFsdWU9e2luZGV4fVxuICAgICAgICAgIC8+XG4gICAgICAgIDwvR3JpZC5Db2x1bW4+XG4gICAgICApKX1cbiAgICA8L0dyaWQ+XG4gICk7XG59XG4iLCIvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6aW1wb3J0LW5hbWVcbmltcG9ydCBTbGlkZXIsIHsgU2xpZGVyUHJvcHMgfSBmcm9tICdyYy1zbGlkZXInO1xuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xuXG4vLyBodHRwczovL2dpdGh1Yi5jb20vcmVhY3QtY29tcG9uZW50L3NsaWRlci8gcmVxdWlyZXMgdGhlIGNzcyBpbXBvcnRlZCBsaWtlIHRoaXMuXG4vLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bm8tc3VibW9kdWxlLWltcG9ydHMgbm8taW1wb3J0LXNpZGUtZWZmZWN0XG5pbXBvcnQgJ3JjLXNsaWRlci9hc3NldHMvaW5kZXguY3NzJztcbmltcG9ydCB7IEJ1dHRvbiwgR3JpZCB9IGZyb20gJ3NlbWFudGljLXVpLXJlYWN0JztcblxuLyoqIEZ1bmN0aW9uIHNpZ25hdHVyZSB0aGF0IGlzIGludm9rZWQgb24gc2xpZGVyIGV2ZW50cy4gKi9cbmV4cG9ydCB0eXBlIENoZWxsU2xpZGVyQ2FsbGJhY2sgPVxuICAvKipcbiAgICogQHBhcmFtIHZhbHVlIE5ldyB2YWx1ZSB0aGUgc2xpZGVyIGlzIGN1cnJlbnRseSBvbiB0b3Agb2YuXG4gICAqL1xuICAodmFsdWU6IG51bWJlcikgPT4gdm9pZDtcblxuLyoqXG4gKiBQcm9wZXJ0aWVzIHRoYXQgQ2hlbGxTbGlkZXIgYWNjZXB0cy5cbiAqXG4gKiBAZXhwb3J0XG4gKi9cbmV4cG9ydCB0eXBlIENoZWxsU2xpZGVyUHJvcHMgPSB7XG4gIC8qKiBWYWx1ZSB0aGUgc2xpZGVyIGlzIHNldCB0by4gKi9cbiAgdmFsdWU6IG51bWJlcjtcblxuICAvLyBUT0RPIFNwbGl0IHVwIGxhYmVsIGFuZCB2YWx1ZSwgaGF2ZSBib3RoIGJlIGluZGVwZW5kZW50bHkgdmlzaWJsZSBvciBub3QuXG4gIC8qKiBTaG91bGQgd2Ugc2hvdyB0aGUgbGFiZWwvdmFsdWUgZm9yIHRoZSBzbGlkZXI/ICovXG4gIGhpZGVMYWJlbFZhbHVlPzogYm9vbGVhbjtcblxuICAvKiogSW5pdGlhbCB2YWx1ZSB0aGUgc2xpZGVyIGlzIHNldCB0by4gKi9cbiAgbGFiZWw6IHN0cmluZztcblxuICAvKiogTWF4aW11bSB2YWx1ZSBmb3Igc2xpZGVyLiAqL1xuICBtYXg6IG51bWJlcjtcblxuICAvKiogTWluaW11bSB2YWx1ZSBmb3Igc2xpZGVyLiAqL1xuICBtaW46IG51bWJlcjtcblxuICAvKiogSW52b2tlZCB3aGVuIHRoZSB2YWx1ZSBoYXMgZmluaXNoZWQgY2hhbmdpbmcgdGhlIHNsaWRlciB2YWx1ZSAtIHVzdWFsbHkgYnkgcmVsZWFzaW5nIHRoZSBtb3VzZS4gKi9cbiAgb25BZnRlckNoYW5nZT86IENoZWxsU2xpZGVyQ2FsbGJhY2s7XG5cbiAgLyoqIEludm9rZWQgd2hlbiB0aGUgdmFsdWUgaXMgaW4gdGhlIG1pZGRsZSBvZiBjaGFuZ2luZyBidXQgdXNlciBoYXMgbm90IGNvbW1pdHRlZCB0byB0aGUgY2hhbmdlLiAqL1xuICBvbkNoYW5nZT86IENoZWxsU2xpZGVyQ2FsbGJhY2s7XG5cbiAgLyoqIFN0eWxlIGZvciB0aGUgc2xpZGVyLiAqL1xuICBzdHlsZT86IFJlYWN0LkNTU1Byb3BlcnRpZXM7XG59ICYgUGFydGlhbDxPbWl0PFNsaWRlclByb3BzLCAnc3R5bGUnPj47IC8vIElnbm9yZSB0aGUgc3R5bGUgcHJvcCBmcm9tIHRoZSBSZWFjdCBzbGlkZXIgc28gd2UgY2FuIGJldHRlciBjb250cm9sIGl0LlxuXG4vKipcbiAqIFN0YXRlIG9mIHRoZSBDaGVsbCBTbGlkZXIuXG4gKlxuICogQGV4cG9ydFxuICovXG5leHBvcnQgaW50ZXJmYWNlIElDaGVsbFNsaWRlclN0YXRlIHtcbiAgLyoqIEluaXRpYWwgdmFsdWUgdGhlIHNsaWRlciBzaG91bGQgYmUgcmVzZXQgdG8uICovXG4gIGRlZmF1bHRWYWx1ZTogbnVtYmVyO1xuXG4gIC8qKiBWYWx1ZSB0aGUgc2xpZGVyIGlzIGN1cnJlbnRseSBzZXQgdG8uICovXG4gIHZhbHVlOiBudW1iZXI7XG59XG5cbi8qKlxuICogUmVwcmVzZW50cyBhIHNpbXBsZSAyZCBzbGlkZXIsIGFsbG93aW5nIGEgdmFsdWUgdG8gYmUgc2VsZWN0ZWQgYmV0d2VlbiBhIG1pbmltdW0gYW5kIG1heGltdW0uXG4gKlxuICogQGV4cG9ydFxuICogQGV4dGVuZHMge1JlYWN0LkNvbXBvbmVudDxDaGVsbFNsaWRlclByb3BzLCBJQ2hlbGxTbGlkZXJTdGF0ZT59XG4gKi9cbmV4cG9ydCBjbGFzcyBDaGVsbFNsaWRlciBleHRlbmRzIFJlYWN0LkNvbXBvbmVudDxDaGVsbFNsaWRlclByb3BzLCBJQ2hlbGxTbGlkZXJTdGF0ZT4ge1xuICBjb25zdHJ1Y3Rvcihwcm9wczogQ2hlbGxTbGlkZXJQcm9wcykge1xuICAgIHN1cGVyKHByb3BzKTtcbiAgICB0aGlzLnN0YXRlID0ge1xuICAgICAgZGVmYXVsdFZhbHVlOiBwcm9wcy5kZWZhdWx0VmFsdWUgPyBwcm9wcy5kZWZhdWx0VmFsdWUgOiBwcm9wcy52YWx1ZSxcbiAgICAgIHZhbHVlOiBwcm9wcy52YWx1ZSxcbiAgICB9O1xuICB9XG5cbiAgcHVibGljIGNvbXBvbmVudERpZFVwZGF0ZShwcmV2UHJvcHM6IENoZWxsU2xpZGVyUHJvcHMpIHtcbiAgICBjb25zdCB7IGRlZmF1bHRWYWx1ZSwgdmFsdWUgfSA9IHRoaXMucHJvcHM7XG4gICAgaWYgKHZhbHVlICYmIHZhbHVlICE9PSBwcmV2UHJvcHMudmFsdWUpIHtcbiAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICB2YWx1ZSxcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGNvbnN0IGNhbmRpZGF0ZURlZmF1bHRWYWx1ZSA9IGRlZmF1bHRWYWx1ZSA/IGRlZmF1bHRWYWx1ZSA6IHZhbHVlO1xuICAgIGlmICh0aGlzLnN0YXRlLmRlZmF1bHRWYWx1ZSA9PT0gLTEgJiYgY2FuZGlkYXRlRGVmYXVsdFZhbHVlICE9PSB0aGlzLnN0YXRlLmRlZmF1bHRWYWx1ZSkge1xuICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgIGRlZmF1bHRWYWx1ZTogY2FuZGlkYXRlRGVmYXVsdFZhbHVlLFxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgcHVibGljIHJlbmRlcigpIHtcbiAgICBjb25zdCB7XG4gICAgICBjbGFzc05hbWUsXG4gICAgICB2YWx1ZSxcbiAgICAgIGhpZGVMYWJlbFZhbHVlLFxuICAgICAgbWF4LFxuICAgICAgbWluLFxuICAgICAgbGFiZWwsXG4gICAgICBvbkFmdGVyQ2hhbmdlLFxuICAgICAgb25DaGFuZ2UsXG4gICAgICBzdHlsZSxcbiAgICAgIC4uLnJlbWFpbmluZ1Byb3BzXG4gICAgfSA9IHRoaXMucHJvcHM7XG5cbiAgICByZXR1cm4gKFxuICAgICAgPEdyaWQgY29sdW1ucz17J2VxdWFsJ30gc3R5bGU9e3N0eWxlfSB0ZXh0QWxpZ249eydsZWZ0J30+XG4gICAgICAgIDxHcmlkLkNvbHVtbiBjbGFzc05hbWU9e2NsYXNzTmFtZX0+XG4gICAgICAgICAgeyFoaWRlTGFiZWxWYWx1ZSAmJiA8cD57YCR7bGFiZWx9OiAke3RoaXMuc3RhdGUudmFsdWV9YH08L3A+fVxuICAgICAgICAgIDxTbGlkZXJcbiAgICAgICAgICAgIG1heD17bWF4fVxuICAgICAgICAgICAgbWluPXttaW59XG4gICAgICAgICAgICBvbkFmdGVyQ2hhbmdlPXt0aGlzLm9uQWZ0ZXJDaGFuZ2Uob25BZnRlckNoYW5nZSl9XG4gICAgICAgICAgICBvbkNoYW5nZT17dGhpcy5vbkNoYW5nZShvbkNoYW5nZSl9XG4gICAgICAgICAgICB2YWx1ZT17dmFsdWV9XG4gICAgICAgICAgICB7Li4ucmVtYWluaW5nUHJvcHN9XG4gICAgICAgICAgLz5cbiAgICAgICAgPC9HcmlkLkNvbHVtbj5cbiAgICAgICAgPEdyaWQuQ29sdW1uIHZlcnRpY2FsQWxpZ249eydtaWRkbGUnfSB3aWR0aD17Mn0+XG4gICAgICAgICAgPEJ1dHRvbiBpY29uPXsndW5kbyd9IG9uQ2xpY2s9e3RoaXMub25SZXNldH0gc2l6ZT17J3NtYWxsJ30gLz5cbiAgICAgICAgPC9HcmlkLkNvbHVtbj5cbiAgICAgIDwvR3JpZD5cbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIFVwZGF0ZXMgdGhlIHN0YXRlIG9mIHRoZSBzbGlkZXIgYWZ0ZXIgdXNlciBjb21taXRzIHRvIGNoYW5nZS4gSWYgYXBwbGljYWJsZSwgaW52b2tlcyBhcHByb3ByaWF0ZSBjYWxsYmFjay5cbiAgICovXG4gIHByb3RlY3RlZCBvbkFmdGVyQ2hhbmdlID0gKGNiPzogQ2hlbGxTbGlkZXJDYWxsYmFjaykgPT4gKHZhbHVlOiBudW1iZXIpID0+IHtcbiAgICBpZiAoY2IpIHtcbiAgICAgIGNiKHZhbHVlKTtcbiAgICB9XG4gICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICB2YWx1ZSxcbiAgICB9KTtcbiAgfTtcblxuICAvKipcbiAgICogVXBkYXRlcyB0aGUgc3RhdGUgb2YgdGhlIHNsaWRlciBhcyB0aGUgdXNlciBtb3ZlcyB0aGUgc2xpZGVyIGFyb3VuZCBidXQgYmVmb3JlIHNlbGVjdGlvbiBpcyBjb21taXR0ZWQuXG4gICAqIElmIGFwcGxpY2FibGUsIGludm9rZXMgYXBwcm9wcmlhdGUgY2FsbGJhY2sgYXMgd2VsbC5cbiAgICovXG4gIHByb3RlY3RlZCBvbkNoYW5nZSA9IChjYj86IENoZWxsU2xpZGVyQ2FsbGJhY2spID0+ICh2YWx1ZTogbnVtYmVyKSA9PiB7XG4gICAgaWYgKGNiKSB7XG4gICAgICBjYih2YWx1ZSk7XG4gICAgfVxuICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgdmFsdWUsXG4gICAgfSk7XG4gIH07XG5cbiAgcHJvdGVjdGVkIG9uUmVzZXQgPSAoKSA9PiB7XG4gICAgdGhpcy5vbkNoYW5nZSh0aGlzLnByb3BzLm9uQ2hhbmdlKSh0aGlzLnN0YXRlLmRlZmF1bHRWYWx1ZSk7XG4gICAgLy8gdGhpcy5vbkFmdGVyQ2hhbmdlKHRoaXMucHJvcHMub25BZnRlckNoYW5nZSkodGhpcy5zdGF0ZS5kZWZhdWx0VmFsdWUpO1xuICB9O1xufVxuIiwiaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xuXG5leHBvcnQgaW50ZXJmYWNlIElDaGVsbFRvb2x0aXBQcm9wcyB7XG4gIHN0eWxlPzogUmVhY3QuQ1NTUHJvcGVydGllcztcbiAgbWVzc2FnZTogc3RyaW5nO1xuICB0aW1lb3V0PzogbnVtYmVyO1xufVxuXG5jb25zdCBkZWZhdWx0U3R5bGU6IFJlYWN0LkNTU1Byb3BlcnRpZXMgPSB7XG4gIGJhY2tncm91bmRDb2xvcjogJ3JnYmEoMCwgMjQ0LCAwLCAwLjYpJyxcbiAgY29sb3I6ICdsaWdodGdyZXknLFxuICBkaXNwbGF5OiAnYmxvY2snLFxuICBmb250RmFtaWx5OiAnc2Fucy1zZXJpZicsXG4gIHBhZGRpbmc6ICcwLjVlbScsXG4gIHBvaW50ZXJFdmVudHM6ICdub25lJyxcbiAgcG9zaXRpb246ICdhYnNvbHV0ZScsXG4gIHpJbmRleDogMTAsXG59O1xuXG5leHBvcnQgY29uc3QgaW5pdGlhbFRvb2x0aXBTdGF0ZSA9IHtcbiAgc2hvdzogdHJ1ZSxcbiAgdGltZXI6IHVuZGVmaW5lZCBhcyB1bmRlZmluZWQgfCBOb2RlSlMuVGltZXIgfCBudW1iZXIsXG59O1xuXG5leHBvcnQgdHlwZSBDaGVsbFRvb2x0aXBTdGF0ZSA9IFJlYWRvbmx5PHR5cGVvZiBpbml0aWFsVG9vbHRpcFN0YXRlPjtcblxuZXhwb3J0IGNsYXNzIENoZWxsVG9vbHRpcCBleHRlbmRzIFJlYWN0LkNvbXBvbmVudDxJQ2hlbGxUb29sdGlwUHJvcHMsIENoZWxsVG9vbHRpcFN0YXRlPiB7XG4gIHB1YmxpYyByZWFkb25seSBzdGF0ZTogQ2hlbGxUb29sdGlwU3RhdGUgPSBpbml0aWFsVG9vbHRpcFN0YXRlO1xuXG4gIGNvbnN0cnVjdG9yKHByb3BzOiBJQ2hlbGxUb29sdGlwUHJvcHMpIHtcbiAgICBzdXBlcihwcm9wcyk7XG4gIH1cblxuICBwdWJsaWMgY29tcG9uZW50RGlkVXBkYXRlKG5leHRQcm9wczogSUNoZWxsVG9vbHRpcFByb3BzKSB7XG4gICAgY29uc3QgeyB0aW1lb3V0ID0gMCB9ID0gbmV4dFByb3BzO1xuICAgIGlmICghdGhpcy5zdGF0ZS50aW1lciAmJiB0aW1lb3V0ID4gMCkge1xuICAgICAgY29uc3QgdGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgdGhpcy5zZXRTdGF0ZSh7IHNob3c6IGZhbHNlIH0pO1xuICAgICAgfSwgdGltZW91dCk7XG4gICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgdGltZXIsXG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICBwdWJsaWMgY29tcG9uZW50V2lsbFVubW91bnQoKSB7XG4gICAgY29uc3QgeyB0aW1lciB9ID0gdGhpcy5zdGF0ZTtcbiAgICBpZiAodGltZXIpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aW1lciBhcyBudW1iZXIpO1xuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyByZW5kZXIoKSB7XG4gICAgY29uc3QgeyBtZXNzYWdlLCBzdHlsZSA9IGRlZmF1bHRTdHlsZSB9ID0gdGhpcy5wcm9wcztcbiAgICBjb25zdCB7IHNob3cgfSA9IHRoaXMuc3RhdGU7XG5cbiAgICByZXR1cm4gKFxuICAgICAgc2hvdyAmJiAoXG4gICAgICAgIDxkaXYgc3R5bGU9e3N0eWxlfSBjbGFzc05hbWU9XCJDaGVsbFRvb2x0aXBcIj5cbiAgICAgICAgICB7bWVzc2FnZX1cbiAgICAgICAgPC9kaXY+XG4gICAgICApXG4gICAgKTtcbiAgfVxufVxuIiwiaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0ICogYXMgUmVhY3RET00gZnJvbSAncmVhY3QtZG9tJztcbmltcG9ydCB7IENhcmQsIEljb24sIE1lbnUgfSBmcm9tICdzZW1hbnRpYy11aS1yZWFjdCc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgSUNvbXBvbmVudENhcmRQcm9wcyB7XG4gIGNvbXBvbmVudE5hbWU6IHN0cmluZztcbiAgZnJhbWVIZWlnaHQ6IG51bWJlcjtcbiAgZnJhbWVXaWR0aDogbnVtYmVyO1xuICBoZWFkZXJIZWlnaHQ6IG51bWJlcjtcbiAgaGVpZ2h0OiBudW1iZXIgfCBzdHJpbmc7XG4gIGljb25TcmM6IHN0cmluZztcbiAgaXNGcmFtZWRDb21wb25lbnQ6IGJvb2xlYW47XG4gIGlzRnVsbFBhZ2U6IGJvb2xlYW47XG4gIHBhZGRpbmc6IG51bWJlciB8IHN0cmluZztcbiAgc2hvd1NldHRpbmdzOiBib29sZWFuO1xuICB3aWR0aDogbnVtYmVyIHwgc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIElDb21wb25lbnRDYXJkU3RhdGUge1xuICBmcmFtZWRTdHlsZTogUmVhY3QuQ1NTUHJvcGVydGllcztcbiAgaXNGdWxsUGFnZTogYm9vbGVhbjtcbn1cblxuZXhwb3J0IGNsYXNzIENvbXBvbmVudENhcmQgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQ8SUNvbXBvbmVudENhcmRQcm9wcywgSUNvbXBvbmVudENhcmRTdGF0ZT4ge1xuICBwdWJsaWMgc3RhdGljIGRlZmF1bHRQcm9wcyA9IHtcbiAgICBmcmFtZUhlaWdodDogMCxcbiAgICBmcmFtZVdpZHRoOiAwLFxuICAgIGhlYWRlckhlaWdodDogMzIsXG4gICAgaGVpZ2h0OiAnNTI1cHgnLFxuICAgIGljb25TcmM6ICdhc3NldHMvaWNvbnMvc3ByaW5nLWljb24ucG5nJyxcbiAgICBpc0ZyYW1lZENvbXBvbmVudDogZmFsc2UsXG4gICAgaXNGdWxsUGFnZTogZmFsc2UsXG4gICAgcGFkZGluZzogMCxcbiAgICBzaG93U2V0dGluZ3M6IGZhbHNlLFxuICAgIHdpZHRoOiAnNTI1cHgnLFxuICB9O1xuXG4gIHByb3RlY3RlZCBjYXJkUmVmOiBSZWFjdC5Db21wb25lbnQ8YW55PiB8IG51bGwgPSBudWxsO1xuXG4gIGNvbnN0cnVjdG9yKHByb3BzOiBJQ29tcG9uZW50Q2FyZFByb3BzKSB7XG4gICAgc3VwZXIocHJvcHMpO1xuICAgIHRoaXMuc3RhdGUgPSB7XG4gICAgICBmcmFtZWRTdHlsZToge1xuICAgICAgICB0cmFuc2Zvcm1PcmlnaW46ICd0b3AgbGVmdCcsXG4gICAgICB9LFxuICAgICAgaXNGdWxsUGFnZTogcHJvcHMuaXNGdWxsUGFnZSxcbiAgICB9O1xuICB9XG5cbiAgcHVibGljIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgIGlmICh0aGlzLnByb3BzLmlzRnJhbWVkQ29tcG9uZW50KSB7XG4gICAgICB3aW5kb3cub25yZXNpemUgPSAoKSA9PiB7XG4gICAgICAgIGlmICh0aGlzLnByb3BzLmlzRnJhbWVkQ29tcG9uZW50KSB7XG4gICAgICAgICAgdGhpcy5yZXNpemVGcmFtZWRDb21wb25lbnQoKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIHRoaXMucmVzaXplRnJhbWVkQ29tcG9uZW50KCk7XG4gICAgfVxuICB9XG5cbiAgcHVibGljIGNvbXBvbmVudERpZFVwZGF0ZShwcmV2UHJvcHM6IElDb21wb25lbnRDYXJkUHJvcHMsIHByZXZTdGF0ZTogSUNvbXBvbmVudENhcmRTdGF0ZSkge1xuICAgIGNvbnN0IHsgaXNGdWxsUGFnZSB9ID0gdGhpcy5zdGF0ZTtcbiAgICBpZiAoaXNGdWxsUGFnZSAhPT0gcHJldlN0YXRlLmlzRnVsbFBhZ2UpIHtcbiAgICAgIHRoaXMucmVzaXplRnJhbWVkQ29tcG9uZW50KCk7XG4gICAgfVxuICB9XG5cbiAgcHVibGljIHJlbmRlcigpIHtcbiAgICBjb25zdCB7IGNoaWxkcmVuLCBoZWFkZXJIZWlnaHQsIGhlaWdodCwgaXNGcmFtZWRDb21wb25lbnQsIHdpZHRoIH0gPSB0aGlzLnByb3BzO1xuICAgIGNvbnN0IHsgaXNGdWxsUGFnZSwgZnJhbWVkU3R5bGUgfSA9IHRoaXMuc3RhdGU7XG5cbiAgICBjb25zdCBleHBhbmRlZFN0eWxlOiBSZWFjdC5DU1NQcm9wZXJ0aWVzID0ge1xuICAgICAgYm90dG9tOiAwLFxuICAgICAgaGVpZ2h0OiAnY2FsYygxMDB2bWluKScsXG4gICAgICBsZWZ0OiAwLFxuICAgICAgcGFkZGluZzogJzVweCcsXG4gICAgICBwb3NpdGlvbjogJ2ZpeGVkJyxcbiAgICAgIHJpZ2h0OiAwLFxuICAgICAgd2lkdGg6ICdjYWxjKDEwMHZtaW4pJyxcbiAgICAgIHpJbmRleDogMTAwMDAsXG4gICAgfTtcblxuICAgIGNvbnN0IGNhcmRTdHlsZTogUmVhY3QuQ1NTUHJvcGVydGllcyA9IHtcbiAgICAgIG1heFdpZHRoOiAndW5zZXQnLFxuICAgICAgcGFkZGluZzogJzAgMCA1cHggNXB4JyxcbiAgICAgIC4uLihpc0Z1bGxQYWdlID8geyAuLi5leHBhbmRlZFN0eWxlIH0gOiB7IGhlaWdodCwgd2lkdGggfSksXG4gICAgfTtcblxuICAgIGNvbnN0IGRpbW1lZEJhY2tncm91bmQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnY2hlbGwtZGltbWVkLWJhY2tncm91bmQnKTtcbiAgICBpZiAoaXNGdWxsUGFnZSAmJiBkaW1tZWRCYWNrZ3JvdW5kKSB7XG4gICAgICBkaW1tZWRCYWNrZ3JvdW5kLnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO1xuICAgIH0gZWxzZSBpZiAoZGltbWVkQmFja2dyb3VuZCkge1xuICAgICAgZGltbWVkQmFja2dyb3VuZC5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgIH1cblxuICAgIHJldHVybiAoXG4gICAgICA8Q2FyZCBjZW50ZXJlZD17dHJ1ZX0gY2xhc3NOYW1lPXsnY2hlbGwtY29tcG9uZW50LWNhcmQnfSByZWY9e3JlZiA9PiAodGhpcy5jYXJkUmVmID0gcmVmKX0gc3R5bGU9e2NhcmRTdHlsZX0+XG4gICAgICAgIHt0aGlzLnJlbmRlclRvcE1lbnUoaGVhZGVySGVpZ2h0KX1cbiAgICAgICAge2lzRnJhbWVkQ29tcG9uZW50ID8gPGRpdiBzdHlsZT17ZnJhbWVkU3R5bGV9PntjaGlsZHJlbn08L2Rpdj4gOiBjaGlsZHJlbn1cbiAgICAgIDwvQ2FyZD5cbiAgICApO1xuICB9XG5cbiAgcHJvdGVjdGVkIHJlbmRlclRvcE1lbnUgPSAoaGVpZ2h0OiBudW1iZXIgfCBzdHJpbmcpID0+IChcbiAgICA8TWVudSBzZWNvbmRhcnk9e3RydWV9IHN0eWxlPXt7IG1hcmdpbjogMCwgaGVpZ2h0IH19PlxuICAgICAgPE1lbnUuSXRlbSBwb3NpdGlvbj17J2xlZnQnfSBmaXR0ZWQ9eydob3Jpem9udGFsbHknfSBzdHlsZT17eyBtYXJnaW46IDAgfX0+XG4gICAgICAgIDxpbWdcbiAgICAgICAgICBhbHQ9eydjb21wb25lbnQgaWNvbid9XG4gICAgICAgICAgc3JjPXt0aGlzLnByb3BzLmljb25TcmN9XG4gICAgICAgICAgc3R5bGU9e3sgaGVpZ2h0OiAnMzJweCcsIHBhZGRpbmc6ICcycHgnLCB3aWR0aDogJzMycHgnIH19XG4gICAgICAgIC8+XG4gICAgICAgIHt0aGlzLnByb3BzLmNvbXBvbmVudE5hbWV9XG4gICAgICA8L01lbnUuSXRlbT5cbiAgICAgIDxNZW51Lkl0ZW0gcG9zaXRpb249eydyaWdodCd9IGZpdHRlZD17J2hvcml6b250YWxseSd9IHN0eWxlPXt7IG1hcmdpbjogMCB9fT5cbiAgICAgICAgPEljb24gbmFtZT17dGhpcy5zdGF0ZS5pc0Z1bGxQYWdlID8gJ2NvbXByZXNzJyA6ICdleHBhbmQgYXJyb3dzIGFsdGVybmF0ZSd9IG9uQ2xpY2s9e3RoaXMub25GdWxsUGFnZVRvZ2dsZX0gLz5cbiAgICAgICAge3RoaXMucHJvcHMuc2hvd1NldHRpbmdzICYmIDxJY29uIG5hbWU9eydzZXR0aW5ncyd9IC8+fVxuICAgICAgPC9NZW51Lkl0ZW0+XG4gICAgPC9NZW51PlxuICApO1xuXG4gIHByb3RlY3RlZCBvbkZ1bGxQYWdlVG9nZ2xlID0gKCkgPT4ge1xuICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgaXNGdWxsUGFnZTogIXRoaXMuc3RhdGUuaXNGdWxsUGFnZSxcbiAgICB9KTtcbiAgfTtcblxuICBwcm90ZWN0ZWQgcmVzaXplRnJhbWVkQ29tcG9uZW50KCkge1xuICAgIGNvbnN0IHsgZnJhbWVIZWlnaHQsIGZyYW1lV2lkdGgsIGhlYWRlckhlaWdodCB9ID0gdGhpcy5wcm9wcztcbiAgICBjb25zdCB7IGZyYW1lZFN0eWxlLCBpc0Z1bGxQYWdlIH0gPSB0aGlzLnN0YXRlO1xuXG4gICAgaWYgKHRoaXMuY2FyZFJlZikge1xuICAgICAgY29uc3QgaUZyYW1lTm9kZVJlZiA9IFJlYWN0RE9NLmZpbmRET01Ob2RlKHRoaXMuY2FyZFJlZikgYXMgRWxlbWVudDtcbiAgICAgIGNvbnN0IGlGcmFtZU5vZGVTdHlsZSA9IGlGcmFtZU5vZGVSZWYgPyB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShpRnJhbWVOb2RlUmVmKSA6IG51bGw7XG5cbiAgICAgIGlmIChpRnJhbWVOb2RlU3R5bGUgJiYgaUZyYW1lTm9kZVN0eWxlLndpZHRoICYmIGlGcmFtZU5vZGVTdHlsZS5oZWlnaHQpIHtcbiAgICAgICAgZG9jdW1lbnQuYm9keS5zdHlsZS5vdmVyZmxvd1kgPSBpc0Z1bGxQYWdlID8gJ2hpZGRlbicgOiAnYXV0byc7XG4gICAgICAgIGNvbnN0IHJlZkhlaWdodCA9IHBhcnNlSW50KGlGcmFtZU5vZGVTdHlsZS5oZWlnaHQsIDEwKSAtIDE4O1xuICAgICAgICBjb25zdCByZWZXaWR0aCA9IHBhcnNlSW50KGlGcmFtZU5vZGVTdHlsZS53aWR0aCwgMTApIC0gMTA7XG4gICAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICAgIGZyYW1lZFN0eWxlOiB7XG4gICAgICAgICAgICAuLi5mcmFtZWRTdHlsZSxcbiAgICAgICAgICAgIHRyYW5zZm9ybTogYHNjYWxlKGNhbGMoJHtyZWZXaWR0aH0vJHtmcmFtZVdpZHRofSksY2FsYygoJHtyZWZIZWlnaHR9IC0gJHtoZWFkZXJIZWlnaHR9KS8ke2ZyYW1lSGVpZ2h0fSkpYCxcbiAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbiIsImltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IEJ1dHRvbiwgR3JpZCwgSWNvbiwgTGFiZWwsIE1lbnUsIFNpZGViYXIsIFNpZGViYXJQcm9wcyB9IGZyb20gJ3NlbWFudGljLXVpLXJlYWN0JztcblxuaW1wb3J0IHsgQ2hlbGxSYWRpb0dyb3VwLCBDaGVsbFNsaWRlciB9IGZyb20gJ35jaGVsbC12aXp+L2NvbXBvbmVudCc7XG5pbXBvcnQge1xuICBCdXR0b25XaWRnZXRDb25maWcsXG4gIENoZWxsV2lkZ2V0Q29uZmlnLFxuICBDT05GSUdVUkFUSU9OX0NPTVBPTkVOVF9UWVBFLFxuICBMYWJlbFdpZGdldENvbmZpZyxcbiAgUmFkaW9XaWRnZXRDb25maWcsXG4gIFNsaWRlcldpZGdldENvbmZpZyxcbn0gZnJvbSAnfmNoZWxsLXZpen4vZGF0YSc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgSVNldHRpbmdzUGFuZWxTdGF0ZSB7XG4gIHZpc2libGU6IGJvb2xlYW47XG59XG5cbi8vIFdlIGFyZSBvbWl0dGluZyB0aGUgJ3dpZHRoJyBwcm9wIGZyb20gdGhlIFNlbWFudGljIFNpZGViYXIgdG8gaW5zdGVhZCB1c2Ugb3VyIG93biBzbyBhbiBleGFjdCB3aWR0aCBtYXkgYmUgc3BlY2lmaWVkLlxuZXhwb3J0IHR5cGUgU2V0dGluZ3NQYW5lbFByb3BzID0ge1xuICBjb25maWd1cmF0aW9uczogQ2hlbGxXaWRnZXRDb25maWdbXTtcbiAgZGlyZWN0aW9uPzogJ3RvcCcgfCAncmlnaHQnIHwgJ2JvdHRvbScgfCAnbGVmdCc7XG4gIGludmVydGVkPzogYm9vbGVhbjtcbiAgb3BhY2l0eT86IG51bWJlcjtcbiAgc2hvd0NvbmZpZ3VyYXRpb25zPzogYm9vbGVhbjtcbiAgd2lkdGg/OiBudW1iZXIgfCBzdHJpbmc7XG59ICYgUGFydGlhbDxPbWl0PFNpZGViYXJQcm9wcywgJ3dpZHRoJz4+O1xuXG5leHBvcnQgY2xhc3MgU2V0dGluZ3NQYW5lbCBleHRlbmRzIFJlYWN0LkNvbXBvbmVudDxTZXR0aW5nc1BhbmVsUHJvcHMsIElTZXR0aW5nc1BhbmVsU3RhdGU+IHtcbiAgcHVibGljIHN0YXRpYyBkZWZhdWx0UHJvcHMgPSB7XG4gICAgY29uZmlndXJhdGlvbnM6IG5ldyBBcnJheTxDaGVsbFdpZGdldENvbmZpZz4oKSxcbiAgICBkaXJlY3Rpb246ICdsZWZ0JyxcbiAgICBpbnZlcnRlZDogdHJ1ZSxcbiAgICBvcGFjaXR5OiAwLjYsXG4gICAgc2hvd0NvbmZpZ3VyYXRpb25zOiB0cnVlLFxuICAgIHdpZHRoOiAnMTAwJScsXG4gIH07XG5cbiAgcHJvdGVjdGVkIHBhbmVsOiBIVE1MRGl2RWxlbWVudCB8IG51bGwgPSBudWxsO1xuXG4gIGNvbnN0cnVjdG9yKHByb3BzOiBTZXR0aW5nc1BhbmVsUHJvcHMpIHtcbiAgICBzdXBlcihwcm9wcyk7XG4gICAgdGhpcy5zdGF0ZSA9IHtcbiAgICAgIHZpc2libGU6IGZhbHNlLFxuICAgIH07XG4gIH1cblxuICBwdWJsaWMgY29tcG9uZW50RGlkVXBkYXRlKHByZXZQcm9wczogU2V0dGluZ3NQYW5lbFByb3BzLCBwcmV2U3RhdGU6IElTZXR0aW5nc1BhbmVsU3RhdGUpIHtcbiAgICBjb25zdCB7IHZpc2libGUgfSA9IHRoaXMuc3RhdGU7XG4gICAgaWYgKHZpc2libGUgJiYgcHJldlN0YXRlLnZpc2libGUgIT09IHZpc2libGUpIHtcbiAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGUgPT4ge1xuICAgICAgICBpZiAodGhpcy5wYW5lbCkge1xuICAgICAgICAgIGNvbnN0IHBhbmVsUmVjdCA9IHRoaXMucGFuZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cbiAgICAgICAgICBjb25zdCB7IHgsIHkgfSA9IGU7XG4gICAgICAgICAgY29uc3QgaXNJbnRlcnNlY3RlZCA9XG4gICAgICAgICAgICB4ID49IHBhbmVsUmVjdC5sZWZ0ICYmIHggPD0gcGFuZWxSZWN0LnJpZ2h0ICYmIHkgPj0gcGFuZWxSZWN0LnRvcCAmJiB5IDw9IHBhbmVsUmVjdC5ib3R0b207XG5cbiAgICAgICAgICBpZiAoIWlzSW50ZXJzZWN0ZWQpIHtcbiAgICAgICAgICAgIHRoaXMuaGlkZVNldHRpbmdzUGFuZWwoKTtcbiAgICAgICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMuaGlkZVNldHRpbmdzUGFuZWwpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdjbGljaycsIGUgPT4gdGhpcy5oaWRlU2V0dGluZ3NQYW5lbCk7XG4gICAgfVxuICB9XG5cbiAgcHVibGljIHJlbmRlcigpIHtcbiAgICBjb25zdCB7IGNoaWxkcmVuLCBjb25maWd1cmF0aW9ucywgaW52ZXJ0ZWQsIG9wYWNpdHksIHNob3dDb25maWd1cmF0aW9ucywgd2lkdGggfSA9IHRoaXMucHJvcHM7XG4gICAgY29uc3QgeyB2aXNpYmxlIH0gPSB0aGlzLnN0YXRlO1xuXG4gICAgcmV0dXJuIChcbiAgICAgIDxkaXYgcmVmPXtub2RlID0+ICh0aGlzLnBhbmVsID0gbm9kZSA/IG5vZGUgOiBudWxsKX0+XG4gICAgICAgIDxHcmlkIGNvbHVtbnM9ezF9PlxuICAgICAgICAgIHtzaG93Q29uZmlndXJhdGlvbnMgJiYgPEdyaWQuQ29sdW1uPnt0aGlzLnJlbmRlclNldHRpbmdzQnV0dG9uKCl9PC9HcmlkLkNvbHVtbj59XG4gICAgICAgICAgPFNpZGViYXIuUHVzaGFibGUgc3R5bGU9e3sgd2lkdGggfX0+XG4gICAgICAgICAgICA8U2lkZWJhclxuICAgICAgICAgICAgICBhcz17TWVudX1cbiAgICAgICAgICAgICAgYW5pbWF0aW9uPXsnb3ZlcmxheSd9XG4gICAgICAgICAgICAgIGludmVydGVkPXtpbnZlcnRlZH1cbiAgICAgICAgICAgICAgc3R5bGU9e3sgd2lkdGgsIG9wYWNpdHkgfX1cbiAgICAgICAgICAgICAgdmVydGljYWw9e3RydWV9XG4gICAgICAgICAgICAgIHZpc2libGU9e3Zpc2libGV9XG4gICAgICAgICAgICA+XG4gICAgICAgICAgICAgIHt0aGlzLnJlbmRlckNvbmZpZ3VyYXRpb25zKGNvbmZpZ3VyYXRpb25zKX1cbiAgICAgICAgICAgIDwvU2lkZWJhcj5cbiAgICAgICAgICAgIDxTaWRlYmFyLlB1c2hlcj57Y2hpbGRyZW59PC9TaWRlYmFyLlB1c2hlcj5cbiAgICAgICAgICA8L1NpZGViYXIuUHVzaGFibGU+XG4gICAgICAgIDwvR3JpZD5cbiAgICAgIDwvZGl2PlxuICAgICk7XG4gIH1cblxuICBwdWJsaWMgb25CdXR0b25DbGljayA9IChlOiBSZWFjdC5Nb3VzZUV2ZW50KSA9PiB7XG4gICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICB2aXNpYmxlOiAhdGhpcy5zdGF0ZS52aXNpYmxlLFxuICAgIH0pO1xuICB9O1xuXG4gIHB1YmxpYyByZW5kZXJTZXR0aW5nc0J1dHRvbiA9ICgpID0+IChcbiAgICA8QnV0dG9uIGJhc2ljPXt0cnVlfSBmbG9hdGVkPXsncmlnaHQnfSBpY29uPXsnc2V0dGluZ3MnfSBvbkNsaWNrPXt0aGlzLm9uQnV0dG9uQ2xpY2t9IC8+XG4gICk7XG5cbiAgcHVibGljIHJlbmRlckNvbmZpZ3VyYXRpb25zKGNvbmZpZ3VyYXRpb25zOiBDaGVsbFdpZGdldENvbmZpZ1tdKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIDxHcmlkIGNlbnRlcmVkPXt0cnVlfT5cbiAgICAgICAge2NvbmZpZ3VyYXRpb25zLm1hcCgoY29uZmlnLCBpbmRleCkgPT4ge1xuICAgICAgICAgIGNvbnN0IGlkID0gY29uZmlnLmlkXG4gICAgICAgICAgICA/IGNvbmZpZy5pZFxuICAgICAgICAgICAgOiBgJHtjb25maWcubmFtZVxuICAgICAgICAgICAgICAgIC50b0xvd2VyQ2FzZSgpXG4gICAgICAgICAgICAgICAgLnNwbGl0KCcgJylcbiAgICAgICAgICAgICAgICAuam9pbignLScpfS0ke2luZGV4fWA7XG4gICAgICAgICAgc3dpdGNoIChjb25maWcudHlwZSkge1xuICAgICAgICAgICAgY2FzZSBDT05GSUdVUkFUSU9OX0NPTVBPTkVOVF9UWVBFLkJVVFRPTjpcbiAgICAgICAgICAgICAgcmV0dXJuIDxHcmlkLlJvdyBrZXk9e2lkfT57dGhpcy5yZW5kZXJDb25maWd1cmF0aW9uQnV0dG9uKGNvbmZpZywgaWQpfTwvR3JpZC5Sb3c+O1xuICAgICAgICAgICAgY2FzZSBDT05GSUdVUkFUSU9OX0NPTVBPTkVOVF9UWVBFLkxBQkVMOlxuICAgICAgICAgICAgICByZXR1cm4gPEdyaWQuUm93IGtleT17aWR9Pnt0aGlzLnJlbmRlckNvbmZpZ3VyYXRpb25MYWJlbChjb25maWcsIGlkKX08L0dyaWQuUm93PjtcbiAgICAgICAgICAgIGNhc2UgQ09ORklHVVJBVElPTl9DT01QT05FTlRfVFlQRS5SQURJTzpcbiAgICAgICAgICAgICAgcmV0dXJuIDxHcmlkLlJvdyBrZXk9e2lkfT57dGhpcy5yZW5kZXJDb25maWd1cmF0aW9uUmFkaW9CdXR0b24oY29uZmlnLCBpZCl9PC9HcmlkLlJvdz47XG4gICAgICAgICAgICBjYXNlIENPTkZJR1VSQVRJT05fQ09NUE9ORU5UX1RZUEUuU0xJREVSOlxuICAgICAgICAgICAgICByZXR1cm4gPEdyaWQuUm93IGtleT17aWR9Pnt0aGlzLnJlbmRlckNvbmZpZ3VyYXRpb25TbGlkZXIoY29uZmlnLCBpZCl9PC9HcmlkLlJvdz47XG4gICAgICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgICAgIHJldHVybiA8R3JpZC5Sb3cga2V5PXtpZH0+e2Bjb25maWd1cmF0aW9uIGZvciAke2lkfWB9PC9HcmlkLlJvdz47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9KX1cbiAgICAgIDwvR3JpZD5cbiAgICApO1xuICB9XG5cbiAgcHVibGljIHJlbmRlckNvbmZpZ3VyYXRpb25CdXR0b24oY29uZmlnOiBCdXR0b25XaWRnZXRDb25maWcsIGlkOiBzdHJpbmcpIHtcbiAgICByZXR1cm4gKFxuICAgICAgPEJ1dHRvbiBjb21wYWN0PXt0cnVlfSBpZD17aWR9IG9uQ2xpY2s9e2NvbmZpZy5vbkNsaWNrfSBzdHlsZT17eyAuLi5jb25maWcuc3R5bGUgfX0+XG4gICAgICAgIHtjb25maWcuaWNvbiAmJiA8SWNvbiBuYW1lPXtjb25maWcuaWNvbn0gLz59XG4gICAgICAgIHtjb25maWcubmFtZX1cbiAgICAgIDwvQnV0dG9uPlxuICAgICk7XG4gIH1cblxuICBwdWJsaWMgcmVuZGVyQ29uZmlndXJhdGlvbkxhYmVsKGNvbmZpZzogTGFiZWxXaWRnZXRDb25maWcsIGlkOiBzdHJpbmcpIHtcbiAgICByZXR1cm4gKFxuICAgICAgPExhYmVsIGJhc2ljPXt0cnVlfSBpZD17aWR9IHN0eWxlPXt7IC4uLmNvbmZpZy5zdHlsZSB9fSBjb2xvcj17J29yYW5nZSd9PlxuICAgICAgICB7Y29uZmlnLm5hbWV9XG4gICAgICA8L0xhYmVsPlxuICAgICk7XG4gIH1cblxuICBwdWJsaWMgcmVuZGVyQ29uZmlndXJhdGlvblJhZGlvQnV0dG9uKGNvbmZpZzogUmFkaW9XaWRnZXRDb25maWcsIGlkOiBzdHJpbmcpIHtcbiAgICByZXR1cm4gKFxuICAgICAgPENoZWxsUmFkaW9Hcm91cFxuICAgICAgICBpZD17aWR9XG4gICAgICAgIG9wdGlvbnM9e2NvbmZpZy5vcHRpb25zfVxuICAgICAgICBvbkNoYW5nZT17Y29uZmlnLm9uQ2hhbmdlfVxuICAgICAgICBzdHlsZT17eyBjb2xvcjogJ3doaXRlJywgLi4uY29uZmlnLnN0eWxlIH19XG4gICAgICAgIHRpdGxlPXtjb25maWcubmFtZX1cbiAgICAgIC8+XG4gICAgKTtcbiAgfVxuXG4gIHB1YmxpYyByZW5kZXJDb25maWd1cmF0aW9uU2xpZGVyKGNvbmZpZzogU2xpZGVyV2lkZ2V0Q29uZmlnLCBpZDogc3RyaW5nKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIDxDaGVsbFNsaWRlclxuICAgICAgICBjbGFzc05hbWU9e2lkfVxuICAgICAgICBsYWJlbD17Y29uZmlnLm5hbWV9XG4gICAgICAgIG1heD17Y29uZmlnLnZhbHVlcy5tYXh9XG4gICAgICAgIG1pbj17Y29uZmlnLnZhbHVlcy5taW59XG4gICAgICAgIG9uQWZ0ZXJDaGFuZ2U9e2NvbmZpZy5vbkFmdGVyQ2hhbmdlfVxuICAgICAgICBvbkNoYW5nZT17Y29uZmlnLm9uQ2hhbmdlfVxuICAgICAgICBzdHlsZT17eyBjb2xvcjogJ3doaXRlJywgcGFkZGluZzogJzAgMjVweCcsIHdpZHRoOiAnOTUlJywgLi4uY29uZmlnLnN0eWxlIH19XG4gICAgICAgIHZhbHVlPXtjb25maWcudmFsdWVzLmN1cnJlbnR9XG4gICAgICAvPlxuICAgICk7XG4gIH1cblxuICBwcm90ZWN0ZWQgaGlkZVNldHRpbmdzUGFuZWwoKSB7XG4gICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICB2aXNpYmxlOiBmYWxzZSxcbiAgICB9KTtcbiAgfVxufVxuIiwiZXhwb3J0ICogZnJvbSAnLi9DYXRlZ29yeVNlbGVjdG9yJztcbmV4cG9ydCAqIGZyb20gJy4vQ2hlbGxSYWRpb0dyb3VwJztcbmV4cG9ydCAqIGZyb20gJy4vQ2hlbGxTbGlkZXInO1xuZXhwb3J0ICogZnJvbSAnLi9DaGVsbFRvb2x0aXAnO1xuZXhwb3J0ICogZnJvbSAnLi9Db21wb25lbnRDYXJkJztcbmV4cG9ydCAqIGZyb20gJy4vU2V0dGluZ3NQYW5lbCc7XG4iLCIvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6aW1wb3J0LW5hbWVcbmltcG9ydCBBbmF0b21vZ3JhbSBmcm9tICdhbmF0b21vZ3JhbSc7XG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XG5cbmltcG9ydCB7IFNldCB9IGZyb20gJ2ltbXV0YWJsZSc7XG5pbXBvcnQgeyBpbml0aWFsU3ByaW5nQ29udGV4dCwgSVNwcmluZ0NvbnRleHQsIFNwcmluZ0NvbnRleHQgfSBmcm9tICd+Y2hlbGwtdml6fi9jb250ZXh0JztcbmltcG9ydCB7IENIRUxMX0NTU19TVFlMRSB9IGZyb20gJ35jaGVsbC12aXp+L2RhdGEnO1xuXG5leHBvcnQgaW50ZXJmYWNlIElBbmF0b21vZ3JhbUNvbnRhaW5lclByb3BzIHtcbiAgaGVpZ2h0OiBudW1iZXIgfCBzdHJpbmc7XG4gIHNwZWNpZXM6ICdob21vX3NhcGllbnMnIHwgJ211c19tdXNjdWx1cyc7XG4gIHNwcmluZ0NvbnRleHQ6IElTcHJpbmdDb250ZXh0O1xuICBzdHlsZTogQ0hFTExfQ1NTX1NUWUxFO1xuICB3aWR0aDogbnVtYmVyIHwgc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIElBbmF0b21vZ3JhbUNvbnRhaW5lclN0YXRlIHtcbiAgaWRzOiBzdHJpbmdbXTtcbiAgc2VsZWN0SWRzOiBTZXQ8c3RyaW5nPjtcbn1cblxuZXhwb3J0IGNvbnN0IHNwcmluZ1RvQW5hdG9tb2dyYW1NYXBwaW5nOiB7IFtrZXk6IHN0cmluZ106IHsgW2tleTogc3RyaW5nXTogc3RyaW5nIH0gfSA9IHtcbiAgaG9tb19zYXBpZW5zOiB7XG4gICAgUDExQTogJ1VCRVJPTl8wMDAwMTc4JyxcbiAgICBQMTFCOiAnVUJFUk9OXzAwMDExNTUnLFxuICAgIFAxMkE6ICdVQkVST05fMDAwMDk1NScsXG4gICAgUDlBOiAnVUJFUk9OXzAwMDA5NzcnLFxuICB9LFxuICBtdXNfbXVzY3VsdXM6IHtcbiAgICBCbGFkZGVyOiAnVUJFUk9OXzAwMDEyNTUnLFxuICAgIEhlYXJ0OiAnVUJFUk9OXzAwMDA5NDgnLFxuICAgIEtpZG5leTogJ1VCRVJPTl8wMDAyMTEzJyxcbiAgICBMaW1iOiAnVUJFUk9OXzAwMTQ4OTInLFxuICAgIExpdmVyOiAnVUJFUk9OXzAwMDIxMDcnLFxuICAgIEx1bmc6ICdVQkVST05fMDAwMjA0OCcsXG4gICAgTWFtbWFyeTogJ1VCRVJPTl8wMDAxOTExJyxcbiAgICBNYXJyb3c6ICdVQkVST05fMDAwMjM3MScsXG4gICAgTXVzY2xlOiAnVUJFUk9OXzAwMTQ4OTInLFxuICAgIFNwbGVlbjogJ1VCRVJPTl8wMDAyMTA2JyxcbiAgICBUaHltdXM6ICdVQkVST05fMDAwMjM3MCcsXG4gICAgVG9uZ3VlOiAnVUJFUk9OXzAwMDE3MjMnLFxuICAgIFRyYWNoZWE6ICdVQkVST05fMDAwMzEyNicsXG4gIH0sXG59O1xuXG5leHBvcnQgY29uc3QgYW5hdG9tb2dyYW1Ub1NwcmluZ01hcHBpbmc6IHsgW2tleTogc3RyaW5nXTogeyBba2V5OiBzdHJpbmddOiBzdHJpbmdbXSB9IH0gPSB7XG4gIGhvbW9fc2FwaWVuczoge1xuICAgIFVCRVJPTl8wMDAwMTc4OiBbJ1AxMUEnXSxcbiAgICBVQkVST05fMDAwMDk1NTogWydQMTJBJ10sXG4gICAgVUJFUk9OXzAwMDA5Nzc6IFsnUDlBJ10sXG4gICAgVUJFUk9OXzAwMDExNTU6IFsnUDExQiddLFxuICB9LFxuICBtdXNfbXVzY3VsdXM6IHtcbiAgICBVQkVST05fMDAwMDk0ODogWydIZWFydF9hbmRfQW9ydGEnLCAnSGVhcnRfYW5kX0FvcnRhLTEwWF9QN180J10sXG4gICAgVUJFUk9OXzAwMDEyNTU6IFsnQmxhZGRlcicsICdCbGFkZGVyLTEwWF9QNF8zJywgJ0JsYWRkZXItMTBYX1A0XzQnLCAnQmxhZGRlci0xMFhfUDdfNyddLFxuICAgIFVCRVJPTl8wMDAxNzIzOiBbJ1Rvbmd1ZScsICdUb25ndWUtMTBYX1A0XzAnLCAnVG9uZ3VlLTEwWF9QNF8xJywgJ1Rvbmd1ZS0xMFhfUDdfMTAnXSxcbiAgICBVQkVST05fMDAwMTkxMTogWydNYW1tYXJ5X0dsYW5kJywgJ01hbW1hcnlfR2xhbmQtMTBYX1A3XzEyJywgJ01hbW1hcnlfR2xhbmQtMTBYX1A3XzEzJ10sXG4gICAgVUJFUk9OXzAwMDIwNDg6IFsnTHVuZycsICdMdW5nLTEwWF9QN184JywgJ0x1bmctMTBYX1A3XzknLCAnTHVuZy0xMFhfUDhfMTInLCAnTHVuZy0xMFhfUDhfMTMnXSxcbiAgICBVQkVST05fMDAwMjEwNjogWydTcGxlZW4nLCAnU3BsZWVuLTEwWF9QNF83JywgJ1NwbGVlbi0xMFhfUDdfNiddLFxuICAgIFVCRVJPTl8wMDAyMTA3OiBbJ0xpdmVyJywgJ0xpdmVyLTEwWF9QNF8yJywgJ0xpdmVyLTEwWF9QN18wJywgJ0xpdmVyLTEwWF9QN18xJ10sXG4gICAgVUJFUk9OXzAwMDIxMTM6IFsnS2lkbmV5JywgJ0tpZG5leS0xMFhfUDRfNScsICdLaWRuZXktMTBYX1A0XzYnLCAnS2lkbmV5LTEwWF9QN181J10sXG4gICAgVUJFUk9OXzAwMDIzNzA6IFsnVGh5bXVzJywgJ1RoeW11cy0xMFhfUDdfMTEnXSxcbiAgICBVQkVST05fMDAwMjM3MTogWydNYXJyb3cnLCAnTWFycm93LTEwWF9QN18yJywgJ01hcnJvdy0xMFhfUDdfMyddLFxuICAgIFVCRVJPTl8wMDAzMTI2OiBbJ1RyYWNoZWEnLCAnVHJhY2hlYS0xMFhfUDhfMTQnLCAnVHJhY2hlYS0xMFhfUDhfMTUnXSxcbiAgICBVQkVST05fMDAxNDg5MjogWydMaW1iX011c2NsZScsICdMaW1iX011c2NsZS0xMFhfUDdfMTQnLCAnTGltYl9NdXNjbGUtMTBYX1A3XzE1J10sXG4gIH0sXG59O1xuXG5leHBvcnQgY2xhc3MgQW5hdG9tb2dyYW1Db250YWluZXJDbGFzcyBleHRlbmRzIFJlYWN0LkNvbXBvbmVudDxJQW5hdG9tb2dyYW1Db250YWluZXJQcm9wcywgSUFuYXRvbW9ncmFtQ29udGFpbmVyU3RhdGU+IHtcbiAgcHVibGljIHN0YXRpYyBkZWZhdWx0UHJvcHMgPSB7XG4gICAgaGVpZ2h0OiAnMzAwcHgnLFxuICAgIHNwcmluZ0NvbnRleHQ6IHtcbiAgICAgIC4uLmluaXRpYWxTcHJpbmdDb250ZXh0LFxuICAgIH0sXG4gICAgc3R5bGU6IHt9LFxuICAgIHdpZHRoOiAnNDAwcHgnLFxuICB9O1xuXG4gIHB1YmxpYyBzdGF0aWMgZGlzcGxheU5hbWUgPSAnQW5hdG9tb2dyYW0nO1xuXG4gIHByb3RlY3RlZCBhbmF0b21vZ3JhbVJlZjogYW55O1xuXG4gIGNvbnN0cnVjdG9yKHByb3BzOiBJQW5hdG9tb2dyYW1Db250YWluZXJQcm9wcykge1xuICAgIHN1cGVyKHByb3BzKTtcbiAgICB0aGlzLnN0YXRlID0ge1xuICAgICAgaWRzOiBPYmplY3Qua2V5cyhhbmF0b21vZ3JhbVRvU3ByaW5nTWFwcGluZ1twcm9wcy5zcGVjaWVzXSksXG4gICAgICBzZWxlY3RJZHM6IFNldDxzdHJpbmc+KCksXG4gICAgfTtcbiAgfVxuXG4gIHB1YmxpYyBjb21wb25lbnREaWRVcGRhdGUocHJldlByb3BzOiBJQW5hdG9tb2dyYW1Db250YWluZXJQcm9wcykge1xuICAgIGNvbnN0IHsgc3ByaW5nQ29udGV4dCB9ID0gdGhpcy5wcm9wcztcbiAgICBpZiAoIXNwcmluZ0NvbnRleHQuc2VsZWN0ZWRMYWJlbHMuZXF1YWxzKHByZXZQcm9wcy5zcHJpbmdDb250ZXh0LnNlbGVjdGVkTGFiZWxzKSkge1xuICAgICAgY29uc3Qgc2VsZWN0SWRzID0gc3ByaW5nQ29udGV4dC5zZWxlY3RlZExhYmVsc1xuICAgICAgICAudG9BcnJheSgpXG4gICAgICAgIC5maWx0ZXIobGFiZWwgPT4gc3ByaW5nVG9BbmF0b21vZ3JhbU1hcHBpbmdbdGhpcy5wcm9wcy5zcGVjaWVzXVt0aGlzLnBhcnNlQ2F0ZWdvcnkobGFiZWwpXSAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAubWFwKGxhYmVsID0+IHNwcmluZ1RvQW5hdG9tb2dyYW1NYXBwaW5nW3RoaXMucHJvcHMuc3BlY2llc11bdGhpcy5wYXJzZUNhdGVnb3J5KGxhYmVsKV0pO1xuICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgIHNlbGVjdElkczogU2V0KHNlbGVjdElkcyksXG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICBwdWJsaWMgcmVuZGVyKCkge1xuICAgIGNvbnN0IHsgaWRzLCBzZWxlY3RJZHMgfSA9IHRoaXMuc3RhdGU7XG5cbiAgICByZXR1cm4gKFxuICAgICAgPGRpdiBjbGFzc05hbWU9eydhbmF0b21vZ3JhbS1jb250YWluZXInfSBzdHlsZT17eyBoZWlnaHQ6ICcxMDAlJyB9fT5cbiAgICAgICAgPEFuYXRvbW9ncmFtXG4gICAgICAgICAgYXRsYXNVcmw9e2BgfVxuICAgICAgICAgIGhpZ2hsaWdodENvbG91cj17J3llbGxvdyd9XG4gICAgICAgICAgb25DbGljaz17dGhpcy5vbkNsaWNrfVxuICAgICAgICAgIG9uTW91c2VPdXQ9e3RoaXMub25Nb3VzZU91dH1cbiAgICAgICAgICBvbk1vdXNlT3Zlcj17dGhpcy5vbk1vdXNlT3Zlcn1cbiAgICAgICAgICBzZWxlY3RDb2xvdXI9eydmZmFhMDAnfVxuICAgICAgICAgIHNlbGVjdElkcz17c2VsZWN0SWRzLnRvQXJyYXkoKX1cbiAgICAgICAgICBzaG93SWRzPXtpZHN9XG4gICAgICAgICAgc3BlY2llcz17dGhpcy5wcm9wcy5zcGVjaWVzfVxuICAgICAgICAgIHNlbGVjdGVkVmlldz17dGhpcy5wcm9wcy5zcGVjaWVzID09PSAnbXVzX211c2N1bHVzJyA/ICdmZW1hbGUnIDogJ21hbGUnfVxuICAgICAgICAvPlxuICAgICAgPC9kaXY+XG4gICAgKTtcbiAgfVxuXG4gIHByb3RlY3RlZCBvbkNsaWNrID0gKGlkOiBzdHJpbmcpID0+IHtcbiAgICBjb25zdCB7IHNwZWNpZXMsIHNwcmluZ0NvbnRleHQgfSA9IHRoaXMucHJvcHM7XG4gICAgY29uc3QgbGFiZWxzID0gYW5hdG9tb2dyYW1Ub1NwcmluZ01hcHBpbmdbc3BlY2llc11baWRdO1xuXG4gICAgc3ByaW5nQ29udGV4dC50b2dnbGVMYWJlbHMobGFiZWxzKTtcbiAgfTtcblxuICBwcm90ZWN0ZWQgb25Nb3VzZU91dCA9IChpZDogc3RyaW5nKSA9PiB7XG4gICAgcmV0dXJuO1xuICB9O1xuXG4gIHByb3RlY3RlZCBvbk1vdXNlT3ZlciA9IChpZDogc3RyaW5nKSA9PiB7XG4gICAgcmV0dXJuO1xuICB9O1xuXG4gIHByb3RlY3RlZCBwYXJzZUNhdGVnb3J5ID0gKGNhdGVnb3J5OiBzdHJpbmcpID0+IHtcbiAgICBjb25zdCBzcGxpdENhdGVnb3JpZXMgPSBjYXRlZ29yeS5zcGxpdCgvLXxfLyk7XG5cbiAgICByZXR1cm4gc3BsaXRDYXRlZ29yaWVzWzBdO1xuICB9O1xufVxuXG50eXBlIHJlcXVpcmVkUHJvcHMgPSBPbWl0PElBbmF0b21vZ3JhbUNvbnRhaW5lclByb3BzLCBrZXlvZiB0eXBlb2YgQW5hdG9tb2dyYW1Db250YWluZXJDbGFzcy5kZWZhdWx0UHJvcHM+ICZcbiAgUGFydGlhbDxJQW5hdG9tb2dyYW1Db250YWluZXJQcm9wcz47XG5cbmV4cG9ydCBjb25zdCBBbmF0b21vZ3JhbUNvbnRhaW5lciA9IChwcm9wczogcmVxdWlyZWRQcm9wcykgPT4gKFxuICA8U3ByaW5nQ29udGV4dC5Db25zdW1lcj5cbiAgICB7c3ByaW5nQ29udGV4dCA9PiA8QW5hdG9tb2dyYW1Db250YWluZXJDbGFzcyB7Li4ucHJvcHN9IHNwcmluZ0NvbnRleHQ9e3NwcmluZ0NvbnRleHR9IC8+fVxuICA8L1NwcmluZ0NvbnRleHQuQ29uc3VtZXI+XG4pO1xuIiwiaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgQ2hlY2tib3hQcm9wcywgRm9ybSwgRm9ybVByb3BzLCBHcmlkQ29sdW1uLCBHcmlkUm93LCBJbnB1dE9uQ2hhbmdlRGF0YSB9IGZyb20gJ3NlbWFudGljLXVpLXJlYWN0JztcblxuaW1wb3J0IHsgRmVhdHVyZVZpZXdlciB9IGZyb20gJ35jaGVsbC12aXp+L2NvbXBvbmVudCc7XG5pbXBvcnQgeyBJUGxvdGx5RGF0YSwgSVByb3RlaW4sIFRpbnRlZENoZWxsMURTZWN0aW9uIH0gZnJvbSAnfmNoZWxsLXZpen4vZGF0YSc7XG5pbXBvcnQgeyBDb2xvck1hcHBlciB9IGZyb20gJ35jaGVsbC12aXp+L2hlbHBlcic7XG5cbmV4cG9ydCBpbnRlcmZhY2UgSVByb3RlaW5GZWF0dXJlVmlld2VyUHJvcHMge1xuICBpbml0aWFsUHJvdGVpbklkOiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgSVByb3RlaW5GZWF0dXJlVmlld2VyU3RhdGUge1xuICBkYXRhOiBBcnJheTxQYXJ0aWFsPElQbG90bHlEYXRhPj47XG4gIGRvbWFpbkRhdGE6IEFycmF5PFRpbnRlZENoZWxsMURTZWN0aW9uPHN0cmluZz4+O1xuICBwcm90ZWluPzogSVByb3RlaW47XG4gIHByb3RlaW5JZDogc3RyaW5nO1xuICBzaG93R3JvdXBlZDogYm9vbGVhbjtcbn1cblxuZXhwb3J0IGNsYXNzIFByb3RlaW5GZWF0dXJlVmlld2VyIGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50PElQcm90ZWluRmVhdHVyZVZpZXdlclByb3BzLCBJUHJvdGVpbkZlYXR1cmVWaWV3ZXJTdGF0ZT4ge1xuICBwdWJsaWMgc3RhdGljIGRlZmF1bHRQcm9wcyA9IHtcbiAgICAvLyBpbml0aWFsUHJvdGVpbklkOiAnUTEzNDg1JyxcbiAgICBpbml0aWFsUHJvdGVpbklkOiAnUTlOWUo3JyxcbiAgfTtcblxuICBjb25zdHJ1Y3Rvcihwcm9wczogSVByb3RlaW5GZWF0dXJlVmlld2VyUHJvcHMpIHtcbiAgICBzdXBlcihwcm9wcyk7XG4gICAgdGhpcy5zdGF0ZSA9IHtcbiAgICAgIGRhdGE6IFtdLFxuICAgICAgZG9tYWluRGF0YTogW10sXG4gICAgICBwcm90ZWluSWQ6IHByb3BzLmluaXRpYWxQcm90ZWluSWQsXG4gICAgICBzaG93R3JvdXBlZDogdHJ1ZSxcbiAgICB9O1xuICB9XG5cbiAgcHVibGljIGFzeW5jIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgIGF3YWl0IHRoaXMuZGVyaXZlUHJvdGVpbkRhdGEoKTtcbiAgfVxuXG4gIHB1YmxpYyByZW5kZXIoKSB7XG4gICAgY29uc3QgeyBkb21haW5EYXRhLCBwcm90ZWluLCBwcm90ZWluSWQsIHNob3dHcm91cGVkIH0gPSB0aGlzLnN0YXRlO1xuXG4gICAgcmV0dXJuIChcbiAgICAgIDxkaXYgY2xhc3NOYW1lPXsncHJvdGVpbi1mZWF0dXJlLXZpZXdlcid9PlxuICAgICAgICA8R3JpZFJvdyBjZW50ZXJlZD17dHJ1ZX0gc3RyZXRjaGVkPXtmYWxzZX0+XG4gICAgICAgICAgPEdyaWRDb2x1bW4+XG4gICAgICAgICAgICA8RmVhdHVyZVZpZXdlclxuICAgICAgICAgICAgICBkYXRhPXtkb21haW5EYXRhfVxuICAgICAgICAgICAgICBnZXRUZXh0Rm9ySG92ZXI9e3RoaXMucmVuZGVyQW5ub3RhdGlvblRleHR9XG4gICAgICAgICAgICAgIHRpdGxlPXtwcm90ZWluID8gcHJvdGVpbi5pZCA6ICcnfVxuICAgICAgICAgICAgICBzaG93R3JvdXBlZD17c2hvd0dyb3VwZWR9XG4gICAgICAgICAgICAvPlxuICAgICAgICAgIDwvR3JpZENvbHVtbj5cbiAgICAgICAgICA8R3JpZENvbHVtbj5cbiAgICAgICAgICAgIDxGb3JtIG9uU3VibWl0PXt0aGlzLm9uUHJvdGVpbklucHV0U3VibWl0fT5cbiAgICAgICAgICAgICAgPEZvcm0uSW5wdXQgb25DaGFuZ2U9e3RoaXMub25Qcm90ZWluSW5wdXRDaGFuZ2V9IHZhbHVlPXtwcm90ZWluSWR9IGZsdWlkPXtmYWxzZX0gd2lkdGg9eyd0aHJlZSd9IC8+XG4gICAgICAgICAgICAgIDxGb3JtLkJ1dHRvbj5TdWJtaXQgUHJvdGVpbiBJRDwvRm9ybS5CdXR0b24+XG4gICAgICAgICAgICAgIDxGb3JtLkNoZWNrYm94IGRlZmF1bHRDaGVja2VkPXt0cnVlfSBsYWJlbD17J1Nob3cgZ3JvdXBlZD8nfSBvbkNoYW5nZT17dGhpcy5vblNob3dHcm91cGVkQ2hhbmdlfSAvPlxuICAgICAgICAgICAgPC9Gb3JtPlxuICAgICAgICAgIDwvR3JpZENvbHVtbj5cbiAgICAgICAgPC9HcmlkUm93PlxuICAgICAgPC9kaXY+XG4gICAgKTtcbiAgfVxuXG4gIHByb3RlY3RlZCBvblByb3RlaW5JbnB1dENoYW5nZSA9IChldmVudDogUmVhY3QuU3ludGhldGljRXZlbnQ8SFRNTElucHV0RWxlbWVudD4sIGRhdGE6IElucHV0T25DaGFuZ2VEYXRhKSA9PiB7XG4gICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICBwcm90ZWluSWQ6IGRhdGEudmFsdWUsXG4gICAgfSk7XG4gIH07XG5cbiAgcHJvdGVjdGVkIGFzeW5jIGRlcml2ZVByb3RlaW5EYXRhKCkge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBmZXRjaChgaHR0cHM6Ly93d3cuZWJpLmFjLnVrL3Byb3RlaW5zL2FwaS9wcm90ZWlucy8ke3RoaXMuc3RhdGUucHJvdGVpbklkfWApO1xuICAgICAgaWYgKHJlc3VsdCAmJiByZXN1bHQub2spIHtcbiAgICAgICAgY29uc3QgcHJvdGVpbiA9IChhd2FpdCByZXN1bHQuanNvbigpKSBhcyBJUHJvdGVpbjtcbiAgICAgICAgY29uc3QgZG9tYWlucyA9IHByb3RlaW4uZmVhdHVyZXMuZmlsdGVyKGZlYXR1cmUgPT4gZmVhdHVyZS50eXBlID09PSAnRE9NQUlOJyk7XG4gICAgICAgIGNvbnN0IGNvbG9yTWFwcGVyID0gbmV3IENvbG9yTWFwcGVyPHN0cmluZz4oKTtcblxuICAgICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICBkb21haW5EYXRhOiBkb21haW5zLm1hcCgoZG9tYWluLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgeyBiZWdpbiwgZGVzY3JpcHRpb24gPSAnJywgZW5kIH0gPSBkb21haW47XG4gICAgICAgICAgICAvLyBUaGlzIG1hdGNoZXMgZG9tYWlucyB0aGF0IGRvIGFuZCBkbyBub3QgaGF2ZSBvdGhlciBvZiB0aGUgc2FtZSBkb21haW4gaW4gdGhlIHByb3RlaW4uXG4gICAgICAgICAgICBjb25zdCBkb21haW5OYW1lID0gZGVzY3JpcHRpb24uc3BsaXQoJy1saWtlJylbMF07XG5cbiAgICAgICAgICAgIHJldHVybiBuZXcgVGludGVkQ2hlbGwxRFNlY3Rpb24oXG4gICAgICAgICAgICAgIGRvbWFpbk5hbWUsXG4gICAgICAgICAgICAgIGJlZ2luID8gTnVtYmVyLnBhcnNlSW50KGJlZ2luLCAxMCkgOiAtMSxcbiAgICAgICAgICAgICAgZW5kID8gTnVtYmVyLnBhcnNlSW50KGVuZCwgMTApIDogLTEsXG4gICAgICAgICAgICAgIGNvbG9yTWFwcGVyLmdldENvbG9yRm9yKGRvbWFpbk5hbWUpLFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9KSxcbiAgICAgICAgICBwcm90ZWluLFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBjb25zb2xlLmxvZyhlKTtcbiAgICB9XG4gIH1cblxuICBwcm90ZWN0ZWQgb25Qcm90ZWluSW5wdXRTdWJtaXQgPSBhc3luYyAoZXZlbnQ6IFJlYWN0LkZvcm1FdmVudDxIVE1MRm9ybUVsZW1lbnQ+LCBkYXRhOiBGb3JtUHJvcHMpID0+IHtcbiAgICBhd2FpdCB0aGlzLmRlcml2ZVByb3RlaW5EYXRhKCk7XG4gIH07XG5cbiAgcHJvdGVjdGVkIG9uU2hvd0dyb3VwZWRDaGFuZ2UgPSAoZXZlbnQ6IFJlYWN0LkZvcm1FdmVudDxIVE1MSW5wdXRFbGVtZW50PiwgZGF0YTogQ2hlY2tib3hQcm9wcykgPT4ge1xuICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgc2hvd0dyb3VwZWQ6IGRhdGEuY2hlY2tlZCAhPT0gdW5kZWZpbmVkID8gZGF0YS5jaGVja2VkIDogdGhpcy5zdGF0ZS5zaG93R3JvdXBlZCxcbiAgICB9KTtcbiAgfTtcblxuICBwcm90ZWN0ZWQgcmVuZGVyQW5ub3RhdGlvblRleHQgPSAocHJvdGVpbklkOiBzdHJpbmcsIGluZGV4OiBudW1iZXIpID0+IHtcbiAgICBjb25zdCB7IGRvbWFpbkRhdGEsIHByb3RlaW4gfSA9IHRoaXMuc3RhdGU7XG4gICAgY29uc3QgcEZhbUlkcyA9IHByb3RlaW5cbiAgICAgID8gcHJvdGVpbi5kYlJlZmVyZW5jZXNcbiAgICAgICAgICAuZmlsdGVyKGRiUmVmID0+IGRiUmVmLnR5cGUgPT09ICdQZmFtJylcbiAgICAgICAgICAuZmlsdGVyKHBGYW1SZWYgPT4ge1xuICAgICAgICAgICAgY29uc3QgeyBwcm9wZXJ0aWVzIH0gPSBwRmFtUmVmO1xuICAgICAgICAgICAgY29uc3QgZW50cnlOYW1lID0gcHJvcGVydGllcyA/IHByb3BlcnRpZXNbJ2VudHJ5IG5hbWUnXSA6IG51bGw7XG5cbiAgICAgICAgICAgIHJldHVybiBlbnRyeU5hbWUgJiYgKGVudHJ5TmFtZSA9PT0gcHJvdGVpbklkIHx8IGVudHJ5TmFtZS5sb2NhbGVDb21wYXJlKGAke3Byb3RlaW5JZH0tbGlrZSAke2luZGV4fWApKTtcbiAgICAgICAgICB9KVxuICAgICAgOiBbXTtcblxuICAgIHJldHVybiBwRmFtSWRzLmxlbmd0aCA+PSAxXG4gICAgICA/IGAke3Byb3RlaW5JZH06ICR7cHJvdGVpbklkfSBkb21haW4gKCR7ZG9tYWluRGF0YVtpbmRleF0uc3RhcnR9IC0gJHtcbiAgICAgICAgICBkb21haW5EYXRhW2luZGV4XS5lbmRcbiAgICAgICAgfSk8YnIgLz48YSBocmVmPVwiaHR0cDovL3BmYW0ueGZhbS5vcmcvZmFtaWx5LyR7XG4gICAgICAgICAgcEZhbUlkc1swXS5pZFxuICAgICAgICB9XCI+UEZBTTwvYT4gPGEgaHJlZj1cImh0dHA6Ly9tdXRhdGlvbmFsaWduZXIub3JnL2RvbWFpbnMvJHtwRmFtSWRzWzBdLmlkfVwiPk11dGFnZW4gQWxpZ25lcjwvYT5gXG4gICAgICA6ICcnO1xuICB9O1xufVxuIiwiaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgUm91dGVDb21wb25lbnRQcm9wcyB9IGZyb20gJ3JlYWN0LXJvdXRlcic7XG5pbXBvcnQgeyBMaW5rIH0gZnJvbSAncmVhY3Qtcm91dGVyLWRvbSc7XG5pbXBvcnQge1xuICBCcmVhZGNydW1iLFxuICBDaGVja2JveCxcbiAgQ29udGFpbmVyLFxuICBEaXZpZGVyLFxuICBEcm9wZG93bixcbiAgR3JpZCxcbiAgSGVhZGVyLFxuICBJbnB1dCxcbiAgTGlzdCxcbiAgTWVudSxcbiAgTWVudUl0ZW1Qcm9wcyxcbiAgU2VhcmNoLFxuICBUYWIsXG4gIFRhYmxlLFxufSBmcm9tICdzZW1hbnRpYy11aS1yZWFjdCc7XG5cbmltcG9ydCB7IERhdGFzZXREYXRhLCBWaXpEYXRhIH0gZnJvbSAnfmNoZWxsLXZpen4vZGF0YSc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgSVNpdGVIZWFkZXJQcm9wcyBleHRlbmRzIFBhcnRpYWw8Um91dGVDb21wb25lbnRQcm9wcz4ge31cblxuZXhwb3J0IGludGVyZmFjZSBJU2l0ZUhlYWRlclN0YXRlIHtcbiAgY3VycmVudFBhZ2VOYW1lOiBudWxsIHwgc3RyaW5nO1xuICBpc01vZGFsT3BlbjogYm9vbGVhbjtcbn1cblxuZXhwb3J0IGNsYXNzIFNpdGVIZWFkZXIgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQ8SVNpdGVIZWFkZXJQcm9wcywgSVNpdGVIZWFkZXJTdGF0ZT4ge1xuICBjb25zdHJ1Y3Rvcihwcm9wczogSVNpdGVIZWFkZXJQcm9wcykge1xuICAgIHN1cGVyKHByb3BzKTtcbiAgICB0aGlzLnN0YXRlID0ge1xuICAgICAgY3VycmVudFBhZ2VOYW1lOiBudWxsLFxuICAgICAgaXNNb2RhbE9wZW46IGZhbHNlLFxuICAgIH07XG4gIH1cblxuICBwdWJsaWMgY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5vbk1vdXNlQ2xpY2spO1xuICAgIGlmICh0aGlzLnByb3BzLmxvY2F0aW9uKSB7XG4gICAgICB0aGlzLmhhbmRsZVF1ZXJ5UGFyYW1zKHRoaXMucHJvcHMubG9jYXRpb24uc2VhcmNoKTtcbiAgICB9XG4gIH1cblxuICBwdWJsaWMgY29tcG9uZW50RGlkVXBkYXRlKHByZXZQcm9wczogSVNpdGVIZWFkZXJQcm9wcykge1xuICAgIGlmICh0aGlzLnByb3BzLmxvY2F0aW9uICYmIHRoaXMucHJvcHMubG9jYXRpb24gIT09IHByZXZQcm9wcy5sb2NhdGlvbikge1xuICAgICAgdGhpcy5oYW5kbGVRdWVyeVBhcmFtcyh0aGlzLnByb3BzLmxvY2F0aW9uLnNlYXJjaCk7XG4gICAgfVxuICB9XG5cbiAgcHVibGljIGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xuICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMub25Nb3VzZUNsaWNrKTtcbiAgfVxuXG4gIHB1YmxpYyByZW5kZXIoKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIDxIZWFkZXI+XG4gICAgICAgIDxNZW51IHNlY29uZGFyeT17dHJ1ZX0gYm9yZGVybGVzcz17dHJ1ZX0gZmx1aWQ9e3RydWV9IHN0eWxlPXt7IG1heEhlaWdodDogJzQwcHgnLCBwYWRkaW5nOiAnMjBweCAwIDAgMCcgfX0+XG4gICAgICAgICAgPE1lbnUuSXRlbSBmaXR0ZWQ9eyd2ZXJ0aWNhbGx5J30gcG9zaXRpb249eydsZWZ0J30+XG4gICAgICAgICAgICA8TGluayB0bz17Jy8nfT5cbiAgICAgICAgICAgICAgPGltZ1xuICAgICAgICAgICAgICAgIGFsdD17J2hjYS1keW5hbWljcy1pY29uJ31cbiAgICAgICAgICAgICAgICBzcmM9eydhc3NldHMvaWNvbnMvYmlvLWJsb2Nrcy1pY29uLTJ4LnBuZyd9XG4gICAgICAgICAgICAgICAgc3R5bGU9e3sgaGVpZ2h0OiAnMzJweCcsIHdpZHRoOiAnMzJweCcgfX1cbiAgICAgICAgICAgICAgLz5cbiAgICAgICAgICAgICAgPHNwYW4gc3R5bGU9e3sgY29sb3I6ICdibGFjaycsIGZvbnRTaXplOiAnMzJweCcsIGZvbnRXZWlnaHQ6ICdib2xkJyB9fT5IQ0EgRHluYW1pY3M8L3NwYW4+XG4gICAgICAgICAgICA8L0xpbms+XG4gICAgICAgICAgPC9NZW51Lkl0ZW0+XG4gICAgICAgICAge3RoaXMucmVuZGVyTmF2TWVudSgpfVxuICAgICAgICAgIDxNZW51Lkl0ZW0gcG9zaXRpb249eydyaWdodCd9PlxuICAgICAgICAgICAgPElucHV0IGljb249eydzZWFyY2gnfSBzaXplPXsnbWFzc2l2ZSd9IHRyYW5zcGFyZW50PXt0cnVlfSAvPlxuICAgICAgICAgIDwvTWVudS5JdGVtPlxuICAgICAgICA8L01lbnU+XG4gICAgICAgIHt0aGlzLnJlbmRlck5hdkJyZWFkY3J1bWIoKX1cbiAgICAgICAge3RoaXMucmVuZGVyQ3VycmVudERhdGEoKX1cbiAgICAgIDwvSGVhZGVyPlxuICAgICk7XG4gIH1cblxuICBwcm90ZWN0ZWQgcmVuZGVyQ3VycmVudERhdGEoKSB7XG4gICAgY29uc3QgeyBsb2NhdGlvbiB9ID0gdGhpcy5wcm9wcztcbiAgICBpZiAobG9jYXRpb24pIHtcbiAgICAgIGNvbnN0IHBhcmFtcyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMobG9jYXRpb24uc2VhcmNoKTtcbiAgICAgIGNvbnN0IHZpc3VhbGl6YXRpb25zID0gcGFyYW1zLmdldEFsbCgndml6Jyk7XG4gICAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bm8tYmFja2JvbmUtZ2V0LXNldC1vdXRzaWRlLW1vZGVsXG4gICAgICBjb25zdCBuYW1lID0gcGFyYW1zLmdldCgnbmFtZScpO1xuXG4gICAgICByZXR1cm4gKFxuICAgICAgICBuYW1lICYmXG4gICAgICAgIERhdGFzZXREYXRhW25hbWVdICYmIChcbiAgICAgICAgICA8R3JpZCBjZW50ZXJlZD17dHJ1ZX0gcGFkZGVkPXt0cnVlfSB0ZXh0QWxpZ249eydjZW50ZXInfT5cbiAgICAgICAgICAgIDxHcmlkLlJvdyB0ZXh0QWxpZ249eydsZWZ0J30+XG4gICAgICAgICAgICAgIDxwPlxuICAgICAgICAgICAgICAgIHtgU2VsZWN0ZWQgdmlzdWFsaXphdGlvbihzKTogYH1cbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICA8c3BhbiBzdHlsZT17eyBmb250V2VpZ2h0OiAnbm9ybWFsJyB9fT5cbiAgICAgICAgICAgICAgICAgICAge3Zpc3VhbGl6YXRpb25zLm1hcCh2aXogPT4gVml6RGF0YVt2aXpdLm5hbWUpLmpvaW4oJywgJyl9XG4gICAgICAgICAgICAgICAgICA8L3NwYW4+XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIDxiciAvPlxuICAgICAgICAgICAgICAgIHtuYW1lICYmIGBTZWxlY3RlZCBkYXRhc2V0OiBgfVxuICAgICAgICAgICAgICAgIDxzcGFuIHN0eWxlPXt7IGZvbnRXZWlnaHQ6ICdub3JtYWwnIH19PntgJHtEYXRhc2V0RGF0YVtuYW1lXS5mdWxsTmFtZX0gKCR7bmFtZX0pYH08L3NwYW4+XG4gICAgICAgICAgICAgIDwvcD5cbiAgICAgICAgICAgIDwvR3JpZC5Sb3c+XG4gICAgICAgICAgPC9HcmlkPlxuICAgICAgICApXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH1cblxuICBwcm90ZWN0ZWQgcmVuZGVyTmF2QnJlYWRjcnVtYigpIHtcbiAgICByZXR1cm4gKFxuICAgICAgPEJyZWFkY3J1bWIgc3R5bGU9e3sgcGFkZGluZzogJzAgMCAwIDQwcHgnIH19PlxuICAgICAgICA8QnJlYWRjcnVtYi5TZWN0aW9uPlxuICAgICAgICAgIDxMaW5rIHRvPXsnLyd9PmhvbWU8L0xpbms+XG4gICAgICAgIDwvQnJlYWRjcnVtYi5TZWN0aW9uPlxuICAgICAgICB7dGhpcy5wcm9wcy5sb2NhdGlvbiAmJlxuICAgICAgICAgIHRoaXMucHJvcHMubG9jYXRpb24ucGF0aG5hbWVcbiAgICAgICAgICAgIC5zcGxpdCgnLycpXG4gICAgICAgICAgICAuZmlsdGVyKGNhbmRpZGF0ZVBhdGggPT4gY2FuZGlkYXRlUGF0aC5sZW5ndGggPj0gMSlcbiAgICAgICAgICAgIC5tYXAoKHBhdGgsIGluZGV4KSA9PiAoXG4gICAgICAgICAgICAgIDxSZWFjdC5GcmFnbWVudCBrZXk9e2BicmVhZGNydW1iLSR7aW5kZXh9YH0+XG4gICAgICAgICAgICAgICAgPEJyZWFkY3J1bWIuRGl2aWRlciBpY29uPXsncmlnaHQgYW5nbGUnfSAvPlxuICAgICAgICAgICAgICAgIDxCcmVhZGNydW1iLlNlY3Rpb24+XG4gICAgICAgICAgICAgICAgICA8TGluayB0bz17YC8ke3BhdGh9YH0+e3BhdGh9PC9MaW5rPlxuICAgICAgICAgICAgICAgIDwvQnJlYWRjcnVtYi5TZWN0aW9uPlxuICAgICAgICAgICAgICA8L1JlYWN0LkZyYWdtZW50PlxuICAgICAgICAgICAgKSl9XG4gICAgICAgIHt0aGlzLnN0YXRlLmN1cnJlbnRQYWdlTmFtZSAmJiAoXG4gICAgICAgICAgPD5cbiAgICAgICAgICAgIDxCcmVhZGNydW1iLkRpdmlkZXIgaWNvbj17J3JpZ2h0IGFuZ2xlJ30gLz5cbiAgICAgICAgICAgIDxCcmVhZGNydW1iLlNlY3Rpb24+e3RoaXMuc3RhdGUuY3VycmVudFBhZ2VOYW1lfTwvQnJlYWRjcnVtYi5TZWN0aW9uPlxuICAgICAgICAgIDwvPlxuICAgICAgICApfVxuICAgICAgPC9CcmVhZGNydW1iPlxuICAgICk7XG4gIH1cblxuICBwcm90ZWN0ZWQgcmVuZGVyTmF2TWVudSA9ICgpID0+IHtcbiAgICByZXR1cm4gKFxuICAgICAgPE1lbnUgZGVmYXVsdEFjdGl2ZUluZGV4PXstMX0gc2Vjb25kYXJ5PXt0cnVlfT5cbiAgICAgICAgPE1lbnUuSXRlbSBrZXk9eydkYXRhc2V0cyd9PlxuICAgICAgICAgIDxMaW5rIHRvPXsnL2RhdGFzZXQnfSBzdHlsZT17eyBjb2xvcjogJ2JsYWNrJywgZm9udFNpemU6ICcxOHB4JyB9fT5cbiAgICAgICAgICAgIGRhdGFzZXRzXG4gICAgICAgICAgPC9MaW5rPlxuICAgICAgICA8L01lbnUuSXRlbT5cbiAgICAgICAgPE1lbnUuSXRlbSBrZXk9eyd2aXN1YWxpemF0aW9ucyd9PlxuICAgICAgICAgIDxMaW5rIHRvPXsnL3Zpc3VhbGl6YXRpb25zJ30gc3R5bGU9e3sgY29sb3I6ICdibGFjaycsIGZvbnRTaXplOiAnMThweCcgfX0+XG4gICAgICAgICAgICB2aXN1YWxpemF0aW9uc1xuICAgICAgICAgIDwvTGluaz5cbiAgICAgICAgPC9NZW51Lkl0ZW0+XG4gICAgICAgIDxNZW51Lkl0ZW0ga2V5PXsnc3Rvcmllcyd9PlxuICAgICAgICAgIDxMaW5rIHRvPXsnL3N0b3JpZXMnfSBzdHlsZT17eyBjb2xvcjogJ2JsYWNrJywgZm9udFNpemU6ICcxOHB4JyB9fT5cbiAgICAgICAgICAgIHN0b3JpZXNcbiAgICAgICAgICA8L0xpbms+XG4gICAgICAgIDwvTWVudS5JdGVtPlxuICAgICAgPC9NZW51PlxuICAgICk7XG4gIH07XG5cbiAgcHJvdGVjdGVkIGhhbmRsZVF1ZXJ5UGFyYW1zKHNlYXJjaDogc3RyaW5nKSB7XG4gICAgY29uc3QgcGFyYW1zID0gbmV3IFVSTFNlYXJjaFBhcmFtcyhzZWFyY2gpO1xuICAgIGNvbnN0IHZpc3VhbGl6YXRpb25zID0gcGFyYW1zLmdldEFsbCgndml6Jyk7XG4gICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm5vLWJhY2tib25lLWdldC1zZXQtb3V0c2lkZS1tb2RlbFxuICAgIGNvbnN0IG5hbWUgPSBwYXJhbXMuZ2V0KCduYW1lJyk7XG5cbiAgICBpZiAodmlzdWFsaXphdGlvbnMubGVuZ3RoID49IDEgJiYgIW5hbWUpIHtcbiAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICBjdXJyZW50UGFnZU5hbWU6IG5hbWUsXG4gICAgICAgIGlzTW9kYWxPcGVuOiB0cnVlLFxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICBjdXJyZW50UGFnZU5hbWU6IG5hbWUsXG4gICAgICAgIGlzTW9kYWxPcGVuOiBmYWxzZSxcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIHByb3RlY3RlZCBvbk1vdXNlQ2xpY2sgPSAoZTogTW91c2VFdmVudCkgPT4ge1xuICAgIHJldHVybjtcbiAgfTtcblxuICBwcm90ZWN0ZWQgcmVuZGVyVmlzdWFsaXphdGlvbnNNZW51ID0gKCkgPT4ge1xuICAgIHJldHVybiAoXG4gICAgICA8Q29udGFpbmVyIGZsdWlkPXt0cnVlfT5cbiAgICAgICAgPEhlYWRlcj5WaXN1YWxpemF0aW9uIGFwcGxpY2F0aW9uczwvSGVhZGVyPlxuICAgICAgICA8RGl2aWRlciAvPlxuICAgICAgICBkYXRhc2V0XG4gICAgICAgIDxEaXZpZGVyIC8+XG4gICAgICAgIDxTZWFyY2ggZGVmYXVsdFZhbHVlPXsnc2VhcmNoJ30gaWNvbj17ZmFsc2V9IC8+XG4gICAgICAgIDxUYWJsZSBiYXNpYz17J3ZlcnknfT5cbiAgICAgICAgICA8VGFibGUuSGVhZGVyPlxuICAgICAgICAgICAgPFRhYmxlLlJvdz5cbiAgICAgICAgICAgICAgPFRhYmxlLkhlYWRlckNlbGw+U2VsZWN0PC9UYWJsZS5IZWFkZXJDZWxsPlxuICAgICAgICAgICAgICA8VGFibGUuSGVhZGVyQ2VsbD5OYW1lPC9UYWJsZS5IZWFkZXJDZWxsPlxuICAgICAgICAgICAgICA8VGFibGUuSGVhZGVyQ2VsbD5BdXRob3Iocyk8L1RhYmxlLkhlYWRlckNlbGw+XG4gICAgICAgICAgICAgIDxUYWJsZS5IZWFkZXJDZWxsPkxhc3QgdXBkYXRlZDwvVGFibGUuSGVhZGVyQ2VsbD5cbiAgICAgICAgICAgIDwvVGFibGUuUm93PlxuXG4gICAgICAgICAgICA8VGFibGUuUm93XG4gICAgICAgICAgICAgIGNlbGxzPXtbXG4gICAgICAgICAgICAgICAgeyBrZXk6ICdTZWxlY3QnLCBjb250ZW50OiA8Q2hlY2tib3ggY2hlY2tlZD17dHJ1ZX0gLz4gfSxcbiAgICAgICAgICAgICAgICB7IGtleTogJ05hbWUnLCBjb250ZW50OiAnU1BSSU5HJyB9LFxuICAgICAgICAgICAgICAgIHsga2V5OiAnQXV0aG9yJywgY29udGVudDogJ1dlaW5yZWIsIFdvbG9jaywgS2xlaW4nIH0sXG4gICAgICAgICAgICAgICAgeyBrZXk6ICdMYXN0IFVwZGF0ZWQnLCBjb250ZW50OiAnTm92IDEzLCAyMDE4JyB9LFxuICAgICAgICAgICAgICBdfVxuICAgICAgICAgICAgLz5cbiAgICAgICAgICAgIDxUYWJsZS5Sb3dcbiAgICAgICAgICAgICAgY2VsbHM9e1tcbiAgICAgICAgICAgICAgICB7IGtleTogJ1NlbGVjdCcsIGNvbnRlbnQ6IDxDaGVja2JveCBjaGVja2VkPXtmYWxzZX0gLz4gfSxcbiAgICAgICAgICAgICAgICB7IGtleTogJ05hbWUnLCBjb250ZW50OiAndFNORS1UZW5zb3InIH0sXG4gICAgICAgICAgICAgICAgeyBrZXk6ICdBdXRob3InLCBjb250ZW50OiAnPz8nIH0sXG4gICAgICAgICAgICAgICAgeyBrZXk6ICdMYXN0IFVwZGF0ZWQnLCBjb250ZW50OiAnTm92IDEzLCAyMDE4JyB9LFxuICAgICAgICAgICAgICBdfVxuICAgICAgICAgICAgICBzdHlsZT17eyBib3JkZXI6ICdub25lJyB9fVxuICAgICAgICAgICAgLz5cbiAgICAgICAgICAgIDxUYWJsZS5Sb3dcbiAgICAgICAgICAgICAgY2VsbHM9e1tcbiAgICAgICAgICAgICAgICB7IGtleTogJ1NlbGVjdCcsIGNvbnRlbnQ6IDxDaGVja2JveCBjaGVja2VkPXtmYWxzZX0gLz4gfSxcbiAgICAgICAgICAgICAgICB7IGtleTogJ05hbWUnLCBjb250ZW50OiAnQW5hdG9tb2dyYW0nIH0sXG4gICAgICAgICAgICAgICAgeyBrZXk6ICdBdXRob3InLCBjb250ZW50OiAnPz8nIH0sXG4gICAgICAgICAgICAgICAgeyBrZXk6ICdMYXN0IFVwZGF0ZWQnLCBjb250ZW50OiAnTm92IDEzLCAyMDE4JyB9LFxuICAgICAgICAgICAgICBdfVxuICAgICAgICAgICAgICBzdHlsZT17eyBib3JkZXI6ICdub25lJyB9fVxuICAgICAgICAgICAgLz5cbiAgICAgICAgICA8L1RhYmxlLkhlYWRlcj5cbiAgICAgICAgPC9UYWJsZT5cbiAgICAgIDwvQ29udGFpbmVyPlxuICAgICk7XG4gIH07XG5cbiAgcHJvdGVjdGVkIHJlbmRlckRhdGFzZXRNZW51ID0gKCkgPT4ge1xuICAgIGxldCB2aXN1YWxpemF0aW9uczogc3RyaW5nW10gPSBbXTtcbiAgICBpZiAodGhpcy5wcm9wcy5sb2NhdGlvbikge1xuICAgICAgY29uc3QgcGFyYW1zID0gbmV3IFVSTFNlYXJjaFBhcmFtcyh0aGlzLnByb3BzLmxvY2F0aW9uLnNlYXJjaCk7XG4gICAgICB2aXN1YWxpemF0aW9ucyA9IHBhcmFtcy5nZXRBbGwoJ3ZpeicpLm1hcCh2aXogPT4gYHZpej0ke3Zpen1gKTtcbiAgICB9XG5cbiAgICBjb25zdCBkYXRhc2V0cyA9IFsnaHBjL2Z1bGwnLCAnaHBjX3NmMi9mdWxsJywgJ3RhYnVsYV9tdXJpcy8xMGsnLCAndGFidWxhX211cmlzL2Z1bGwnLCAndGFidWxhX211cmlzL2x1bmcnXTtcblxuICAgIGNvbnN0IHBhbmVzID0gW1xuICAgICAge1xuICAgICAgICBtZW51SXRlbTogJ2h1bWFuIGNlbGwgYXRsYXMnLFxuICAgICAgICByZW5kZXI6ICgpID0+IChcbiAgICAgICAgICA8VGFiLlBhbmU+XG4gICAgICAgICAgICA8Q29udGFpbmVyIGZsdWlkPXt0cnVlfT5cbiAgICAgICAgICAgICAgPFRhYmxlIGJhc2ljPXsndmVyeSd9PlxuICAgICAgICAgICAgICAgIDxUYWJsZS5IZWFkZXI+XG4gICAgICAgICAgICAgICAgICA8VGFibGUuUm93PlxuICAgICAgICAgICAgICAgICAgICA8VGFibGUuSGVhZGVyQ2VsbD5cbiAgICAgICAgICAgICAgICAgICAgICA8RHJvcGRvd24gcGxhY2Vob2xkZXI9eydzZWFyY2gnfSBzZWxlY3Rpb249e3RydWV9IC8+XG4gICAgICAgICAgICAgICAgICAgIDwvVGFibGUuSGVhZGVyQ2VsbD5cbiAgICAgICAgICAgICAgICAgICAgPFRhYmxlLkhlYWRlckNlbGw+XG4gICAgICAgICAgICAgICAgICAgICAgPERyb3Bkb3duIHBsYWNlaG9sZGVyPXsnb3JnYW4nfSBzZWxlY3Rpb249e3RydWV9IC8+XG4gICAgICAgICAgICAgICAgICAgIDwvVGFibGUuSGVhZGVyQ2VsbD5cbiAgICAgICAgICAgICAgICAgICAgPFRhYmxlLkhlYWRlckNlbGw+XG4gICAgICAgICAgICAgICAgICAgICAgPERyb3Bkb3duIHBsYWNlaG9sZGVyPXsnbWV0aG9kJ30gc2VsZWN0aW9uPXt0cnVlfSAvPlxuICAgICAgICAgICAgICAgICAgICA8L1RhYmxlLkhlYWRlckNlbGw+XG4gICAgICAgICAgICAgICAgICA8L1RhYmxlLlJvdz5cbiAgICAgICAgICAgICAgICA8L1RhYmxlLkhlYWRlcj5cbiAgICAgICAgICAgICAgPC9UYWJsZT5cbiAgICAgICAgICAgIDwvQ29udGFpbmVyPlxuICAgICAgICAgIDwvVGFiLlBhbmU+XG4gICAgICAgICksXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBtZW51SXRlbTogJ0hDQSBEeW5hbWljcyBwdWJsaWMnLFxuICAgICAgICByZW5kZXI6ICgpID0+IChcbiAgICAgICAgICA8TGlzdD57ZGF0YXNldHMubWFwKChkYXRhc2V0LCBpbmRleCkgPT4gdGhpcy5yZW5kZXJEYXRhc2V0TGlua0l0ZW0oZGF0YXNldCwgaW5kZXgsIHZpc3VhbGl6YXRpb25zKSl9PC9MaXN0PlxuICAgICAgICApLFxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgbWVudUl0ZW06ICd1cGxvYWQgZnJvbSBjb21wdXRlcicsXG4gICAgICAgIHJlbmRlcjogKCkgPT4gPFRhYi5QYW5lPkNvbWluZyBzb29uITwvVGFiLlBhbmU+LFxuICAgICAgfSxcbiAgICBdO1xuXG4gICAgcmV0dXJuIChcbiAgICAgIDxDb250YWluZXIgZmx1aWQ9e3RydWV9PlxuICAgICAgICA8SGVhZGVyPmRhdGFzZXRzPC9IZWFkZXI+XG4gICAgICAgIDxEaXZpZGVyIC8+XG4gICAgICAgIDxUYWIgZGVmYXVsdEFjdGl2ZUluZGV4PXsxfSBtZW51PXt7IHNlY29uZGFyeTogdHJ1ZSwgcG9pbnRpbmc6IHRydWUgfX0gcGFuZXM9e3BhbmVzfSAvPlxuICAgICAgPC9Db250YWluZXI+XG4gICAgKTtcbiAgfTtcblxuICBwcm90ZWN0ZWQgcmVuZGVyRGF0YXNldExpbmtJdGVtID0gKGRhdGFzZXROYW1lOiBzdHJpbmcsIGluZGV4OiBudW1iZXIsIHZpc3VhbGl6YXRpb25zOiBzdHJpbmdbXSkgPT4gKFxuICAgIDxMaXN0Lkl0ZW0ga2V5PXtgZGF0YXNldC1saW5rLSR7aW5kZXh9YH0+XG4gICAgICA8TGlua1xuICAgICAgICBvbkNsaWNrPXt0aGlzLmNsb3NlTW9kYWx9XG4gICAgICAgIHRvPXt7IHBhdGhuYW1lOiAnL2RhdGFzZXQnLCBzZWFyY2g6IGA/bmFtZT0ke2RhdGFzZXROYW1lfSYke3Zpc3VhbGl6YXRpb25zLmpvaW4oJyYnKX1gIH19XG4gICAgICA+XG4gICAgICAgIHtkYXRhc2V0TmFtZX1cbiAgICAgIDwvTGluaz5cbiAgICA8L0xpc3QuSXRlbT5cbiAgKTtcblxuICBwcm90ZWN0ZWQgY2xvc2VNb2RhbCA9ICgpID0+IHtcbiAgICB0aGlzLnNldFN0YXRlKHsgaXNNb2RhbE9wZW46IGZhbHNlIH0pO1xuICB9O1xuXG4gIHByb3RlY3RlZCBvcGVuTW9kYWwgPSAoZXZlbnQ6IFJlYWN0Lk1vdXNlRXZlbnQ8SFRNTEFuY2hvckVsZW1lbnQ+LCBkYXRhOiBNZW51SXRlbVByb3BzKSA9PiB7XG4gICAgdGhpcy5zZXRTdGF0ZSh7IGlzTW9kYWxPcGVuOiB0cnVlIH0pO1xuICB9O1xufVxuIiwiaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xuXG4vLyB0c2xpbnQ6ZGlzYWJsZTppbXBvcnQtbmFtZSBtYXRjaC1kZWZhdWx0LWV4cG9ydC1uYW1lXG5pbXBvcnQgSWZyYW1lQ29tbSwgeyBJZnJhbWVDb21tQXR0cmlidXRlcyB9IGZyb20gJ3JlYWN0LWlmcmFtZS1jb21tJztcbi8vIHRzbGludDplbmFibGU6aW1wb3J0LW5hbWUgbWF0Y2gtZGVmYXVsdC1leHBvcnQtbmFtZVxuXG5pbXBvcnQgeyBDb21wb25lbnRDYXJkIH0gZnJvbSAnfmNoZWxsLXZpen4vY29tcG9uZW50JztcbmltcG9ydCB7IGluaXRpYWxTcHJpbmdDb250ZXh0LCBJU3ByaW5nQ29udGV4dCwgU3ByaW5nQ29udGV4dCB9IGZyb20gJ35jaGVsbC12aXp+L2NvbnRleHQnO1xuaW1wb3J0IHsgSVNwcmluZ0xpbmssIElTcHJpbmdOb2RlIH0gZnJvbSAnfmNoZWxsLXZpen4vZGF0YSc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgSVNwcmluZ0NvbnRhaW5lclByb3BzIHtcbiAgZGF0YXNldExvY2F0aW9uOiBzdHJpbmc7XG4gIGlzRnVsbFBhZ2U6IGJvb2xlYW47XG4gIHBhZGRpbmc6IG51bWJlciB8IHN0cmluZztcbiAgc2VsZWN0ZWRDYXRlZ29yeTogc3RyaW5nO1xuICBzcHJpbmdDb250ZXh0OiBJU3ByaW5nQ29udGV4dDtcbiAgc3ByaW5nSGVpZ2h0OiBudW1iZXI7XG4gIHNwcmluZ1dpZHRoOiBudW1iZXI7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgSVNwcmluZ0NvbnRhaW5lclN0YXRlIHtcbiAgcG9zdE1lc3NhZ2VEYXRhOiBvYmplY3Q7XG4gIHNwcmluZ1VybDogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIElTcHJpbmdNZXNzYWdlIHtcbiAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm5vLXJlc2VydmVkLWtleXdvcmRzXG4gIHR5cGU6IHN0cmluZztcbiAgcGF5bG9hZDoge1xuICAgIGN1cnJlbnRDYXRlZ29yeTogc3RyaW5nO1xuICAgIGluZGljZXM6IG51bWJlcltdO1xuICAgIHNlbGVjdGVkTGFiZWw6IHN0cmluZztcbiAgfTtcbn1cblxuZXhwb3J0IGNsYXNzIFNwcmluZ0NvbnRhaW5lckNsYXNzIGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50PElTcHJpbmdDb250YWluZXJQcm9wcywgSVNwcmluZ0NvbnRhaW5lclN0YXRlPiB7XG4gIHB1YmxpYyBzdGF0aWMgZGVmYXVsdFByb3BzID0ge1xuICAgIGRhdGE6IHtcbiAgICAgIGxpbmtzOiBuZXcgQXJyYXk8SVNwcmluZ0xpbms+KCksXG4gICAgICBub2RlczogbmV3IEFycmF5PElTcHJpbmdOb2RlPigpLFxuICAgIH0sXG4gICAgZGF0YXNldExvY2F0aW9uOiAnaHBjL2Z1bGwnLFxuICAgIGhlYWRlckhlaWdodDogMzIsXG4gICAgaXNGdWxsUGFnZTogZmFsc2UsXG4gICAgcGFkZGluZzogMCxcbiAgICBzZWxlY3RlZENhdGVnb3J5OiAnJyxcbiAgICBzcHJpbmdDb250ZXh0OiB7XG4gICAgICAuLi5pbml0aWFsU3ByaW5nQ29udGV4dCxcbiAgICB9LFxuICAgIHNwcmluZ0hlaWdodDogMTE1MCxcbiAgICBzcHJpbmdXaWR0aDogMTE1MCxcbiAgfTtcblxuICBwdWJsaWMgc3RhdGljIGRpc3BsYXlOYW1lID0gJ1NQUklORyc7XG5cbiAgY29uc3RydWN0b3IocHJvcHM6IElTcHJpbmdDb250YWluZXJQcm9wcykge1xuICAgIHN1cGVyKHByb3BzKTtcbiAgICB0aGlzLnN0YXRlID0ge1xuICAgICAgcG9zdE1lc3NhZ2VEYXRhOiB7XG4gICAgICAgIHBheWxvYWQ6IHt9LFxuICAgICAgICB0eXBlOiAnaW5pdCcsXG4gICAgICB9LFxuICAgICAgc3ByaW5nVXJsOiB0aGlzLmdlbmVyYXRlU3ByaW5nVVJMKHRoaXMucHJvcHMuZGF0YXNldExvY2F0aW9uKSxcbiAgICB9O1xuICB9XG5cbiAgcHVibGljIGNvbXBvbmVudERpZFVwZGF0ZShwcmV2UHJvcHM6IElTcHJpbmdDb250YWluZXJQcm9wcywgcHJldlN0YXRlOiBJU3ByaW5nQ29udGFpbmVyU3RhdGUpIHtcbiAgICBjb25zdCB7IHNwcmluZ0NvbnRleHQgfSA9IHRoaXMucHJvcHM7XG4gICAgaWYgKCFwcmV2UHJvcHMuc3ByaW5nQ29udGV4dC5jdXJyZW50Q2VsbHMuZXF1YWxzKHNwcmluZ0NvbnRleHQuY3VycmVudENlbGxzKSkge1xuICAgICAgY29uc29sZS5sb2coYHNlbmRpbmcgbmV3IGNlbGxzIHRvIHNwcmluZywgdG90YWxsaW5nICR7c3ByaW5nQ29udGV4dC5jdXJyZW50Q2VsbHMuc2l6ZX1gKTtcbiAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICBwb3N0TWVzc2FnZURhdGE6IHtcbiAgICAgICAgICBwYXlsb2FkOiB7XG4gICAgICAgICAgICBpbmRpY2VzOiBzcHJpbmdDb250ZXh0LmN1cnJlbnRDZWxscy50b0FycmF5KCksXG4gICAgICAgICAgfSxcbiAgICAgICAgICB0eXBlOiAnc2VsZWN0ZWQtY2VsbHMtdXBkYXRlJyxcbiAgICAgICAgfSxcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAocHJldlByb3BzLmRhdGFzZXRMb2NhdGlvbiAhPT0gdGhpcy5wcm9wcy5kYXRhc2V0TG9jYXRpb24pIHtcbiAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICBzcHJpbmdVcmw6IHRoaXMuZ2VuZXJhdGVTcHJpbmdVUkwodGhpcy5wcm9wcy5kYXRhc2V0TG9jYXRpb24pLFxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgcHVibGljIHJlbmRlcigpIHtcbiAgICBjb25zdCB7IGlzRnVsbFBhZ2UsIHNwcmluZ0hlaWdodCwgc3ByaW5nV2lkdGggfSA9IHRoaXMucHJvcHM7XG4gICAgY29uc3QgeyBwb3N0TWVzc2FnZURhdGEsIHNwcmluZ1VybCB9ID0gdGhpcy5zdGF0ZTtcbiAgICBjb25zdCBhdHRyaWJ1dGVzOiBJZnJhbWVDb21tQXR0cmlidXRlcyA9IHtcbiAgICAgIGFsbG93RnVsbFNjcmVlbjogdHJ1ZSxcbiAgICAgIGhlaWdodDogc3ByaW5nSGVpZ2h0LFxuICAgICAgc3JjOiBzcHJpbmdVcmwsXG4gICAgICB3aWR0aDogc3ByaW5nV2lkdGgsXG4gICAgfTtcblxuICAgIGNvbnN0IHRhcmdldE9yaWdpblBpZWNlcyA9IHNwcmluZ1VybC5zcGxpdCgnLycpO1xuXG4gICAgcmV0dXJuIChcbiAgICAgIDxDb21wb25lbnRDYXJkXG4gICAgICAgIGNvbXBvbmVudE5hbWU9e1NwcmluZ0NvbnRhaW5lckNsYXNzLmRpc3BsYXlOYW1lfVxuICAgICAgICBpc0ZyYW1lZENvbXBvbmVudD17dHJ1ZX1cbiAgICAgICAgaXNGdWxsUGFnZT17aXNGdWxsUGFnZX1cbiAgICAgICAgZnJhbWVIZWlnaHQ9e3NwcmluZ0hlaWdodH1cbiAgICAgICAgZnJhbWVXaWR0aD17c3ByaW5nV2lkdGh9XG4gICAgICAgIGhlaWdodD17JzUwMHB4J31cbiAgICAgID5cbiAgICAgICAgPElmcmFtZUNvbW1cbiAgICAgICAgICBhdHRyaWJ1dGVzPXthdHRyaWJ1dGVzfVxuICAgICAgICAgIHBvc3RNZXNzYWdlRGF0YT17cG9zdE1lc3NhZ2VEYXRhfVxuICAgICAgICAgIGhhbmRsZVJlYWR5PXt0aGlzLm9uUmVhZHl9XG4gICAgICAgICAgaGFuZGxlUmVjZWl2ZU1lc3NhZ2U9e3RoaXMub25SZWNlaXZlTWVzc2FnZX1cbiAgICAgICAgICB0YXJnZXRPcmlnaW49e2Ake3RhcmdldE9yaWdpblBpZWNlc1swXX0vLyR7dGFyZ2V0T3JpZ2luUGllY2VzWzJdfWB9XG4gICAgICAgIC8+XG4gICAgICA8L0NvbXBvbmVudENhcmQ+XG4gICAgKTtcbiAgfVxuXG4gIHByb3RlY3RlZCBvblJlYWR5ID0gKCkgPT4ge1xuICAgIHJldHVybjtcbiAgfTtcblxuICBwcm90ZWN0ZWQgb25SZWNlaXZlTWVzc2FnZSA9IChtc2c6IE1lc3NhZ2VFdmVudCkgPT4ge1xuICAgIGNvbnN0IGRhdGEgPSBtc2cuZGF0YSBhcyBJU3ByaW5nTWVzc2FnZTtcbiAgICBjb25zdCB7IHNwcmluZ0NvbnRleHQgfSA9IHRoaXMucHJvcHM7XG4gICAgc3dpdGNoIChkYXRhLnR5cGUpIHtcbiAgICAgIGNhc2UgJ3NlbGVjdGVkLWNhdGVnb3J5LXVwZGF0ZSc6XG4gICAgICBjYXNlICdzZWxlY3RlZC1jZWxscy11cGRhdGUnOiB7XG4gICAgICAgIHNwcmluZ0NvbnRleHQudXBkYXRlKGRhdGEucGF5bG9hZC5pbmRpY2VzLCBkYXRhLnBheWxvYWQuY3VycmVudENhdGVnb3J5KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlICdsb2FkZWQnOiB7XG4gICAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICAgIHBvc3RNZXNzYWdlRGF0YToge1xuICAgICAgICAgICAgcGF5bG9hZDoge1xuICAgICAgICAgICAgICBpbmRpY2VzOiBzcHJpbmdDb250ZXh0LmN1cnJlbnRDZWxscy50b0FycmF5KCksXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdHlwZTogJ2luaXQnLFxuICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgZGVmYXVsdDoge1xuICAgICAgICBjb25zb2xlLmxvZyhgR290IHRoaXMgbXNnIGZvciB5YTogJHtKU09OLnN0cmluZ2lmeShtc2cpfWApO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBwcm90ZWN0ZWQgZ2VuZXJhdGVTcHJpbmdVUkwgPSAoZGF0YXNldDogc3RyaW5nKSA9PlxuICAgIGAke3dpbmRvdy5sb2NhdGlvbi5vcmlnaW59LyR7d2luZG93LmxvY2F0aW9uLnBhdGhuYW1lLnN1YnN0cihcbiAgICAgIDAsXG4gICAgICB3aW5kb3cubG9jYXRpb24ucGF0aG5hbWUubGFzdEluZGV4T2YoJy8nKSxcbiAgICApfS9zcHJpbmdWaWV3ZXIuaHRtbD9kYXRhc2V0cy8ke2RhdGFzZXR9YDtcbn1cblxudHlwZSByZXF1aXJlZFByb3BzID0gT21pdDxJU3ByaW5nQ29udGFpbmVyUHJvcHMsIGtleW9mIHR5cGVvZiBTcHJpbmdDb250YWluZXJDbGFzcy5kZWZhdWx0UHJvcHM+ICZcbiAgUGFydGlhbDxJU3ByaW5nQ29udGFpbmVyUHJvcHM+O1xuXG5leHBvcnQgY29uc3QgU3ByaW5nQ29udGFpbmVyID0gKHByb3BzOiByZXF1aXJlZFByb3BzKSA9PiAoXG4gIDxTcHJpbmdDb250ZXh0LkNvbnN1bWVyPlxuICAgIHtzcHJpbmdDb250ZXh0ID0+IDxTcHJpbmdDb250YWluZXJDbGFzcyB7Li4ucHJvcHN9IHNwcmluZ0NvbnRleHQ9e3NwcmluZ0NvbnRleHR9IC8+fVxuICA8L1NwcmluZ0NvbnRleHQuQ29uc3VtZXI+XG4pO1xuIiwiaW1wb3J0IHsgaXNFcXVhbCB9IGZyb20gJ2xvZGFzaCc7XG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XG5cbmltcG9ydCAqIGFzIHRlbnNvckZsb3cgZnJvbSAnQHRlbnNvcmZsb3cvdGZqcy1jb3JlJztcbi8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpuby1zdWJtb2R1bGUtaW1wb3J0c1xuaW1wb3J0IHsgVFNORSB9IGZyb20gJ0B0ZW5zb3JmbG93L3RmanMtdHNuZS9kaXN0L3RzbmUnO1xuaW1wb3J0IHsgR3JpZCwgSWNvbiwgUmFkaW8gfSBmcm9tICdzZW1hbnRpYy11aS1yZWFjdCc7XG5pbXBvcnQgeyBDb21wb25lbnRDYXJkLCBUZW5zb3JUQ29tcG9uZW50IH0gZnJvbSAnfmNoZWxsLXZpen4vY29tcG9uZW50JztcbmltcG9ydCB7IGluaXRpYWxTcHJpbmdDb250ZXh0LCBJU3ByaW5nQ29udGV4dCwgU3ByaW5nQ29udGV4dCB9IGZyb20gJ35jaGVsbC12aXp+L2NvbnRleHQnO1xuaW1wb3J0IHtcbiAgQ0hFTExfQ1NTX1NUWUxFLFxuICBDaGVsbENoYXJ0RXZlbnQsXG4gIENoZWxsV2lkZ2V0Q29uZmlnLFxuICBDT05GSUdVUkFUSU9OX0NPTVBPTkVOVF9UWVBFLFxuICBJUGxvdGx5RGF0YSxcbn0gZnJvbSAnfmNoZWxsLXZpen4vZGF0YSc7XG5pbXBvcnQgeyBmZXRjaFRlbnNvclRTbmVDb29yZGluYXRlRGF0YSB9IGZyb20gJ35jaGVsbC12aXp+L2hlbHBlcic7XG5cbmV4cG9ydCBpbnRlcmZhY2UgSVRlbnNvckNvbnRhaW5lclByb3BzIHtcbiAgZGF0YXNldExvY2F0aW9uOiBzdHJpbmc7XG4gIGlzRnVsbFBhZ2U6IGJvb2xlYW47XG4gIHBvaW50Q29sb3I6IHN0cmluZztcbiAgc3ByaW5nQ29udGV4dDogSVNwcmluZ0NvbnRleHQ7XG4gIHN0eWxlOiBDSEVMTF9DU1NfU1RZTEU7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgSVRlbnNvckNvbnRhaW5lclN0YXRlIHtcbiAgY29vcmRzQXJyYXk6IG51bWJlcltdW107XG4gIGlzQW5pbWF0aW5nOiBib29sZWFuO1xuICBpc0NvbXB1dGluZzogYm9vbGVhbjtcbiAgbnVtSXRlcmF0aW9uczogbnVtYmVyO1xuICB0c25lPzogVFNORTtcbiAgcGxvdGx5Q29vcmRzOiBBcnJheTxQYXJ0aWFsPElQbG90bHlEYXRhPj47XG59XG5cbmV4cG9ydCBjbGFzcyBUZW5zb3JUQ29udGFpbmVyQ2xhc3MgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQ8SVRlbnNvckNvbnRhaW5lclByb3BzLCBJVGVuc29yQ29udGFpbmVyU3RhdGU+IHtcbiAgcHVibGljIHN0YXRpYyBkZWZhdWx0UHJvcHMgPSB7XG4gICAgZGF0YXNldExvY2F0aW9uOiAnaHBjL2Z1bGwnLFxuICAgIGhlaWdodDogNDAwLFxuICAgIGlzRnVsbFBhZ2U6IGZhbHNlLFxuICAgIHBvaW50Q29sb3I6ICcjYWEwMDAwJyxcbiAgICBzcHJpbmdDb250ZXh0OiB7XG4gICAgICAuLi5pbml0aWFsU3ByaW5nQ29udGV4dCxcbiAgICB9LFxuICAgIHN0eWxlOiB7XG4gICAgICBwYWRkaW5nOiAwLFxuICAgIH0sXG4gICAgd2lkdGg6IDQwMCxcbiAgfTtcblxuICBwdWJsaWMgc3RhdGljIGRpc3BsYXlOYW1lID0gJ3RTTkUgLSBUZW5zb3JGbG93JztcblxuICBwcm90ZWN0ZWQgY2FudmFzQ29udGV4dDogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEIHwgbnVsbCA9IG51bGw7XG5cbiAgY29uc3RydWN0b3IocHJvcHM6IElUZW5zb3JDb250YWluZXJQcm9wcykge1xuICAgIHN1cGVyKHByb3BzKTtcbiAgICB0aGlzLnN0YXRlID0ge1xuICAgICAgY29vcmRzQXJyYXk6IFtdLFxuICAgICAgaXNBbmltYXRpbmc6IGZhbHNlLFxuICAgICAgaXNDb21wdXRpbmc6IGZhbHNlLFxuICAgICAgbnVtSXRlcmF0aW9uczogMCxcbiAgICAgIHBsb3RseUNvb3JkczogW10sXG4gICAgfTtcbiAgfVxuXG4gIHB1YmxpYyBhc3luYyBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgdGVuc29yRGF0YSA9IGF3YWl0IGZldGNoVGVuc29yVFNuZUNvb3JkaW5hdGVEYXRhKGBkYXRhc2V0cy8ke3RoaXMucHJvcHMuZGF0YXNldExvY2F0aW9ufWApO1xuICAgICAgY29uc3QgdHNuZURhdGEgPSB0ZW5zb3JGbG93LnRlbnNvcih0ZW5zb3JEYXRhKTtcbiAgICAgIC8vIEluaXRpYWxpemUgdGhlIHRzbmUgb3B0aW1pemVyXG4gICAgICBjb25zdCB0c25lID0gKGF3YWl0IGltcG9ydCgnQHRlbnNvcmZsb3cvdGZqcy10c25lJykpLnRzbmUodHNuZURhdGEpO1xuICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgIHRzbmUsXG4gICAgICB9KTtcbiAgICAgIGF3YWl0IHRoaXMuY29tcHV0ZVRlbnNvclRzbmUodGhpcy5zdGF0ZS5udW1JdGVyYXRpb25zKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBjb25zb2xlLmxvZyhlKTtcbiAgICB9XG4gIH1cblxuICBwdWJsaWMgYXN5bmMgY29tcG9uZW50RGlkVXBkYXRlKHByZXZQcm9wczogSVRlbnNvckNvbnRhaW5lclByb3BzKSB7XG4gICAgY29uc3QgeyBzcHJpbmdDb250ZXh0IH0gPSB0aGlzLnByb3BzO1xuICAgIGNvbnN0IHsgdHNuZSB9ID0gdGhpcy5zdGF0ZTtcbiAgICBpZiAodGhpcy5wcm9wcy5kYXRhc2V0TG9jYXRpb24gIT09IHByZXZQcm9wcy5kYXRhc2V0TG9jYXRpb24pIHtcbiAgICAgIGF3YWl0IHRoaXMuc2V0dXBUZW5zb3JEYXRhKCk7XG4gICAgfSBlbHNlIGlmICh0c25lKSB7XG4gICAgICBpZiAoc3ByaW5nQ29udGV4dC5jdXJyZW50Q2VsbHMgIT09IHByZXZQcm9wcy5zcHJpbmdDb250ZXh0LmN1cnJlbnRDZWxscykge1xuICAgICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICBwbG90bHlDb29yZHM6IHRoaXMuZ2V0UGxvdGx5Q29vcmRzRnJvbVRzbmUoYXdhaXQgdHNuZS5jb29yZHNBcnJheSgpKSxcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2UgaWYgKCFpc0VxdWFsKHNwcmluZ0NvbnRleHQuc2VsZWN0ZWRMYWJlbHMsIHByZXZQcm9wcy5zcHJpbmdDb250ZXh0LnNlbGVjdGVkTGFiZWxzKSkge1xuICAgICAgICBjb25zdCBpbmRpY2VzID0gbmV3IEFycmF5PG51bWJlcj4oKTtcbiAgICAgICAgZm9yIChjb25zdCBub2RlIG9mIHNwcmluZ0NvbnRleHQuZ3JhcGhEYXRhLm5vZGVzKSB7XG4gICAgICAgICAgaWYgKHNwcmluZ0NvbnRleHQuc2VsZWN0ZWRMYWJlbHMuaW5jbHVkZXMobm9kZS5sYWJlbEZvckNhdGVnb3J5W3NwcmluZ0NvbnRleHQuc2VsZWN0ZWRDYXRlZ29yeV0pKSB7XG4gICAgICAgICAgICBpbmRpY2VzLnB1c2gobm9kZS5udW1iZXIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICAgIHBsb3RseUNvb3JkczogdGhpcy5nZXRQbG90bHlDb29yZHNGcm9tU3ByaW5nKGF3YWl0IHRzbmUuY29vcmRzQXJyYXkoKSwgaW5kaWNlcyksXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyByZW5kZXIoKSB7XG4gICAgY29uc3QgeyBpc0Z1bGxQYWdlIH0gPSB0aGlzLnByb3BzO1xuICAgIGNvbnN0IHsgcGxvdGx5Q29vcmRzIH0gPSB0aGlzLnN0YXRlO1xuXG4gICAgcmV0dXJuIChcbiAgICAgIDxDb21wb25lbnRDYXJkXG4gICAgICAgIGNvbXBvbmVudE5hbWU9e1RlbnNvclRDb250YWluZXJDbGFzcy5kaXNwbGF5TmFtZX1cbiAgICAgICAgaWNvblNyYz17J2Fzc2V0cy9pY29ucy90ZmpzLXRzbmUtaWNvbi5wbmcnfVxuICAgICAgICBpc0Z1bGxQYWdlPXtpc0Z1bGxQYWdlfVxuICAgICAgPlxuICAgICAgICA8R3JpZCBjZW50ZXJlZD17dHJ1ZX0gc3R5bGU9e3sgaGVpZ2h0OiAnMTAwJScsIG1hcmdpbkxlZnQ6IDAsIHdpZHRoOiAnMTAwJScgfX0+XG4gICAgICAgICAgPEdyaWQuUm93IGNvbHVtbnM9eydlcXVhbCd9IHN0eWxlPXt7IG1heEhlaWdodDogJzIzcHgnLCBwYWRkaW5nOiAnN3B4IDAgMCAwJyB9fT5cbiAgICAgICAgICAgIDxHcmlkLkNvbHVtbiBmbG9hdGVkPXsnbGVmdCd9Pnt0aGlzLnJlbmRlckl0ZXJhdGVCdXR0b24oKX08L0dyaWQuQ29sdW1uPlxuICAgICAgICAgICAgPEdyaWQuQ29sdW1uPnt0aGlzLnJlbmRlckl0ZXJhdGVMYWJlbCgpfTwvR3JpZC5Db2x1bW4+XG4gICAgICAgICAgICA8R3JpZC5Db2x1bW4gZmxvYXRlZD17J3JpZ2h0J30+e3RoaXMucmVuZGVyUmVzZXRCdXR0b24oKX08L0dyaWQuQ29sdW1uPlxuICAgICAgICAgIDwvR3JpZC5Sb3c+XG4gICAgICAgICAgPEdyaWQuUm93IHN0cmV0Y2hlZD17dHJ1ZX0gc3R5bGU9e3sgaGVpZ2h0OiAnOTAlJywgbWFyZ2luOiAwIH19PlxuICAgICAgICAgICAgPFRlbnNvclRDb21wb25lbnQgb25TZWxlY3RlZENhbGxiYWNrPXt0aGlzLmhhbmRsZVBvaW50U2VsZWN0aW9ufSBwb2ludHNUb1Bsb3Q9e3Bsb3RseUNvb3Jkc30gLz5cbiAgICAgICAgICA8L0dyaWQuUm93PlxuICAgICAgICA8L0dyaWQ+XG4gICAgICA8L0NvbXBvbmVudENhcmQ+XG4gICAgKTtcbiAgfVxuXG4gIHByb3RlY3RlZCBhc3luYyBjb21wdXRlVGVuc29yVHNuZShudW1JdGVyYXRpb25zOiBudW1iZXIpIHtcbiAgICBjb25zdCB7IGlzQ29tcHV0aW5nLCB0c25lIH0gPSB0aGlzLnN0YXRlO1xuICAgIGlmICh0c25lICYmICFpc0NvbXB1dGluZykge1xuICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgIGlzQ29tcHV0aW5nOiB0cnVlLFxuICAgICAgfSk7XG4gICAgICBhd2FpdCB0c25lLmNvbXB1dGUobnVtSXRlcmF0aW9ucyk7XG4gICAgICBjb25zdCBjb29yZHNBcnJheSA9IGF3YWl0IHRzbmUuY29vcmRzQXJyYXkoKTtcbiAgICAgIGNvbnN0IHBsb3RseUNvb3JkcyA9IHRoaXMuZ2V0UGxvdGx5Q29vcmRzRnJvbVRzbmUoY29vcmRzQXJyYXkpO1xuICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgIGNvb3Jkc0FycmF5LFxuICAgICAgICBpc0NvbXB1dGluZzogZmFsc2UsXG4gICAgICAgIG51bUl0ZXJhdGlvbnMsXG4gICAgICAgIHBsb3RseUNvb3JkcyxcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIHByb3RlY3RlZCBnZXRQbG90bHlDb29yZHNGcm9tVHNuZSA9IChjb29yZHM6IG51bWJlcltdW10pOiBBcnJheTxQYXJ0aWFsPElQbG90bHlEYXRhPj4gPT4ge1xuICAgIGNvbnN0IHsgc3ByaW5nQ29udGV4dCB9ID0gdGhpcy5wcm9wcztcblxuICAgIHJldHVybiBbXG4gICAgICB7XG4gICAgICAgIG1hcmtlcjoge1xuICAgICAgICAgIGNvbG9yOiB0aGlzLnByb3BzLnBvaW50Q29sb3IsXG4gICAgICAgIH0sXG4gICAgICAgIG1vZGU6ICdtYXJrZXJzJyxcbiAgICAgICAgdHlwZTogJ3NjYXR0ZXJnbCcsXG4gICAgICAgIHg6IGNvb3Jkcy5tYXAoY29vcmQgPT4gY29vcmRbMF0pLFxuICAgICAgICB5OiBjb29yZHMubWFwKGNvb3JkID0+IGNvb3JkWzFdKSxcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIG1hcmtlcjoge1xuICAgICAgICAgIGNvbG9yOiAnI2ZmYWEwMCcsXG4gICAgICAgIH0sXG4gICAgICAgIG1vZGU6ICdtYXJrZXJzJyxcbiAgICAgICAgdHlwZTogJ3NjYXR0ZXJnbCcsXG4gICAgICAgIHg6IHNwcmluZ0NvbnRleHQuY3VycmVudENlbGxzLnRvQXJyYXkoKS5tYXAoY2VsbEluZGV4ID0+IGNvb3Jkc1tjZWxsSW5kZXhdWzBdKSxcbiAgICAgICAgeTogc3ByaW5nQ29udGV4dC5jdXJyZW50Q2VsbHMudG9BcnJheSgpLm1hcChjZWxsSW5kZXggPT4gY29vcmRzW2NlbGxJbmRleF1bMV0pLFxuICAgICAgfSxcbiAgICBdO1xuICB9O1xuXG4gIHByb3RlY3RlZCBnZXRQbG90bHlDb29yZHNGcm9tU3ByaW5nID0gKGNvb3JkczogbnVtYmVyW11bXSwgY3VycmVudENlbGxzOiBudW1iZXJbXSk6IEFycmF5PFBhcnRpYWw8SVBsb3RseURhdGE+PiA9PiB7XG4gICAgcmV0dXJuIFtcbiAgICAgIHtcbiAgICAgICAgbWFya2VyOiB7XG4gICAgICAgICAgY29sb3I6IHRoaXMucHJvcHMucG9pbnRDb2xvcixcbiAgICAgICAgfSxcbiAgICAgICAgbW9kZTogJ21hcmtlcnMnLFxuICAgICAgICB0eXBlOiAnc2NhdHRlcmdsJyxcbiAgICAgICAgeDogY29vcmRzLm1hcChjb29yZCA9PiBjb29yZFswXSksXG4gICAgICAgIHk6IGNvb3Jkcy5tYXAoY29vcmQgPT4gY29vcmRbMV0pLFxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgbWFya2VyOiB7XG4gICAgICAgICAgY29sb3I6ICcjZmZhYTAwJyxcbiAgICAgICAgfSxcbiAgICAgICAgbW9kZTogJ21hcmtlcnMnLFxuICAgICAgICB0eXBlOiAnc2NhdHRlcmdsJyxcbiAgICAgICAgeDogY3VycmVudENlbGxzLm1hcChjZWxsSW5kZXggPT4gY29vcmRzW2NlbGxJbmRleF1bMF0pLFxuICAgICAgICB5OiBjdXJyZW50Q2VsbHMubWFwKGNlbGxJbmRleCA9PiBjb29yZHNbY2VsbEluZGV4XVsxXSksXG4gICAgICB9LFxuICAgIF07XG4gIH07XG5cbiAgcHJvdGVjdGVkIGdldFRlbnNvckNvbmZpZ3MgPSAoKTogQ2hlbGxXaWRnZXRDb25maWdbXSA9PiBbXG4gICAge1xuICAgICAgbmFtZTogJ0l0ZXJhdGUgT25jZScsXG4gICAgICBvbkNsaWNrOiB0aGlzLm9uSXRlcmF0ZUZvcndhcmQoKSxcbiAgICAgIHR5cGU6IENPTkZJR1VSQVRJT05fQ09NUE9ORU5UX1RZUEUuQlVUVE9OLFxuICAgIH0sXG4gICAge1xuICAgICAgbmFtZTogJ0l0ZXJhdGUgVGVuIFRpbWVzJyxcbiAgICAgIG9uQ2xpY2s6IHRoaXMub25JdGVyYXRlRm9yd2FyZCgxMCksXG4gICAgICB0eXBlOiBDT05GSUdVUkFUSU9OX0NPTVBPTkVOVF9UWVBFLkJVVFRPTixcbiAgICB9LFxuICAgIHtcbiAgICAgIG5hbWU6ICdJdGVyYXRlIEZpZnR5IFRpbWVzJyxcbiAgICAgIG9uQ2xpY2s6IHRoaXMub25JdGVyYXRlRm9yd2FyZCg1MCksXG4gICAgICB0eXBlOiBDT05GSUdVUkFUSU9OX0NPTVBPTkVOVF9UWVBFLkJVVFRPTixcbiAgICB9LFxuICAgIHtcbiAgICAgIG5hbWU6ICdSZXNldCcsXG4gICAgICBvbkNsaWNrOiB0aGlzLm9uUmVzZXQoKSxcbiAgICAgIHR5cGU6IENPTkZJR1VSQVRJT05fQ09NUE9ORU5UX1RZUEUuQlVUVE9OLFxuICAgIH0sXG4gICAge1xuICAgICAgaWNvbjogJ2hhc2h0YWcnLFxuICAgICAgbmFtZTogYFRvdGFsIEl0ZXJhdGlvbnM6ICR7dGhpcy5zdGF0ZS5udW1JdGVyYXRpb25zfWAsXG4gICAgICB0eXBlOiBDT05GSUdVUkFUSU9OX0NPTVBPTkVOVF9UWVBFLkxBQkVMLFxuICAgIH0sXG4gIF07XG5cbiAgcHJvdGVjdGVkIGhhbmRsZVBvaW50U2VsZWN0aW9uID0gKGV2ZW50OiBDaGVsbENoYXJ0RXZlbnQpID0+IHtcbiAgICBjb25zdCB7IHNwcmluZ0NvbnRleHQgfSA9IHRoaXMucHJvcHM7XG4gICAgY29uc3QgeyBjb29yZHNBcnJheSB9ID0gdGhpcy5zdGF0ZTtcbiAgICBjb25zdCBzZWxlY3RlZENlbGxzID0gbmV3IEFycmF5PG51bWJlcj4oKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGV2ZW50LnNlbGVjdGVkUG9pbnRzLmxlbmd0aCAtIDE7IGkgKz0gMikge1xuICAgICAgY29uc3QgeCA9IGV2ZW50LnNlbGVjdGVkUG9pbnRzW2ldO1xuICAgICAgY29uc3QgeSA9IGV2ZW50LnNlbGVjdGVkUG9pbnRzW2kgKyAxXTtcbiAgICAgIGNvbnN0IGNlbGxJbmRleCA9IGNvb3Jkc0FycmF5LmZpbmRJbmRleChjb29yZCA9PiBjb29yZFswXSA9PT0geCAmJiBjb29yZFsxXSA9PT0geSk7XG4gICAgICBpZiAoY2VsbEluZGV4ID49IDApIHtcbiAgICAgICAgc2VsZWN0ZWRDZWxscy5wdXNoKGNlbGxJbmRleCk7XG4gICAgICB9XG4gICAgfVxuICAgIHNwcmluZ0NvbnRleHQuc2V0Q2VsbHMoc2VsZWN0ZWRDZWxscyk7XG4gIH07XG5cbiAgcHJvdGVjdGVkIHJlbmRlckl0ZXJhdGVMYWJlbCA9ICgpID0+IDxsYWJlbD57YGl0ZXJhdGlvbnM6ICR7dGhpcy5zdGF0ZS5udW1JdGVyYXRpb25zfWB9PC9sYWJlbD47XG5cbiAgLyoqXG4gICAqIFJlbmRlcnMgdGhlIHJhZGlvIGJ1dHRvbiByZXNwb25zaWJsZSBmb3IgdG9nZ2xpbmcgdGhlIGFuaW1hdGlvbiBvbi9vZmYuXG4gICAqL1xuICBwcm90ZWN0ZWQgcmVuZGVySXRlcmF0ZUJ1dHRvbiA9ICgpID0+IChcbiAgICA8UmFkaW9cbiAgICAgIGxhYmVsPXs8bGFiZWwgc3R5bGU9e3sgZm9udFNpemU6ICcxNHB4JywgZm9udFdlaWdodDogJ2JvbGQnIH19Pml0ZXJhdGU8L2xhYmVsPn1cbiAgICAgIG9uQ2xpY2s9e3RoaXMub25JdGVyYXRpb25Ub2dnbGUoKX1cbiAgICAgIHRvZ2dsZT17dHJ1ZX1cbiAgICAvPlxuICApO1xuXG4gIHByb3RlY3RlZCByZW5kZXJSZXNldEJ1dHRvbiA9ICgpID0+IDxJY29uIG5hbWU9eyd1bmRvJ30gb25DbGljaz17dGhpcy5vblJlc2V0KCl9IC8+O1xuXG4gIHByb3RlY3RlZCBvbkl0ZXJhdGVGb3J3YXJkID0gKGFtb3VudDogbnVtYmVyID0gMSkgPT4gYXN5bmMgKCkgPT4ge1xuICAgIGNvbnN0IHsgaXNDb21wdXRpbmcsIHRzbmUgfSA9IHRoaXMuc3RhdGU7XG4gICAgaWYgKHRzbmUgJiYgIWlzQ29tcHV0aW5nKSB7XG4gICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgaXNDb21wdXRpbmc6IHRydWUsXG4gICAgICB9KTtcbiAgICAgIGF3YWl0IHRzbmUuaXRlcmF0ZShhbW91bnQpO1xuICAgICAgY29uc3QgY29vcmRzQXJyYXkgPSBhd2FpdCB0c25lLmNvb3Jkc0FycmF5KCk7XG4gICAgICBjb25zdCBwbG90bHlDb29yZHMgPSB0aGlzLmdldFBsb3RseUNvb3Jkc0Zyb21Uc25lKGNvb3Jkc0FycmF5KTtcbiAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICBjb29yZHNBcnJheSxcbiAgICAgICAgaXNDb21wdXRpbmc6IGZhbHNlLFxuICAgICAgICBudW1JdGVyYXRpb25zOiB0aGlzLnN0YXRlLm51bUl0ZXJhdGlvbnMgKyBhbW91bnQsXG4gICAgICAgIHBsb3RseUNvb3JkcyxcbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcblxuICBwcm90ZWN0ZWQgb25JdGVyYXRpb25Ub2dnbGUgPSAoKSA9PiAoKSA9PiB7XG4gICAgY29uc3QgaXNBbmltYXRpbmcgPSAhdGhpcy5zdGF0ZS5pc0FuaW1hdGluZztcblxuICAgIGlmIChpc0FuaW1hdGluZykge1xuICAgICAgY29uc3QgYW5pbWF0aW9uRnJhbWUgPSBhc3luYyAoKSA9PiB7XG4gICAgICAgIGF3YWl0IHRoaXMub25JdGVyYXRlRm9yd2FyZCgxKSgpO1xuICAgICAgICBpZiAodGhpcy5zdGF0ZS5pc0FuaW1hdGluZyAmJiB0aGlzLnN0YXRlLm51bUl0ZXJhdGlvbnMgPCA1MDApIHtcbiAgICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoYW5pbWF0aW9uRnJhbWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuc2V0U3RhdGUoeyBpc0FuaW1hdGluZzogZmFsc2UgfSk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoYW5pbWF0aW9uRnJhbWUpO1xuICAgIH1cbiAgICB0aGlzLnNldFN0YXRlKHsgaXNBbmltYXRpbmcgfSk7XG4gIH07XG5cbiAgcHJvdGVjdGVkIG9uUmVzZXQgPSAoKSA9PiBhc3luYyAoKSA9PiB7XG4gICAgYXdhaXQgdGhpcy5jb21wdXRlVGVuc29yVHNuZSgwKTtcbiAgfTtcblxuICBwcm90ZWN0ZWQgYXN5bmMgc2V0dXBUZW5zb3JEYXRhKCkge1xuICAgIHRyeSB7XG4gICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgaXNBbmltYXRpbmc6IGZhbHNlLFxuICAgICAgICBpc0NvbXB1dGluZzogdHJ1ZSxcbiAgICAgICAgcGxvdGx5Q29vcmRzOiBbXSxcbiAgICAgICAgdHNuZTogdW5kZWZpbmVkLFxuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IHRlbnNvckRhdGEgPSBhd2FpdCBmZXRjaFRlbnNvclRTbmVDb29yZGluYXRlRGF0YShgZGF0YXNldHMvJHt0aGlzLnByb3BzLmRhdGFzZXRMb2NhdGlvbn1gKTtcbiAgICAgIGNvbnN0IHRzbmVEYXRhID0gdGVuc29yRmxvdy50ZW5zb3IodGVuc29yRGF0YSk7XG4gICAgICBjb25zdCB0c25lID0gbmV3IFRTTkUodHNuZURhdGEpO1xuICAgICAgY29uc3QgbnVtSXRlcmF0aW9ucyA9IDA7XG4gICAgICBhd2FpdCB0c25lLmNvbXB1dGUobnVtSXRlcmF0aW9ucyk7XG4gICAgICBjb25zdCBjb29yZHNBcnJheSA9IGF3YWl0IHRzbmUuY29vcmRzQXJyYXkoKTtcbiAgICAgIGNvbnN0IHBsb3RseUNvb3JkcyA9IHRoaXMuZ2V0UGxvdGx5Q29vcmRzRnJvbVRzbmUoY29vcmRzQXJyYXkpO1xuXG4gICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgY29vcmRzQXJyYXksXG4gICAgICAgIGlzQ29tcHV0aW5nOiBmYWxzZSxcbiAgICAgICAgbnVtSXRlcmF0aW9ucyxcbiAgICAgICAgcGxvdGx5Q29vcmRzLFxuICAgICAgfSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgY29uc29sZS5sb2coZSk7XG4gICAgfVxuICB9XG59XG5cbnR5cGUgcmVxdWlyZWRQcm9wcyA9IE9taXQ8SVRlbnNvckNvbnRhaW5lclByb3BzLCBrZXlvZiB0eXBlb2YgVGVuc29yVENvbnRhaW5lckNsYXNzLmRlZmF1bHRQcm9wcz4gJlxuICBQYXJ0aWFsPElUZW5zb3JDb250YWluZXJQcm9wcz47XG5cbmV4cG9ydCBjb25zdCBUZW5zb3JUQ29udGFpbmVyID0gKHByb3BzOiByZXF1aXJlZFByb3BzKSA9PiAoXG4gIDxTcHJpbmdDb250ZXh0LkNvbnN1bWVyPlxuICAgIHtzcHJpbmdDb250ZXh0ID0+IDxUZW5zb3JUQ29udGFpbmVyQ2xhc3Mgey4uLnByb3BzfSBzcHJpbmdDb250ZXh0PXtzcHJpbmdDb250ZXh0fSAvPn1cbiAgPC9TcHJpbmdDb250ZXh0LkNvbnN1bWVyPlxuKTtcbiIsImltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IEJ1dHRvbiwgRHJvcGRvd24sIERyb3Bkb3duUHJvcHMsIEdyaWQsIEdyaWRDb2x1bW4sIEdyaWRSb3csIExhYmVsIH0gZnJvbSAnc2VtYW50aWMtdWktcmVhY3QnO1xuXG5pbXBvcnQgeyBWaXpTZWxlY3RvclBhbmVsIH0gZnJvbSAnfmNoZWxsLXZpen4vY29tcG9uZW50JztcbmltcG9ydCB7IENIRUxMX0RBVEFfVFlQRSwgQ2hlbGxQREIsIElDb250YWN0TWFwRGF0YSwgVklaX1RZUEUgfSBmcm9tICd+Y2hlbGwtdml6fi9kYXRhJztcbmltcG9ydCB7XG4gIGZldGNoQXBwcm9wcmlhdGVEYXRhLFxuICBnZW5lcmF0ZVJlc2lkdWVNYXBwaW5nLFxuICBnZXRDb3VwbGluZ1Njb3Jlc0RhdGEsXG4gIHJlYWRGaWxlQXNUZXh0LFxufSBmcm9tICd+Y2hlbGwtdml6fi9oZWxwZXInO1xuXG5leHBvcnQgaW50ZXJmYWNlIElWaXpQYW5lbENvbnRhaW5lclByb3BzIHtcbiAgYWxsb3dVcGxvYWRzOiBib29sZWFuO1xuICBkYXRhRGlyczogc3RyaW5nW107XG4gIGluaXRpYWxWaXN1YWxpemF0aW9uczogVklaX1RZUEVbXTtcbiAgLyoqIE51bWJlciBvZiBwYW5lbHMgdG8gYmUgY29udHJvbGxlZCBieSB0aGlzIGNvbnRhaW5lci4gQ3VycmVudGx5IGxpbWl0ZWQgdG8gNC4gKi9cbiAgbnVtUGFuZWxzOiAxIHwgMiB8IDMgfCA0O1xuICBzdXBwb3J0ZWRWaXN1YWxpemF0aW9uczogVklaX1RZUEVbXTtcbn1cblxuZXhwb3J0IGNvbnN0IGluaXRpYWxWaXpQYW5lbFN0YXRlID0ge1xuICBjdXJyZW50RGF0YURpcjogJycsXG4gIGRhdGE6IG5ldyBPYmplY3QoKSBhcyBQYXJ0aWFsPHsgW0sgaW4gVklaX1RZUEVdOiBDSEVMTF9EQVRBX1RZUEUgfT4sXG59O1xuXG5leHBvcnQgdHlwZSBWaXpQYW5lbENvbnRhaW5lclN0YXRlID0gUmVhZG9ubHk8dHlwZW9mIGluaXRpYWxWaXpQYW5lbFN0YXRlPjtcblxuZXhwb3J0IGNsYXNzIFZpelBhbmVsQ29udGFpbmVyIGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50PElWaXpQYW5lbENvbnRhaW5lclByb3BzLCBWaXpQYW5lbENvbnRhaW5lclN0YXRlPiB7XG4gIHB1YmxpYyBzdGF0aWMgZGVmYXVsdFByb3BzID0ge1xuICAgIGFsbG93VXBsb2FkczogdHJ1ZSxcbiAgICBpbml0aWFsVmlzdWFsaXphdGlvbnM6IFtdIGFzIFZJWl9UWVBFW10sXG4gICAgLyoqIE51bWJlciBvZiBwYW5lbHMgdG8gYmUgY29udHJvbGxlZCBieSB0aGlzIGNvbnRhaW5lci4gQ3VycmVudGx5IGxpbWl0ZWQgdG8gNC4gKi9cbiAgICBudW1QYW5lbHM6IDEsXG4gIH07XG4gIHB1YmxpYyByZWFkb25seSBzdGF0ZTogVml6UGFuZWxDb250YWluZXJTdGF0ZSA9IGluaXRpYWxWaXpQYW5lbFN0YXRlO1xuXG4gIGNvbnN0cnVjdG9yKHByb3BzOiBJVml6UGFuZWxDb250YWluZXJQcm9wcykge1xuICAgIHN1cGVyKHByb3BzKTtcbiAgICB0aGlzLnN0YXRlID0ge1xuICAgICAgLi4udGhpcy5zdGF0ZSxcbiAgICAgIGN1cnJlbnREYXRhRGlyOiBwcm9wcy5kYXRhRGlyc1swXSxcbiAgICB9O1xuICB9XG5cbiAgcHVibGljIGFzeW5jIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgIGNvbnN0IHJlc3VsdHM6IFBhcnRpYWw8eyBbSyBpbiBWSVpfVFlQRV06IGFueSB9PiA9IHt9O1xuICAgIGZvciAoY29uc3Qgdml6IG9mIHRoaXMucHJvcHMuc3VwcG9ydGVkVmlzdWFsaXphdGlvbnMpIHtcbiAgICAgIHJlc3VsdHNbdml6XSA9IGF3YWl0IGZldGNoQXBwcm9wcmlhdGVEYXRhKHZpeiwgdGhpcy5zdGF0ZS5jdXJyZW50RGF0YURpcik7XG4gICAgfVxuICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgZGF0YToge1xuICAgICAgICAuLi5yZXN1bHRzLFxuICAgICAgfSxcbiAgICB9KTtcbiAgfVxuXG4gIHB1YmxpYyBhc3luYyBjb21wb25lbnREaWRVcGRhdGUocHJldlByb3BzOiBJVml6UGFuZWxDb250YWluZXJQcm9wcywgcHJldlN0YXRlOiBWaXpQYW5lbENvbnRhaW5lclN0YXRlKSB7XG4gICAgaWYgKHByZXZTdGF0ZS5jdXJyZW50RGF0YURpciAhPT0gdGhpcy5zdGF0ZS5jdXJyZW50RGF0YURpcikge1xuICAgICAgY29uc3QgcmVzdWx0czogUGFydGlhbDx7IFtLIGluIFZJWl9UWVBFXTogQ0hFTExfREFUQV9UWVBFIH0+ID0ge307XG4gICAgICBmb3IgKGNvbnN0IHZpeiBvZiB0aGlzLnByb3BzLnN1cHBvcnRlZFZpc3VhbGl6YXRpb25zKSB7XG4gICAgICAgIHJlc3VsdHNbdml6XSA9IGF3YWl0IGZldGNoQXBwcm9wcmlhdGVEYXRhKHZpeiwgdGhpcy5zdGF0ZS5jdXJyZW50RGF0YURpcik7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgLi4ucmVzdWx0cyxcbiAgICAgICAgfSxcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyByZW5kZXIoKSB7XG4gICAgY29uc3QgeyBhbGxvd1VwbG9hZHMgfSA9IHRoaXMucHJvcHM7XG5cbiAgICByZXR1cm4gKFxuICAgICAgPEdyaWQgY2xhc3NOYW1lPXsnVml6UGFuZWxDb250YWluZXInfSBjb2x1bW5zPXt0aGlzLnByb3BzLm51bVBhbmVsc30gY2VudGVyZWQ9e3RydWV9IHJlbGF4ZWQ9e3RydWV9PlxuICAgICAgICA8R3JpZFJvdyBjb2x1bW5zPXsxfSBjZW50ZXJlZD17dHJ1ZX0+XG4gICAgICAgICAgPERyb3Bkb3duXG4gICAgICAgICAgICBjbGFzc05hbWU9eyd2aXotcGFuZWwtY29udGFpbmVyLWRyb3Bkb3duJ31cbiAgICAgICAgICAgIG9uQ2hhbmdlPXt0aGlzLm9uRGF0YURpckNoYW5nZX1cbiAgICAgICAgICAgIG9wdGlvbnM9e1tcbiAgICAgICAgICAgICAgLi4udGhpcy5wcm9wcy5kYXRhRGlycy5tYXAoZGlyID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBrZXk6IGRpciwgdGV4dDogZGlyLCB2YWx1ZTogZGlyIH07XG4gICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgXX1cbiAgICAgICAgICAgIHBsYWNlaG9sZGVyPXt0aGlzLnByb3BzLmRhdGFEaXJzWzBdfVxuICAgICAgICAgICAgc2VhcmNoPXt0cnVlfVxuICAgICAgICAgIC8+XG4gICAgICAgIDwvR3JpZFJvdz5cbiAgICAgICAge3RoaXMucmVuZGVyUGFuZWxzKHRoaXMucHJvcHMubnVtUGFuZWxzLCB0aGlzLnN0YXRlLmRhdGEsIHRoaXMucHJvcHMuaW5pdGlhbFZpc3VhbGl6YXRpb25zKS5tYXAoXG4gICAgICAgICAgKHBhbmVsLCBpbmRleCkgPT4gKFxuICAgICAgICAgICAgPEdyaWRDb2x1bW4ga2V5PXtpbmRleH0+e3BhbmVsfTwvR3JpZENvbHVtbj5cbiAgICAgICAgICApLFxuICAgICAgICApfVxuXG4gICAgICAgIHthbGxvd1VwbG9hZHMgJiYgdGhpcy5yZW5kZXJGaWxlVXBsb2FkRm9ybSgpfVxuICAgICAgPC9HcmlkPlxuICAgICk7XG4gIH1cblxuICBwcm90ZWN0ZWQgcmVuZGVyUGFuZWxzKFxuICAgIG51bVBhbmVsczogbnVtYmVyLFxuICAgIGRhdGE6IFBhcnRpYWw8eyBbSyBpbiBWSVpfVFlQRV06IENIRUxMX0RBVEFfVFlQRSB9PixcbiAgICBpbml0aWFsVmlzdWFsaXphdGlvbnM6IFZJWl9UWVBFW10sXG4gICkge1xuICAgIGNvbnN0IHJlc3VsdDogSlNYLkVsZW1lbnRbXSA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtUGFuZWxzOyArK2kpIHtcbiAgICAgIHJlc3VsdC5wdXNoKFxuICAgICAgICA8Vml6U2VsZWN0b3JQYW5lbFxuICAgICAgICAgIGRhdGE9e2RhdGF9XG4gICAgICAgICAgaW5pdGlhbFZpej17aW5pdGlhbFZpc3VhbGl6YXRpb25zW2ldfVxuICAgICAgICAgIHN1cHBvcnRlZFZpc3VhbGl6YXRpb25zPXt0aGlzLnByb3BzLnN1cHBvcnRlZFZpc3VhbGl6YXRpb25zfVxuICAgICAgICAvPixcbiAgICAgICk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIHByb3RlY3RlZCByZW5kZXJGaWxlVXBsb2FkRm9ybSA9ICgpID0+IChcbiAgICA8TGFiZWwgYXM9XCJsYWJlbFwiIGJhc2ljPXt0cnVlfSBodG1sRm9yPXsndXBsb2FkJ30+XG4gICAgICA8QnV0dG9uXG4gICAgICAgIGljb249eyd1cGxvYWQnfVxuICAgICAgICBsYWJlbD17e1xuICAgICAgICAgIGJhc2ljOiB0cnVlLFxuICAgICAgICAgIGNvbnRlbnQ6ICdVcGxvYWQnLFxuICAgICAgICB9fVxuICAgICAgICBsYWJlbFBvc2l0aW9uPXsncmlnaHQnfVxuICAgICAgLz5cbiAgICAgIDxpbnB1dCBpZD17J3VwbG9hZCd9IG9uQ2hhbmdlPXt0aGlzLm9uRGF0YVVwbG9hZH0gaGlkZGVuPXt0cnVlfSB0eXBlPXsnZmlsZSd9IG11bHRpcGxlPXt0cnVlfSByZXF1aXJlZD17dHJ1ZX0gLz5cbiAgICA8L0xhYmVsPlxuICApO1xuXG4gIHByb3RlY3RlZCBvbkRhdGFVcGxvYWQgPSBhc3luYyAoZTogUmVhY3QuQ2hhbmdlRXZlbnQpID0+IHtcbiAgICBjb25zdCBmaWxlTGlzdCA9IChlLnRhcmdldCBhcyBIVE1MSW5wdXRFbGVtZW50KS5maWxlcztcbiAgICBpZiAoZmlsZUxpc3QpIHtcbiAgICAgIGNvbnN0IGZpbGVzID0gQXJyYXkuZnJvbShmaWxlTGlzdCk7XG4gICAgICBjb25zdCBwZGJJbmRleCA9IGZpbGVzLmZpbmRJbmRleChmaWxlID0+IGZpbGUubmFtZS5lbmRzV2l0aCgnLnBkYicpKTtcbiAgICAgIGNvbnN0IG1hcHBpbmdJbmRleCA9IGZpbGVzLmZpbmRJbmRleChmaWxlID0+IGZpbGUubmFtZS5sb2NhbGVDb21wYXJlKCdyZXNpZHVlX21hcHBpbmcuY3N2JykgPT09IDApO1xuICAgICAgY29uc3QgY291cGxpbmdJbmRleCA9IGZpbGVzLmZpbmRJbmRleCgoZmlsZSwgaW5kZXgpID0+IGZpbGUubmFtZS5lbmRzV2l0aCgnLmNzdicpICYmIGluZGV4ICE9PSBtYXBwaW5nSW5kZXgpO1xuICAgICAgaWYgKHBkYkluZGV4ID09PSAtMSB8fCBtYXBwaW5nSW5kZXggPT09IC0xIHx8IGNvdXBsaW5nSW5kZXggPT09IC0xKSB7XG4gICAgICAgIGFsZXJ0KFxuICAgICAgICAgICdJbmNvcnJlY3QgZmlsZXMgdXBsb2FkZWQhIFBsZWFzZSB1cGxvYWQgYSBmaWxlIG5hbWVkIHJlc2lkdWVfbWFwcGluZy5jc3YgYXMgd2VsbCBhcyBhIC5wZGIgYW5kIC5jc3YgZmlsZSEnLFxuICAgICAgICApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgcGRiRGF0YSA9IGF3YWl0IENoZWxsUERCLmNyZWF0ZVBEQihmaWxlc1twZGJJbmRleF0pO1xuICAgICAgICBjb25zdCBjb3VwbGluZ1Jlc3VsdCA9IGF3YWl0IHJlYWRGaWxlQXNUZXh0KGZpbGVzW2NvdXBsaW5nSW5kZXhdKTtcbiAgICAgICAgY29uc3QgbWFwcGluZ1Jlc3VsdCA9IGF3YWl0IHJlYWRGaWxlQXNUZXh0KGZpbGVzW21hcHBpbmdJbmRleF0pO1xuXG4gICAgICAgIGNvbnN0IGRhdGE6IElDb250YWN0TWFwRGF0YSA9IHtcbiAgICAgICAgICBjb3VwbGluZ1Njb3JlczogZ2V0Q291cGxpbmdTY29yZXNEYXRhKGNvdXBsaW5nUmVzdWx0LCBnZW5lcmF0ZVJlc2lkdWVNYXBwaW5nKG1hcHBpbmdSZXN1bHQpKSxcbiAgICAgICAgICBwZGJEYXRhLFxuICAgICAgICAgIHNlY29uZGFyeVN0cnVjdHVyZXM6IFtdLFxuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgIC4uLnRoaXMuc3RhdGUuZGF0YSxcbiAgICAgICAgICAgICdDb250YWN0IE1hcCc6IGRhdGEsXG4gICAgICAgICAgICBOR0w6IHBkYkRhdGEubmdsU3RydWN0dXJlLFxuICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBwcm90ZWN0ZWQgb25EYXRhRGlyQ2hhbmdlID0gKGV2ZW50OiBSZWFjdC5TeW50aGV0aWNFdmVudDxIVE1MRWxlbWVudD4sIGRhdGE6IERyb3Bkb3duUHJvcHMpID0+IHtcbiAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgIGN1cnJlbnREYXRhRGlyOiBkYXRhLnZhbHVlIGFzIHN0cmluZyxcbiAgICB9KTtcbiAgfTtcbn1cbiIsImV4cG9ydCAqIGZyb20gJy4vQW5hdG9tb2dyYW1Db250YWluZXInO1xuZXhwb3J0ICogZnJvbSAnLi9Qcm90ZWluRmVhdHVyZVZpZXdlcic7XG5leHBvcnQgKiBmcm9tICcuL1NwcmluZ0NvbnRhaW5lcic7XG5leHBvcnQgKiBmcm9tICcuL1NpdGVIZWFkZXInO1xuZXhwb3J0ICogZnJvbSAnLi9UZW5zb3JUQ29udGFpbmVyJztcbmV4cG9ydCAqIGZyb20gJy4vVml6UGFuZWxDb250YWluZXInO1xuIiwiaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgUm91dGVDb21wb25lbnRQcm9wcyB9IGZyb20gJ3JlYWN0LXJvdXRlcic7XG5cbmltcG9ydCB7IFJlc2lkdWVDb250ZXh0UHJvdmlkZXIsIFNlY29uZGFyeVN0cnVjdHVyZUNvbnRleHRQcm92aWRlciwgU3ByaW5nQ29udGV4dFByb3ZpZGVyIH0gZnJvbSAnfmNoZWxsLXZpen4vY29udGV4dCc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgSUNoZWxsQ29udGV4dFByb3BzIGV4dGVuZHMgUGFydGlhbDxSb3V0ZUNvbXBvbmVudFByb3BzPiB7fVxuXG4vKipcbiAqIFNob3J0aGFuZCBmb3IgcGFzc2luZyBhbGwgQ2hlbGwgY29udGV4dHMgZG93bi5cbiAqXG4gKiBAZXhwb3J0XG4gKiBAZXh0ZW5kcyB7UmVhY3QuQ29tcG9uZW50PGFueSwgYW55Pn1cbiAqL1xuZXhwb3J0IGNsYXNzIENoZWxsQ29udGV4dFByb3ZpZGVyIGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50PElDaGVsbENvbnRleHRQcm9wcywgYW55PiB7XG4gIGNvbnN0cnVjdG9yKHByb3BzOiBJQ2hlbGxDb250ZXh0UHJvcHMpIHtcbiAgICBzdXBlcihwcm9wcyk7XG4gIH1cblxuICBwdWJsaWMgcmVuZGVyKCkge1xuICAgIGNvbnN0IHBhcmFtcyA9IG5ldyBVUkxTZWFyY2hQYXJhbXModGhpcy5wcm9wcy5sb2NhdGlvbiA/IHRoaXMucHJvcHMubG9jYXRpb24uc2VhcmNoIDogJycpO1xuICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpuby1iYWNrYm9uZS1nZXQtc2V0LW91dHNpZGUtbW9kZWxcbiAgICBjb25zdCBkYXRhc2V0TG9jYXRpb24gPSBwYXJhbXMuZ2V0KCduYW1lJyk7XG5cbiAgICByZXR1cm4gKFxuICAgICAgPFNlY29uZGFyeVN0cnVjdHVyZUNvbnRleHRQcm92aWRlcj5cbiAgICAgICAgPFNwcmluZ0NvbnRleHRQcm92aWRlciBkYXRhc2V0TG9jYXRpb249e2RhdGFzZXRMb2NhdGlvbiA/IGRhdGFzZXRMb2NhdGlvbiA6ICcnfT5cbiAgICAgICAgICA8UmVzaWR1ZUNvbnRleHRQcm92aWRlcj57dGhpcy5wcm9wcy5jaGlsZHJlbn08L1Jlc2lkdWVDb250ZXh0UHJvdmlkZXI+XG4gICAgICAgIDwvU3ByaW5nQ29udGV4dFByb3ZpZGVyPlxuICAgICAgPC9TZWNvbmRhcnlTdHJ1Y3R1cmVDb250ZXh0UHJvdmlkZXI+XG4gICAgKTtcbiAgfVxufVxuIiwiaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xuXG5pbXBvcnQgeyBSZXNpZHVlQ29udGV4dFByb3ZpZGVyLCBTZWNvbmRhcnlTdHJ1Y3R1cmVDb250ZXh0UHJvdmlkZXIgfSBmcm9tICd+Y2hlbGwtdml6fi9jb250ZXh0JztcbmltcG9ydCB7IENvdXBsaW5nQ29udGFpbmVyIH0gZnJvbSAnfmNoZWxsLXZpen4vZGF0YSc7XG5cbmV4cG9ydCBjb25zdCBpbml0aWFsQ291cGxpbmdDb250ZXh0ID0ge1xuICBjb3VwbGluZ1Njb3JlczogbmV3IENvdXBsaW5nQ29udGFpbmVyKCksXG59O1xuXG5leHBvcnQgdHlwZSBJQ291cGxpbmdDb250ZXh0ID0gdHlwZW9mIGluaXRpYWxDb3VwbGluZ0NvbnRleHQ7XG5leHBvcnQgY29uc3QgQ291cGxpbmdDb250ZXh0ID0gUmVhY3QuY3JlYXRlQ29udGV4dChpbml0aWFsQ291cGxpbmdDb250ZXh0KTtcbmV4cG9ydCBjb25zdCBDb3VwbGluZ0NvbnRleHRDb25zdW1lciA9IENvdXBsaW5nQ29udGV4dC5Db25zdW1lcjtcblxuLyoqXG4gKiBTaG9ydGhhbmQgZm9yIHBhc3NpbmcgY29udGV4dHMgcmVsZXZhbnQgZm9yIENvdXBsaW5nIFNjb3JlcyAtIFByaW1hcmlseSBpbnRlcmFjdGlvbiB3aXRoIHJlc2lkdWVzIGFuZCBzZWNvbmRhcnkgc3RydWN0dXJlcy5cbiAqXG4gKiBAZXhwb3J0XG4gKiBAZXh0ZW5kcyB7UmVhY3QuQ29tcG9uZW50PGFueSwgSUNvdXBsaW5nQ29udGV4dD59XG4gKi9cbmV4cG9ydCBjbGFzcyBDb3VwbGluZ0NvbnRleHRQcm92aWRlciBleHRlbmRzIFJlYWN0LkNvbXBvbmVudDxhbnksIElDb3VwbGluZ0NvbnRleHQ+IHtcbiAgY29uc3RydWN0b3IocHJvcHM6IGFueSkge1xuICAgIHN1cGVyKHByb3BzKTtcbiAgICB0aGlzLnN0YXRlID0gaW5pdGlhbENvdXBsaW5nQ29udGV4dDtcbiAgfVxuXG4gIHB1YmxpYyByZW5kZXIoKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIDxTZWNvbmRhcnlTdHJ1Y3R1cmVDb250ZXh0UHJvdmlkZXI+XG4gICAgICAgIDxSZXNpZHVlQ29udGV4dFByb3ZpZGVyPlxuICAgICAgICAgIDxDb3VwbGluZ0NvbnRleHQuUHJvdmlkZXIgdmFsdWU9e3RoaXMuc3RhdGV9Pnt0aGlzLnByb3BzLmNoaWxkcmVufTwvQ291cGxpbmdDb250ZXh0LlByb3ZpZGVyPlxuICAgICAgICA8L1Jlc2lkdWVDb250ZXh0UHJvdmlkZXI+XG4gICAgICA8L1NlY29uZGFyeVN0cnVjdHVyZUNvbnRleHRQcm92aWRlcj5cbiAgICApO1xuICB9XG59XG4iLCIvLyB0c2xpbnQ6ZGlzYWJsZTptYXgtY2xhc3Nlcy1wZXItZmlsZVxuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xuXG5leHBvcnQgaW50ZXJmYWNlIElDaGVsbENvbnRleHQ8UiBleHRlbmRzIG9iamVjdCwgVyBleHRlbmRzIG9iamVjdCwgUlcgPSBSICYgVz4ge1xuICBDb25zdW1lcnM6IHtcbiAgICBCb3RoOiBSZWFjdC5Db25zdW1lcjxSVz47XG4gICAgUmVhZDogUmVhY3QuQ29uc3VtZXI8Uj47XG4gICAgV3JpdGU6IFJlYWN0LkNvbnN1bWVyPFc+O1xuICB9O1xuICBQcm92aWRlcnM6IHtcbiAgICBCb3RoOiBSZWFjdC5Qcm92aWRlcjxSVz47XG4gICAgUmVhZDogUmVhY3QuUHJvdmlkZXI8Uj47XG4gICAgV3JpdGU6IFJlYWN0LlByb3ZpZGVyPFc+O1xuICB9O1xuICBhbGxDb25zdW1lcnM6IEFycmF5PFJlYWN0LkNvbnN1bWVyPFI+IHwgUmVhY3QuQ29uc3VtZXI8Vz4gfCBSZWFjdC5Db25zdW1lcjxSVz4+O1xuICBhbGxQcm92aWRlcnM6IEFycmF5PFJlYWN0LlByb3ZpZGVyPFI+IHwgUmVhY3QuUHJvdmlkZXI8Vz4gfCBSZWFjdC5Qcm92aWRlcjxSVz4+O1xuICBhbGxQcm92aWRlcnNKU1goc3RhdGU6IGFueSwgY2hpbGRyZW46IFJlYWN0LlJlYWN0Tm9kZSk6IEpTWC5FbGVtZW50IHwgUmVhY3QuUmVhY3ROb2RlO1xufVxuXG5leHBvcnQgY29uc3QgY3JlYXRlR2VuZXJpY0NvbnRleHQgPSA8UiBleHRlbmRzIG9iamVjdCwgVyBleHRlbmRzIG9iamVjdD4oXG4gIHJlYWRWYWx1ZTogUixcbiAgd3JpdGVWYWx1ZTogVyxcbik6IElDaGVsbENvbnRleHQ8UiwgVz4gPT4ge1xuICBjb25zdCByZWFkQ29udGV4dCA9IFJlYWN0LmNyZWF0ZUNvbnRleHQocmVhZFZhbHVlKTtcbiAgY29uc3Qgd3JpdGVDb250ZXh0ID0gUmVhY3QuY3JlYXRlQ29udGV4dCh3cml0ZVZhbHVlKTtcbiAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm5vLW9iamVjdC1saXRlcmFsLXR5cGUtYXNzZXJ0aW9uXG4gIGNvbnN0IGJvdGhDb250ZXh0ID0gUmVhY3QuY3JlYXRlQ29udGV4dCh7IC4uLihyZWFkVmFsdWUgYXMgb2JqZWN0KSwgLi4uKHdyaXRlVmFsdWUgYXMgb2JqZWN0KSB9IGFzIFIgJiBXKTtcblxuICBjb25zdCBDb25zdW1lcnMgPSB7XG4gICAgQm90aDogYm90aENvbnRleHQuQ29uc3VtZXIsXG4gICAgUmVhZDogcmVhZENvbnRleHQuQ29uc3VtZXIsXG4gICAgV3JpdGU6IHdyaXRlQ29udGV4dC5Db25zdW1lcixcbiAgfTtcblxuICBjb25zdCBQcm92aWRlcnMgPSB7XG4gICAgQm90aDogYm90aENvbnRleHQuUHJvdmlkZXIsXG4gICAgUmVhZDogcmVhZENvbnRleHQuUHJvdmlkZXIsXG4gICAgV3JpdGU6IHdyaXRlQ29udGV4dC5Qcm92aWRlcixcbiAgfTtcblxuICBjb25zdCBhbGxDb25zdW1lcnMgPSBbLi4uT2JqZWN0LnZhbHVlcyhDb25zdW1lcnMpXTtcbiAgY29uc3QgYWxsUHJvdmlkZXJzID0gWy4uLk9iamVjdC52YWx1ZXMoUHJvdmlkZXJzKV07XG5cbiAgcmV0dXJuIHtcbiAgICBDb25zdW1lcnMsXG4gICAgUHJvdmlkZXJzLFxuICAgIGFsbENvbnN1bWVycyxcbiAgICBhbGxQcm92aWRlcnMsXG4gICAgYWxsUHJvdmlkZXJzSlNYOiAoc3RhdGU6IGFueSwgY2hpbGRyZW4pID0+XG4gICAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmVcbiAgICAgIGFsbFByb3ZpZGVycy5yZWR1Y2UoKHByZXYsIEN1cnIpID0+IDxDdXJyIHZhbHVlPXtzdGF0ZX0+e3ByZXZ9PC9DdXJyPiwgY2hpbGRyZW4pLFxuICB9O1xufTtcbiIsImltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcblxuaW1wb3J0IHsgUkVTSURVRV9UWVBFIH0gZnJvbSAnfmNoZWxsLXZpen4vZGF0YSc7XG5cbmV4cG9ydCB0eXBlIFJlc2lkdWVTZWxlY3Rpb24gPSBNYXA8c3RyaW5nLCBSRVNJRFVFX1RZUEVbXT47XG5cbmV4cG9ydCBjb25zdCBpbml0aWFsUmVzaWR1ZUNvbnRleHQgPSB7XG4gIGFkZENhbmRpZGF0ZVJlc2lkdWVzOiAocmVzaWR1ZXM6IFJFU0lEVUVfVFlQRVtdKSA9PiB7XG4gICAgcmV0dXJuO1xuICB9LFxuICBhZGRIb3ZlcmVkUmVzaWR1ZXM6IChyZXNpZHVlczogUkVTSURVRV9UWVBFW10pID0+IHtcbiAgICByZXR1cm47XG4gIH0sXG4gIGFkZExvY2tlZFJlc2lkdWVQYWlyOiAocmVzaWR1ZXM6IFJFU0lEVUVfVFlQRVtdKSA9PiB7XG4gICAgcmV0dXJuO1xuICB9LFxuICBjYW5kaWRhdGVSZXNpZHVlczogbmV3IEFycmF5PFJFU0lEVUVfVFlQRT4oKSxcbiAgY2xlYXJBbGxSZXNpZHVlczogKCkgPT4ge1xuICAgIHJldHVybjtcbiAgfSxcbiAgaG92ZXJlZFJlc2lkdWVzOiBuZXcgQXJyYXk8UkVTSURVRV9UWVBFPigpLFxuICBsb2NrZWRSZXNpZHVlUGFpcnM6IG5ldyBNYXA8c3RyaW5nLCBSRVNJRFVFX1RZUEVbXT4oKSxcbiAgcmVtb3ZlQWxsTG9ja2VkUmVzaWR1ZVBhaXJzOiAoKSA9PiB7XG4gICAgcmV0dXJuO1xuICB9LFxuICByZW1vdmVDYW5kaWRhdGVSZXNpZHVlczogKCkgPT4ge1xuICAgIHJldHVybjtcbiAgfSxcbiAgcmVtb3ZlSG92ZXJlZFJlc2lkdWVzOiAoKSA9PiB7XG4gICAgcmV0dXJuO1xuICB9LFxuICByZW1vdmVMb2NrZWRSZXNpZHVlUGFpcjogKHJlc2lkdWVzOiBSRVNJRFVFX1RZUEVbXSkgPT4ge1xuICAgIHJldHVybjtcbiAgfSxcbiAgcmVtb3ZlTm9uTG9ja2VkUmVzaWR1ZXM6ICgpID0+IHtcbiAgICByZXR1cm47XG4gIH0sXG4gIHRvZ2dsZUxvY2tlZFJlc2lkdWVQYWlyOiAocmVzaWR1ZXM6IFJFU0lEVUVfVFlQRVtdKSA9PiB7XG4gICAgcmV0dXJuO1xuICB9LFxufTtcblxuZXhwb3J0IGludGVyZmFjZSBJUmVzaWR1ZUNvbnRleHRQcm9wcyB7XG4gIHJlc2lkdWVDb250ZXh0OiBJUmVzaWR1ZUNvbnRleHQ7XG59XG5cbmV4cG9ydCB0eXBlIElSZXNpZHVlQ29udGV4dCA9IHR5cGVvZiBpbml0aWFsUmVzaWR1ZUNvbnRleHQ7XG5leHBvcnQgY29uc3QgUmVzaWR1ZUNvbnRleHQgPSBSZWFjdC5jcmVhdGVDb250ZXh0KGluaXRpYWxSZXNpZHVlQ29udGV4dCk7XG5leHBvcnQgY29uc3QgUmVzaWR1ZUNvbnRleHRDb25zdW1lciA9IFJlc2lkdWVDb250ZXh0LkNvbnN1bWVyO1xuXG5leHBvcnQgY2xhc3MgUmVzaWR1ZUNvbnRleHRQcm92aWRlciBleHRlbmRzIFJlYWN0LkNvbXBvbmVudDxhbnksIElSZXNpZHVlQ29udGV4dD4ge1xuICBjb25zdHJ1Y3Rvcihwcm9wczogYW55KSB7XG4gICAgc3VwZXIocHJvcHMpO1xuICAgIHRoaXMuc3RhdGUgPSB7XG4gICAgICAuLi5pbml0aWFsUmVzaWR1ZUNvbnRleHQsXG4gICAgICBhZGRDYW5kaWRhdGVSZXNpZHVlczogdGhpcy5vbkFkZENhbmRpZGF0ZVJlc2lkdWVzLFxuICAgICAgYWRkSG92ZXJlZFJlc2lkdWVzOiB0aGlzLm9uQWRkSG92ZXJlZFJlc2lkdWVzLFxuICAgICAgYWRkTG9ja2VkUmVzaWR1ZVBhaXI6IHRoaXMub25BZGRMb2NrZWRSZXNpZHVlUGFpcixcbiAgICAgIGNsZWFyQWxsUmVzaWR1ZXM6IHRoaXMub25DbGVhckFsbFJlc2lkdWVzLFxuICAgICAgcmVtb3ZlQWxsTG9ja2VkUmVzaWR1ZVBhaXJzOiB0aGlzLm9uUmVtb3ZlQWxsTG9ja2VkUmVzaWR1ZVBhaXJzLFxuICAgICAgcmVtb3ZlQ2FuZGlkYXRlUmVzaWR1ZXM6IHRoaXMub25SZW1vdmVDYW5kaWRhdGVSZXNpZHVlLFxuICAgICAgcmVtb3ZlSG92ZXJlZFJlc2lkdWVzOiB0aGlzLm9uUmVtb3ZlSG92ZXJlZFJlc2lkdWVzLFxuICAgICAgcmVtb3ZlTG9ja2VkUmVzaWR1ZVBhaXI6IHRoaXMub25SZW1vdmVMb2NrZWRSZXNpZHVlUGFpcixcbiAgICAgIHJlbW92ZU5vbkxvY2tlZFJlc2lkdWVzOiB0aGlzLm9uUmVtb3ZlTm9uTG9ja2VkUmVzaWR1ZXMsXG4gICAgICB0b2dnbGVMb2NrZWRSZXNpZHVlUGFpcjogdGhpcy5vblRvZ2dsZUxvY2tlZFJlc2lkdWVQYWlyLFxuICAgIH07XG4gIH1cblxuICBwdWJsaWMgcmVuZGVyKCkge1xuICAgIHJldHVybiA8UmVzaWR1ZUNvbnRleHQuUHJvdmlkZXIgdmFsdWU9e3RoaXMuc3RhdGV9Pnt0aGlzLnByb3BzLmNoaWxkcmVufTwvUmVzaWR1ZUNvbnRleHQuUHJvdmlkZXI+O1xuICB9XG5cbiAgcHJvdGVjdGVkIG9uQWRkQ2FuZGlkYXRlUmVzaWR1ZXMgPSAoY2FuZGlkYXRlUmVzaWR1ZXM6IFJFU0lEVUVfVFlQRVtdKSA9PiB7XG4gICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICBjYW5kaWRhdGVSZXNpZHVlczogY2FuZGlkYXRlUmVzaWR1ZXMuc29ydCgpLFxuICAgIH0pO1xuICB9O1xuXG4gIHByb3RlY3RlZCBvbkFkZEhvdmVyZWRSZXNpZHVlcyA9IChob3ZlcmVkUmVzaWR1ZXM6IFJFU0lEVUVfVFlQRVtdKSA9PiB7XG4gICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICBob3ZlcmVkUmVzaWR1ZXM6IGhvdmVyZWRSZXNpZHVlcy5zb3J0KCksXG4gICAgfSk7XG4gIH07XG5cbiAgcHJvdGVjdGVkIG9uQWRkTG9ja2VkUmVzaWR1ZVBhaXIgPSAocmVzaWR1ZXM6IFJFU0lEVUVfVFlQRVtdKSA9PiB7XG4gICAgY29uc3QgeyBsb2NrZWRSZXNpZHVlUGFpcnMgfSA9IHRoaXMuc3RhdGU7XG4gICAgY29uc3Qgc29ydGVkUmVzaWR1ZXMgPSByZXNpZHVlcy5zb3J0KCk7XG4gICAgY29uc3QgcmVzaWR1ZVBhaXJLZXkgPSBzb3J0ZWRSZXNpZHVlcy50b1N0cmluZygpO1xuICAgIGlmICghbG9ja2VkUmVzaWR1ZVBhaXJzLmhhcyhyZXNpZHVlUGFpcktleSkpIHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBNYXAobG9ja2VkUmVzaWR1ZVBhaXJzKTtcbiAgICAgIHJlc3VsdC5zZXQocmVzaWR1ZVBhaXJLZXksIHNvcnRlZFJlc2lkdWVzKTtcbiAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICBsb2NrZWRSZXNpZHVlUGFpcnM6IHJlc3VsdCxcbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcblxuICBwcm90ZWN0ZWQgb25DbGVhckFsbFJlc2lkdWVzID0gKCkgPT4ge1xuICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgY2FuZGlkYXRlUmVzaWR1ZXM6IG5ldyBBcnJheTxSRVNJRFVFX1RZUEU+KCksXG4gICAgICBob3ZlcmVkUmVzaWR1ZXM6IG5ldyBBcnJheTxSRVNJRFVFX1RZUEU+KCksXG4gICAgICBsb2NrZWRSZXNpZHVlUGFpcnM6IG5ldyBNYXAoKSxcbiAgICB9KTtcbiAgfTtcblxuICBwcm90ZWN0ZWQgb25SZW1vdmVBbGxMb2NrZWRSZXNpZHVlUGFpcnMgPSAoKSA9PiB7XG4gICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICBsb2NrZWRSZXNpZHVlUGFpcnM6IG5ldyBNYXAoKSxcbiAgICB9KTtcbiAgfTtcblxuICBwcm90ZWN0ZWQgb25SZW1vdmVDYW5kaWRhdGVSZXNpZHVlID0gKCkgPT4ge1xuICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgY2FuZGlkYXRlUmVzaWR1ZXM6IG5ldyBBcnJheTxSRVNJRFVFX1RZUEU+KCksXG4gICAgfSk7XG4gIH07XG5cbiAgcHJvdGVjdGVkIG9uUmVtb3ZlSG92ZXJlZFJlc2lkdWVzID0gKCkgPT4ge1xuICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgaG92ZXJlZFJlc2lkdWVzOiBuZXcgQXJyYXk8UkVTSURVRV9UWVBFPigpLFxuICAgIH0pO1xuICB9O1xuXG4gIHByb3RlY3RlZCBvblJlbW92ZUxvY2tlZFJlc2lkdWVQYWlyID0gKHJlc2lkdWVzOiBSRVNJRFVFX1RZUEVbXSkgPT4ge1xuICAgIGNvbnN0IHJlc2lkdWVQYWlyS2V5ID0gcmVzaWR1ZXMuc29ydCgpLmpvaW4oJywnKTtcbiAgICBjb25zdCB7IGxvY2tlZFJlc2lkdWVQYWlycyB9ID0gdGhpcy5zdGF0ZTtcbiAgICBpZiAobG9ja2VkUmVzaWR1ZVBhaXJzLmhhcyhyZXNpZHVlUGFpcktleSkpIHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBNYXAobG9ja2VkUmVzaWR1ZVBhaXJzKTtcbiAgICAgIHJlc3VsdC5kZWxldGUocmVzaWR1ZVBhaXJLZXkpO1xuICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgIGxvY2tlZFJlc2lkdWVQYWlyczogcmVzdWx0LFxuICAgICAgfSk7XG4gICAgfVxuICB9O1xuXG4gIHByb3RlY3RlZCBvblJlbW92ZU5vbkxvY2tlZFJlc2lkdWVzID0gKCkgPT4ge1xuICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgY2FuZGlkYXRlUmVzaWR1ZXM6IG5ldyBBcnJheTxSRVNJRFVFX1RZUEU+KCksXG4gICAgICBob3ZlcmVkUmVzaWR1ZXM6IG5ldyBBcnJheTxSRVNJRFVFX1RZUEU+KCksXG4gICAgfSk7XG4gIH07XG5cbiAgcHJvdGVjdGVkIG9uVG9nZ2xlTG9ja2VkUmVzaWR1ZVBhaXIgPSAocmVzaWR1ZXM6IFJFU0lEVUVfVFlQRVtdKSA9PiB7XG4gICAgY29uc3QgeyBsb2NrZWRSZXNpZHVlUGFpcnMgfSA9IHRoaXMuc3RhdGU7XG4gICAgY29uc3Qgc29ydGVkUmVzaWR1ZXMgPSByZXNpZHVlcy5zb3J0KCk7XG4gICAgY29uc3QgcmVzaWR1ZVBhaXJLZXkgPSBzb3J0ZWRSZXNpZHVlcy50b1N0cmluZygpO1xuICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBNYXAobG9ja2VkUmVzaWR1ZVBhaXJzKTtcbiAgICBpZiAoIWxvY2tlZFJlc2lkdWVQYWlycy5oYXMocmVzaWR1ZVBhaXJLZXkpKSB7XG4gICAgICByZXN1bHQuc2V0KHJlc2lkdWVQYWlyS2V5LCBzb3J0ZWRSZXNpZHVlcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdC5kZWxldGUocmVzaWR1ZVBhaXJLZXkpO1xuICAgIH1cbiAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgIGxvY2tlZFJlc2lkdWVQYWlyczogcmVzdWx0LFxuICAgIH0pO1xuICB9O1xufVxuIiwiLy8gdHNsaW50OmRpc2FibGU6bWF4LWNsYXNzZXMtcGVyLWZpbGVcbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcblxuaW1wb3J0IHsgU0VDT05EQVJZX1NUUlVDVFVSRV9TRUNUSU9OIH0gZnJvbSAnfmNoZWxsLXZpen4vZGF0YSc7XG5cbmV4cG9ydCBjb25zdCBpbml0aWFsU2Vjb25kYXJ5U3RydWN0Q29udGV4dFJlYWQgPSB7XG4gIGhvdmVyZWRTZWNvbmRhcnlTdHJ1Y3R1cmVzOiBuZXcgQXJyYXk8U0VDT05EQVJZX1NUUlVDVFVSRV9TRUNUSU9OPigpLFxuICBzZWxlY3RlZFNlY29uZGFyeVN0cnVjdHVyZXM6IG5ldyBBcnJheTxTRUNPTkRBUllfU1RSVUNUVVJFX1NFQ1RJT04+KCksXG59O1xuXG5leHBvcnQgY29uc3QgaW5pdGlhbFNlY29uZGFyeVN0cnVjdENvbnRleHRXcml0ZSA9IHtcbiAgYWRkSG92ZXJlZFNlY29uZGFyeVN0cnVjdHVyZTogKHNlY3Rpb246IFNFQ09OREFSWV9TVFJVQ1RVUkVfU0VDVElPTikgPT4ge1xuICAgIHJldHVybjtcbiAgfSxcbiAgYWRkU2VsZWN0ZWRTZWNvbmRhcnlTdHJ1Y3R1cmU6IChzZWN0aW9uOiBTRUNPTkRBUllfU1RSVUNUVVJFX1NFQ1RJT04pID0+IHtcbiAgICByZXR1cm47XG4gIH0sXG4gIGNsZWFyQWxsU2Vjb25kYXJ5U3RydWN0dXJlczogKCkgPT4ge1xuICAgIHJldHVybjtcbiAgfSxcbiAgcmVtb3ZlSG92ZXJlZFNlY29uZGFyeVN0cnVjdHVyZTogKHNlY3Rpb246IFNFQ09OREFSWV9TVFJVQ1RVUkVfU0VDVElPTikgPT4ge1xuICAgIHJldHVybjtcbiAgfSxcbiAgcmVtb3ZlU2Vjb25kYXJ5U3RydWN0dXJlOiAoc2VjdGlvbjogU0VDT05EQVJZX1NUUlVDVFVSRV9TRUNUSU9OKSA9PiB7XG4gICAgcmV0dXJuO1xuICB9LFxufTtcblxuZXhwb3J0IGNvbnN0IGluaXRpYWxTZWNvbmRhcnlTdHJ1Y3R1cmVDb250ZXh0ID0ge1xuICAuLi5pbml0aWFsU2Vjb25kYXJ5U3RydWN0Q29udGV4dFdyaXRlLFxuICAuLi5pbml0aWFsU2Vjb25kYXJ5U3RydWN0Q29udGV4dFJlYWQsXG59O1xuXG5leHBvcnQgaW50ZXJmYWNlIElTZWNvbmRhcnlTdHJ1Y3R1cmVQcm9wcyB7XG4gIHNlY29uZGFyeVN0cnVjdHVyZUNvbnRleHQ6IElTZWNvbmRhcnlTdHJ1Y3R1cmVDb250ZXh0O1xufVxuXG5leHBvcnQgdHlwZSBJU2Vjb25kYXJ5U3RydWN0dXJlQ29udGV4dFJlYWQgPSB0eXBlb2YgaW5pdGlhbFNlY29uZGFyeVN0cnVjdENvbnRleHRSZWFkO1xuZXhwb3J0IHR5cGUgSVNlY29uZGFyeVN0cnVjdHVyZUNvbnRleHRXcml0ZSA9IHR5cGVvZiBpbml0aWFsU2Vjb25kYXJ5U3RydWN0Q29udGV4dFdyaXRlO1xuXG5leHBvcnQgdHlwZSBJU2Vjb25kYXJ5U3RydWN0dXJlQ29udGV4dCA9IElTZWNvbmRhcnlTdHJ1Y3R1cmVDb250ZXh0UmVhZCAmIElTZWNvbmRhcnlTdHJ1Y3R1cmVDb250ZXh0V3JpdGU7XG5cbmV4cG9ydCBjb25zdCBTZWNvbmRhcnlTdHJ1Y3R1cmVDb250ZXh0UmVhZCA9IFJlYWN0LmNyZWF0ZUNvbnRleHQoaW5pdGlhbFNlY29uZGFyeVN0cnVjdENvbnRleHRSZWFkKTtcbmV4cG9ydCBjb25zdCBTZWNvbmRhcnlTdHJ1Y3R1cmVDb250ZXh0V3JpdGUgPSBSZWFjdC5jcmVhdGVDb250ZXh0KGluaXRpYWxTZWNvbmRhcnlTdHJ1Y3RDb250ZXh0V3JpdGUpO1xuZXhwb3J0IGNvbnN0IFNlY29uZGFyeVN0cnVjdHVyZUNvbnRleHQgPSBSZWFjdC5jcmVhdGVDb250ZXh0KGluaXRpYWxTZWNvbmRhcnlTdHJ1Y3R1cmVDb250ZXh0KTtcblxuZXhwb3J0IGNvbnN0IFNlY29uZGFyeVN0cnVjdHVyZUNvbnRleHRSZWFkQ29uc3VtZXIgPSBTZWNvbmRhcnlTdHJ1Y3R1cmVDb250ZXh0UmVhZC5Db25zdW1lcjtcbmV4cG9ydCBjb25zdCBTZWNvbmRhcnlTdHJ1Y3R1cmVDb250ZXh0V3JpdGVDb25zdW1lciA9IFNlY29uZGFyeVN0cnVjdHVyZUNvbnRleHRXcml0ZS5Db25zdW1lcjtcbmV4cG9ydCBjb25zdCBTZWNvbmRhcnlTdHJ1Y3R1cmVDb250ZXh0Q29uc3VtZXIgPSBTZWNvbmRhcnlTdHJ1Y3R1cmVDb250ZXh0LkNvbnN1bWVyO1xuXG5leHBvcnQgY2xhc3MgU2Vjb25kYXJ5U3RydWN0dXJlQ29udGV4dFByb3ZpZGVyIGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50PGFueSwgSVNlY29uZGFyeVN0cnVjdHVyZUNvbnRleHQ+IHtcbiAgcHVibGljIGNvbnN0cnVjdG9yKHByb3BzOiBhbnkpIHtcbiAgICBzdXBlcihwcm9wcyk7XG4gICAgdGhpcy5zdGF0ZSA9IHtcbiAgICAgIGFkZEhvdmVyZWRTZWNvbmRhcnlTdHJ1Y3R1cmU6IHRoaXMub25BZGRIb3ZlcmVkU2Vjb25kYXJ5U3RydWN0dXJlKCksXG4gICAgICBhZGRTZWxlY3RlZFNlY29uZGFyeVN0cnVjdHVyZTogdGhpcy5vbkFkZFNlbGVjdGVkU2Vjb25kYXJ5U3RydWN0dXJlKCksXG4gICAgICBjbGVhckFsbFNlY29uZGFyeVN0cnVjdHVyZXM6IHRoaXMub25DbGVhclNlY29uZGFyeVN0cnVjdHVyZSgpLFxuICAgICAgaG92ZXJlZFNlY29uZGFyeVN0cnVjdHVyZXM6IG5ldyBBcnJheTxTRUNPTkRBUllfU1RSVUNUVVJFX1NFQ1RJT04+KCksXG4gICAgICByZW1vdmVIb3ZlcmVkU2Vjb25kYXJ5U3RydWN0dXJlOiB0aGlzLm9uUmVtb3ZlSG92ZXJlZFNlY29uZGFyeVN0cnVjdHVyZSgpLFxuICAgICAgcmVtb3ZlU2Vjb25kYXJ5U3RydWN0dXJlOiB0aGlzLm9uUmVtb3ZlU2Vjb25kYXJ5U3RydWN0dXJlKCksXG4gICAgICBzZWxlY3RlZFNlY29uZGFyeVN0cnVjdHVyZXM6IG5ldyBBcnJheTxTRUNPTkRBUllfU1RSVUNUVVJFX1NFQ1RJT04+KCksXG4gICAgfTtcbiAgfVxuXG4gIHB1YmxpYyByZW5kZXIoKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIDxTZWNvbmRhcnlTdHJ1Y3R1cmVDb250ZXh0UmVhZC5Qcm92aWRlciB2YWx1ZT17dGhpcy5zdGF0ZX0+XG4gICAgICAgIDxTZWNvbmRhcnlTdHJ1Y3R1cmVDb250ZXh0V3JpdGUuUHJvdmlkZXIgdmFsdWU9e3RoaXMuc3RhdGV9PlxuICAgICAgICAgIDxTZWNvbmRhcnlTdHJ1Y3R1cmVDb250ZXh0LlByb3ZpZGVyIHZhbHVlPXt0aGlzLnN0YXRlfT5cbiAgICAgICAgICAgIHt0aGlzLnByb3BzLmNoaWxkcmVufVxuICAgICAgICAgIDwvU2Vjb25kYXJ5U3RydWN0dXJlQ29udGV4dC5Qcm92aWRlcj5cbiAgICAgICAgPC9TZWNvbmRhcnlTdHJ1Y3R1cmVDb250ZXh0V3JpdGUuUHJvdmlkZXI+XG4gICAgICA8L1NlY29uZGFyeVN0cnVjdHVyZUNvbnRleHRSZWFkLlByb3ZpZGVyPlxuICAgICk7XG4gIH1cblxuICBwcm90ZWN0ZWQgb25BZGRIb3ZlcmVkU2Vjb25kYXJ5U3RydWN0dXJlID0gKCkgPT4gKHNlY3Rpb246IFNFQ09OREFSWV9TVFJVQ1RVUkVfU0VDVElPTikgPT4ge1xuICAgIGlmICghdGhpcy5zdGF0ZS5ob3ZlcmVkU2Vjb25kYXJ5U3RydWN0dXJlcy5pbmNsdWRlcyhzZWN0aW9uKSkge1xuICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgIGhvdmVyZWRTZWNvbmRhcnlTdHJ1Y3R1cmVzOiBbLi4udGhpcy5zdGF0ZS5ob3ZlcmVkU2Vjb25kYXJ5U3RydWN0dXJlcywgc2VjdGlvbl0sXG4gICAgICB9KTtcbiAgICB9XG4gIH07XG5cbiAgcHJvdGVjdGVkIG9uQWRkU2VsZWN0ZWRTZWNvbmRhcnlTdHJ1Y3R1cmUgPSAoKSA9PiAoc2VjdGlvbjogU0VDT05EQVJZX1NUUlVDVFVSRV9TRUNUSU9OKSA9PiB7XG4gICAgaWYgKCF0aGlzLnN0YXRlLnNlbGVjdGVkU2Vjb25kYXJ5U3RydWN0dXJlcy5pbmNsdWRlcyhzZWN0aW9uKSkge1xuICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgIHNlbGVjdGVkU2Vjb25kYXJ5U3RydWN0dXJlczogWy4uLnRoaXMuc3RhdGUuc2VsZWN0ZWRTZWNvbmRhcnlTdHJ1Y3R1cmVzLCBzZWN0aW9uXSxcbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcblxuICBwcm90ZWN0ZWQgb25DbGVhclNlY29uZGFyeVN0cnVjdHVyZSA9ICgpID0+ICgpID0+IHtcbiAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgIGhvdmVyZWRTZWNvbmRhcnlTdHJ1Y3R1cmVzOiBuZXcgQXJyYXk8U0VDT05EQVJZX1NUUlVDVFVSRV9TRUNUSU9OPigpLFxuICAgICAgc2VsZWN0ZWRTZWNvbmRhcnlTdHJ1Y3R1cmVzOiBuZXcgQXJyYXk8U0VDT05EQVJZX1NUUlVDVFVSRV9TRUNUSU9OPigpLFxuICAgIH0pO1xuICB9O1xuXG4gIHByb3RlY3RlZCBvblJlbW92ZUhvdmVyZWRTZWNvbmRhcnlTdHJ1Y3R1cmUgPSAoKSA9PiAoc2VjdGlvblRvUmVtb3ZlOiBTRUNPTkRBUllfU1RSVUNUVVJFX1NFQ1RJT04pID0+IHtcbiAgICBjb25zdCBwcmV2SW5kZXggPSB0aGlzLnN0YXRlLmhvdmVyZWRTZWNvbmRhcnlTdHJ1Y3R1cmVzLmZpbmRJbmRleChcbiAgICAgIHNlY3Rpb24gPT5cbiAgICAgICAgc2VjdGlvbi5sYWJlbCA9PT0gc2VjdGlvblRvUmVtb3ZlLmxhYmVsICYmXG4gICAgICAgIHNlY3Rpb24uc3RhcnQgPT09IHNlY3Rpb25Ub1JlbW92ZS5zdGFydCAmJlxuICAgICAgICBzZWN0aW9uLmVuZCA9PT0gc2VjdGlvblRvUmVtb3ZlLmVuZCxcbiAgICApO1xuICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgaG92ZXJlZFNlY29uZGFyeVN0cnVjdHVyZXM6IFtcbiAgICAgICAgLi4udGhpcy5zdGF0ZS5ob3ZlcmVkU2Vjb25kYXJ5U3RydWN0dXJlcy5zcGxpY2UoMCwgcHJldkluZGV4KSxcbiAgICAgICAgLi4udGhpcy5zdGF0ZS5ob3ZlcmVkU2Vjb25kYXJ5U3RydWN0dXJlcy5zcGxpY2UocHJldkluZGV4ICsgMSksXG4gICAgICBdLFxuICAgIH0pO1xuICB9O1xuXG4gIHByb3RlY3RlZCBvblJlbW92ZVNlY29uZGFyeVN0cnVjdHVyZSA9ICgpID0+IChzZWN0aW9uVG9SZW1vdmU6IFNFQ09OREFSWV9TVFJVQ1RVUkVfU0VDVElPTikgPT4ge1xuICAgIGNvbnN0IHByZXZTZWxlY3RlZEluZGV4ID0gdGhpcy5zdGF0ZS5zZWxlY3RlZFNlY29uZGFyeVN0cnVjdHVyZXMuZmluZEluZGV4KFxuICAgICAgc2VjdGlvbiA9PlxuICAgICAgICBzZWN0aW9uLmxhYmVsID09PSBzZWN0aW9uVG9SZW1vdmUubGFiZWwgJiZcbiAgICAgICAgc2VjdGlvbi5zdGFydCA9PT0gc2VjdGlvblRvUmVtb3ZlLnN0YXJ0ICYmXG4gICAgICAgIHNlY3Rpb24uZW5kID09PSBzZWN0aW9uVG9SZW1vdmUuZW5kLFxuICAgICk7XG4gICAgY29uc3QgcHJldkhvdmVyZWRJbmRleCA9IHRoaXMuc3RhdGUuaG92ZXJlZFNlY29uZGFyeVN0cnVjdHVyZXMuZmluZEluZGV4KFxuICAgICAgc2VjdGlvbiA9PlxuICAgICAgICBzZWN0aW9uLmxhYmVsID09PSBzZWN0aW9uVG9SZW1vdmUubGFiZWwgJiZcbiAgICAgICAgc2VjdGlvbi5zdGFydCA9PT0gc2VjdGlvblRvUmVtb3ZlLnN0YXJ0ICYmXG4gICAgICAgIHNlY3Rpb24uZW5kID09PSBzZWN0aW9uVG9SZW1vdmUuZW5kLFxuICAgICk7XG4gICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICBob3ZlcmVkU2Vjb25kYXJ5U3RydWN0dXJlczogW1xuICAgICAgICAuLi50aGlzLnN0YXRlLmhvdmVyZWRTZWNvbmRhcnlTdHJ1Y3R1cmVzLnNwbGljZSgwLCBwcmV2SG92ZXJlZEluZGV4KSxcbiAgICAgICAgLi4udGhpcy5zdGF0ZS5ob3ZlcmVkU2Vjb25kYXJ5U3RydWN0dXJlcy5zcGxpY2UocHJldkhvdmVyZWRJbmRleCArIDEpLFxuICAgICAgXSxcbiAgICAgIHNlbGVjdGVkU2Vjb25kYXJ5U3RydWN0dXJlczogW1xuICAgICAgICAuLi50aGlzLnN0YXRlLnNlbGVjdGVkU2Vjb25kYXJ5U3RydWN0dXJlcy5zcGxpY2UoMCwgcHJldlNlbGVjdGVkSW5kZXgpLFxuICAgICAgICAuLi50aGlzLnN0YXRlLnNlbGVjdGVkU2Vjb25kYXJ5U3RydWN0dXJlcy5zcGxpY2UocHJldlNlbGVjdGVkSW5kZXggKyAxKSxcbiAgICAgIF0sXG4gICAgfSk7XG4gIH07XG59XG4iLCJpbXBvcnQgeyBTZXQgfSBmcm9tICdpbW11dGFibGUnO1xuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xuXG5pbXBvcnQgeyBDRUxMX1RZUEUsIElTcHJpbmdOb2RlIH0gZnJvbSAnfmNoZWxsLXZpen4vZGF0YSc7XG5pbXBvcnQgeyBmZXRjaFNwcmluZ0RhdGEgfSBmcm9tICd+Y2hlbGwtdml6fi9oZWxwZXInO1xuXG5leHBvcnQgY29uc3QgaW5pdGlhbFNwcmluZ0NvbnRleHQgPSB7XG4gIGFkZExhYmVsOiAobGFiZWw6IHN0cmluZykgPT4ge1xuICAgIHJldHVybjtcbiAgfSxcbiAgYWRkTGFiZWxzOiAobGFiZWxzOiBzdHJpbmdbXSkgPT4ge1xuICAgIHJldHVybjtcbiAgfSxcbiAgY2F0ZWdvcmllczogU2V0PHN0cmluZz4oKSxcbiAgY2hhbmdlQ2F0ZWdvcnk6IChzZWxlY3RlZENhdGVnb3J5OiBzdHJpbmcpID0+IHtcbiAgICByZXR1cm47XG4gIH0sXG4gIGN1cnJlbnRDZWxsczogU2V0PENFTExfVFlQRT4oKSxcbiAgZ3JhcGhEYXRhOiB7IG5vZGVzOiBuZXcgQXJyYXk8SVNwcmluZ05vZGU+KCkgfSxcbiAgbGFiZWxzQnlDYXRlZ29yeTogbmV3IE1hcDxzdHJpbmcsIFNldDxzdHJpbmc+PigpLFxuICByZW1vdmVBbGxDZWxsczogKCkgPT4ge1xuICAgIHJldHVybjtcbiAgfSxcbiAgcmVtb3ZlQ2VsbHM6IChjZWxsczogQ0VMTF9UWVBFW10pID0+IHtcbiAgICByZXR1cm47XG4gIH0sXG4gIHJlbW92ZUxhYmVsOiAobGFiZWw6IHN0cmluZykgPT4ge1xuICAgIHJldHVybjtcbiAgfSxcbiAgcmVtb3ZlTGFiZWxzOiAobGFiZWxzOiBzdHJpbmdbXSkgPT4ge1xuICAgIHJldHVybjtcbiAgfSxcbiAgc2VsZWN0ZWRDYXRlZ29yeTogJycsXG4gIHNlbGVjdGVkTGFiZWxzOiBTZXQ8c3RyaW5nPigpLFxuICBzZXRDZWxsczogKGNlbGxzOiBDRUxMX1RZUEVbXSkgPT4ge1xuICAgIHJldHVybjtcbiAgfSxcbiAgdG9nZ2xlTGFiZWxzOiAobGFiZWxzOiBzdHJpbmdbXSkgPT4ge1xuICAgIHJldHVybjtcbiAgfSxcbiAgdXBkYXRlOiAoY2VsbHM6IENFTExfVFlQRVtdLCBzZWxlY3RlZENhdGVnb3J5Pzogc3RyaW5nLCBsYWJlbD86IHN0cmluZykgPT4ge1xuICAgIHJldHVybjtcbiAgfSxcbn07XG5cbmV4cG9ydCB0eXBlIElTcHJpbmdDb250ZXh0ID0gdHlwZW9mIGluaXRpYWxTcHJpbmdDb250ZXh0O1xuXG5leHBvcnQgdHlwZSBTcHJpbmdDb250ZXh0U3RhdGUgPSBSZWFkb25seTx0eXBlb2YgaW5pdGlhbFNwcmluZ0NvbnRleHQ+O1xuXG5leHBvcnQgY29uc3QgU3ByaW5nQ29udGV4dCA9IFJlYWN0LmNyZWF0ZUNvbnRleHQoaW5pdGlhbFNwcmluZ0NvbnRleHQpO1xuXG5leHBvcnQgaW50ZXJmYWNlIElTcHJpbmdDb250ZXh0UHJvcHMge1xuICBkYXRhc2V0TG9jYXRpb24/OiBzdHJpbmc7XG59XG5cbmV4cG9ydCBjbGFzcyBTcHJpbmdDb250ZXh0UHJvdmlkZXIgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQ8SVNwcmluZ0NvbnRleHRQcm9wcywgU3ByaW5nQ29udGV4dFN0YXRlPiB7XG4gIHB1YmxpYyBjb25zdHJ1Y3Rvcihwcm9wczogSVNwcmluZ0NvbnRleHRQcm9wcykge1xuICAgIHN1cGVyKHByb3BzKTtcbiAgICB0aGlzLnN0YXRlID0ge1xuICAgICAgLi4uaW5pdGlhbFNwcmluZ0NvbnRleHQsXG4gICAgICBhZGRMYWJlbDogdGhpcy5vbkFkZExhYmVsLFxuICAgICAgYWRkTGFiZWxzOiB0aGlzLm9uQWRkTGFiZWxzLFxuICAgICAgY2hhbmdlQ2F0ZWdvcnk6IHRoaXMub25DaGFuZ2VDYXRlZ29yeSxcbiAgICAgIHJlbW92ZUFsbENlbGxzOiB0aGlzLm9uUmVtb3ZlQWxsQ2VsbHMsXG4gICAgICByZW1vdmVDZWxsczogdGhpcy5vblJlbW92ZUNlbGxzLFxuICAgICAgcmVtb3ZlTGFiZWw6IHRoaXMub25SZW1vdmVMYWJlbCxcbiAgICAgIHJlbW92ZUxhYmVsczogdGhpcy5vblJlbW92ZUxhYmVscyxcbiAgICAgIHNldENlbGxzOiB0aGlzLm9uU2V0Q2VsbHMsXG4gICAgICB0b2dnbGVMYWJlbHM6IHRoaXMub25Ub2dnbGVMYWJlbHMsXG4gICAgICB1cGRhdGU6IHRoaXMub25VcGRhdGUsXG4gICAgfTtcbiAgfVxuXG4gIHB1YmxpYyBhc3luYyBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICBhd2FpdCB0aGlzLnNldHVwRGF0YSgpO1xuICB9XG5cbiAgcHVibGljIGFzeW5jIGNvbXBvbmVudERpZFVwZGF0ZShwcmV2UHJvcHM6IElTcHJpbmdDb250ZXh0UHJvcHMpIHtcbiAgICBpZiAodGhpcy5wcm9wcy5kYXRhc2V0TG9jYXRpb24gIT09IHByZXZQcm9wcy5kYXRhc2V0TG9jYXRpb24pIHtcbiAgICAgIGF3YWl0IHRoaXMuc2V0dXBEYXRhKCk7XG4gICAgfVxuICB9XG5cbiAgcHVibGljIHJlbmRlcigpIHtcbiAgICByZXR1cm4gPFNwcmluZ0NvbnRleHQuUHJvdmlkZXIgdmFsdWU9e3RoaXMuc3RhdGV9Pnt0aGlzLnByb3BzLmNoaWxkcmVufTwvU3ByaW5nQ29udGV4dC5Qcm92aWRlcj47XG4gIH1cblxuICBwcm90ZWN0ZWQgYXN5bmMgc2V0dXBEYXRhKCkge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBncmFwaERhdGEgPSBhd2FpdCBmZXRjaFNwcmluZ0RhdGEoYGFzc2V0cy9kYXRhc2V0cy8ke3RoaXMucHJvcHMuZGF0YXNldExvY2F0aW9ufWApO1xuICAgICAgY29uc3QgY2F0ZWdvcmllcyA9IFNldDxzdHJpbmc+KFxuICAgICAgICBncmFwaERhdGEubm9kZXMubGVuZ3RoID49IDEgPyBPYmplY3Qua2V5cyhncmFwaERhdGEubm9kZXNbMF0ubGFiZWxGb3JDYXRlZ29yeSkgOiBbXSxcbiAgICAgICk7XG4gICAgICBjb25zdCBsYWJlbHNCeUNhdGVnb3J5ID0gbmV3IE1hcDxzdHJpbmcsIFNldDxzdHJpbmc+PigpO1xuXG4gICAgICBjYXRlZ29yaWVzLmZvckVhY2goY2F0ZWdvcnkgPT4ge1xuICAgICAgICBpZiAoY2F0ZWdvcnkpIHtcbiAgICAgICAgICBjb25zdCBsYWJlbHMgPSBTZXQ8c3RyaW5nPihBcnJheS5mcm9tKGdyYXBoRGF0YS5ub2Rlcy5tYXAobm9kZSA9PiBub2RlLmxhYmVsRm9yQ2F0ZWdvcnlbY2F0ZWdvcnldKSkpO1xuICAgICAgICAgIGxhYmVsc0J5Q2F0ZWdvcnkuc2V0KGNhdGVnb3J5LCBsYWJlbHMpO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgIGNhdGVnb3JpZXMsXG4gICAgICAgIGdyYXBoRGF0YSxcbiAgICAgICAgbGFiZWxzQnlDYXRlZ29yeSxcbiAgICAgIH0pO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGNvbnNvbGUubG9nKGUpO1xuICAgIH1cbiAgfVxuXG4gIHByb3RlY3RlZCBkZXJpdmVDdXJyZW50Q2VsbHNGcm9tTGFiZWxzID0gKHNlbGVjdGVkTGFiZWxzOiBTZXQ8c3RyaW5nPikgPT4ge1xuICAgIGNvbnN0IHsgY2F0ZWdvcmllcywgZ3JhcGhEYXRhLCBsYWJlbHNCeUNhdGVnb3J5IH0gPSB0aGlzLnN0YXRlO1xuICAgIGxldCB2YWxpZENhdGVnb3JpZXMgPSBTZXQ8c3RyaW5nPigpO1xuICAgIHNlbGVjdGVkTGFiZWxzLmZvckVhY2gobGFiZWwgPT4ge1xuICAgICAgaWYgKGxhYmVsKSB7XG4gICAgICAgIGNhdGVnb3JpZXMuZm9yRWFjaChjYXRlZ29yeSA9PiB7XG4gICAgICAgICAgaWYgKGNhdGVnb3J5KSB7XG4gICAgICAgICAgICBjb25zdCBsYWJlbHMgPSBsYWJlbHNCeUNhdGVnb3J5LmdldChjYXRlZ29yeSk7XG4gICAgICAgICAgICBpZiAobGFiZWxzICYmIGxhYmVscy5pbmNsdWRlcyhsYWJlbCkpIHtcbiAgICAgICAgICAgICAgdmFsaWRDYXRlZ29yaWVzID0gdmFsaWRDYXRlZ29yaWVzLmFkZChjYXRlZ29yeSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGxldCBjZWxsSW5kaWNlcyA9IFNldDxudW1iZXI+KCk7XG4gICAgZm9yIChjb25zdCBub2RlIG9mIGdyYXBoRGF0YS5ub2Rlcykge1xuICAgICAgdmFsaWRDYXRlZ29yaWVzLmZvckVhY2goY2F0ZWdvcnkgPT4ge1xuICAgICAgICBpZiAoY2F0ZWdvcnkgJiYgc2VsZWN0ZWRMYWJlbHMuaW5jbHVkZXMobm9kZS5sYWJlbEZvckNhdGVnb3J5W2NhdGVnb3J5XSkpIHtcbiAgICAgICAgICBjZWxsSW5kaWNlcyA9IGNlbGxJbmRpY2VzLmFkZChub2RlLm51bWJlcik7XG5cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiBjZWxsSW5kaWNlcztcbiAgfTtcblxuICBwcm90ZWN0ZWQgZGVyaXZlVmFsaWRMYWJlbHNGcm9tQ2VsbHMgPSAoY3VycmVudENlbGxzOiBDRUxMX1RZUEVbXSkgPT4ge1xuICAgIGNvbnN0IHsgY2F0ZWdvcmllcywgZ3JhcGhEYXRhIH0gPSB0aGlzLnN0YXRlO1xuICAgIGxldCByZXN1bHQgPSBTZXQ8c3RyaW5nPigpO1xuXG4gICAgZm9yIChjb25zdCBjZWxsSW5kZXggb2YgY3VycmVudENlbGxzKSB7XG4gICAgICBmb3IgKGNvbnN0IGNhdGVnb3J5IG9mIGNhdGVnb3JpZXMudG9BcnJheSgpKSB7XG4gICAgICAgIHJlc3VsdCA9IHJlc3VsdC5hZGQoZ3JhcGhEYXRhLm5vZGVzW2NlbGxJbmRleF0ubGFiZWxGb3JDYXRlZ29yeVtjYXRlZ29yeV0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgcHJvdGVjdGVkIG9uQWRkTGFiZWwgPSAobGFiZWw6IHN0cmluZykgPT4ge1xuICAgIGNvbnN0IHsgc2VsZWN0ZWRMYWJlbHMgfSA9IHRoaXMuc3RhdGU7XG4gICAgaWYgKCFzZWxlY3RlZExhYmVscy5pbmNsdWRlcyhsYWJlbCkpIHtcbiAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICBzZWxlY3RlZExhYmVsczogc2VsZWN0ZWRMYWJlbHMuYWRkKGxhYmVsKSxcbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcblxuICBwcm90ZWN0ZWQgb25BZGRMYWJlbHMgPSAobGFiZWxzOiBzdHJpbmdbXSkgPT4ge1xuICAgIGxldCB7IHNlbGVjdGVkTGFiZWxzIH0gPSB0aGlzLnN0YXRlO1xuICAgIGZvciAoY29uc3QgbGFiZWwgb2YgbGFiZWxzKSB7XG4gICAgICBpZiAoIXNlbGVjdGVkTGFiZWxzLmluY2x1ZGVzKGxhYmVsKSkge1xuICAgICAgICBzZWxlY3RlZExhYmVscyA9IHNlbGVjdGVkTGFiZWxzLmFkZChsYWJlbCk7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuc2V0U3RhdGUoeyBzZWxlY3RlZExhYmVscyB9KTtcbiAgfTtcblxuICBwcm90ZWN0ZWQgb25DaGFuZ2VDYXRlZ29yeSA9IChzZWxlY3RlZENhdGVnb3J5OiBzdHJpbmcpID0+IHtcbiAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgIHNlbGVjdGVkQ2F0ZWdvcnksXG4gICAgfSk7XG4gIH07XG5cbiAgcHJvdGVjdGVkIG9uUmVtb3ZlQWxsQ2VsbHMgPSAoKSA9PiB7XG4gICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICBjdXJyZW50Q2VsbHM6IFNldCgpLFxuICAgIH0pO1xuICB9O1xuXG4gIHByb3RlY3RlZCBvblJlbW92ZUNlbGxzID0gKGNlbGxzVG9SZW1vdmU6IENFTExfVFlQRVtdKSA9PiB7XG4gICAgY29uc3QgeyBjdXJyZW50Q2VsbHMgfSA9IHRoaXMuc3RhdGU7XG4gICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICBjdXJyZW50Q2VsbHM6IFNldChjdXJyZW50Q2VsbHMuZmlsdGVyKGNlbGwgPT4gY2VsbCAhPT0gdW5kZWZpbmVkICYmICFjZWxsc1RvUmVtb3ZlLmluY2x1ZGVzKGNlbGwpKSksXG4gICAgfSk7XG4gIH07XG5cbiAgcHJvdGVjdGVkIG9uUmVtb3ZlTGFiZWwgPSAobGFiZWw6IHN0cmluZykgPT4ge1xuICAgIGNvbnN0IHsgc2VsZWN0ZWRMYWJlbHMgfSA9IHRoaXMuc3RhdGU7XG4gICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICBzZWxlY3RlZExhYmVsczogc2VsZWN0ZWRMYWJlbHMucmVtb3ZlKGxhYmVsKSxcbiAgICB9KTtcbiAgfTtcblxuICBwcm90ZWN0ZWQgb25SZW1vdmVMYWJlbHMgPSAobGFiZWxzOiBzdHJpbmdbXSkgPT4ge1xuICAgIGxldCB7IHNlbGVjdGVkTGFiZWxzIH0gPSB0aGlzLnN0YXRlO1xuICAgIGZvciAoY29uc3QgbGFiZWwgb2YgbGFiZWxzKSB7XG4gICAgICBzZWxlY3RlZExhYmVscyA9IHNlbGVjdGVkTGFiZWxzLnJlbW92ZShsYWJlbCk7XG4gICAgfVxuICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgc2VsZWN0ZWRMYWJlbHMsXG4gICAgfSk7XG4gIH07XG5cbiAgcHJvdGVjdGVkIG9uU2V0Q2VsbHMgPSAoY2VsbHM6IENFTExfVFlQRVtdKSA9PiB7XG4gICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICBjdXJyZW50Q2VsbHM6IFNldChjZWxscyksXG4gICAgfSk7XG4gIH07XG5cbiAgcHJvdGVjdGVkIG9uVG9nZ2xlTGFiZWxzID0gKGxhYmVsczogc3RyaW5nW10pID0+IHtcbiAgICBsZXQgeyBzZWxlY3RlZExhYmVscyB9ID0gdGhpcy5zdGF0ZTtcbiAgICBmb3IgKGNvbnN0IGxhYmVsIG9mIGxhYmVscykge1xuICAgICAgc2VsZWN0ZWRMYWJlbHMgPSBzZWxlY3RlZExhYmVscy5pbmNsdWRlcyhsYWJlbCkgPyBzZWxlY3RlZExhYmVscy5yZW1vdmUobGFiZWwpIDogc2VsZWN0ZWRMYWJlbHMuYWRkKGxhYmVsKTtcbiAgICB9XG5cbiAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgIGN1cnJlbnRDZWxsczogdGhpcy5kZXJpdmVDdXJyZW50Q2VsbHNGcm9tTGFiZWxzKHNlbGVjdGVkTGFiZWxzKSxcbiAgICAgIHNlbGVjdGVkTGFiZWxzLFxuICAgIH0pO1xuICB9O1xuXG4gIHByb3RlY3RlZCBvblVwZGF0ZSA9IChjdXJyZW50Q2VsbHM6IENFTExfVFlQRVtdLCBzZWxlY3RlZENhdGVnb3J5Pzogc3RyaW5nKSA9PiB7XG4gICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICBjdXJyZW50Q2VsbHM6IFNldChjdXJyZW50Q2VsbHMpLFxuICAgICAgc2VsZWN0ZWRDYXRlZ29yeTogc2VsZWN0ZWRDYXRlZ29yeSA/IHNlbGVjdGVkQ2F0ZWdvcnkgOiB0aGlzLnN0YXRlLnNlbGVjdGVkQ2F0ZWdvcnksXG4gICAgICBzZWxlY3RlZExhYmVsczogdGhpcy5kZXJpdmVWYWxpZExhYmVsc0Zyb21DZWxscyhjdXJyZW50Q2VsbHMpLFxuICAgIH0pO1xuICB9O1xufVxuIiwiZXhwb3J0ICogZnJvbSAnLi9DaGVsbENvbnRleHRQcm92aWRlcic7XG5leHBvcnQgKiBmcm9tICcuL0NvdXBsaW5nQ29udGV4dCc7XG5leHBvcnQgKiBmcm9tICcuL0dlbmVyaWNDb250ZXh0UHJvdmlkZXInO1xuZXhwb3J0ICogZnJvbSAnLi9SZXNpZHVlQ29udGV4dCc7XG5leHBvcnQgKiBmcm9tICcuL1NlY29uZGFyeVN0cnVjdHVyZUNvbnRleHQnO1xuZXhwb3J0ICogZnJvbSAnLi9TcHJpbmdDb250ZXh0JztcbiIsImltcG9ydCB7IENoZWxsUERCLCBDb3VwbGluZ0NvbnRhaW5lciB9IGZyb20gJ35jaGVsbC12aXp+L2RhdGEnO1xuXG5leHBvcnQgdHlwZSBBTUlOT19BQ0lEX1NJTkdMRV9MRVRURVJfQ09ERSA9XG4gIHwgJ0EnXG4gIHwgJ1InXG4gIHwgJ04nXG4gIHwgJ0QnXG4gIHwgJ0MnXG4gIHwgJ1EnXG4gIHwgJ0UnXG4gIHwgJ0cnXG4gIHwgJ0gnXG4gIHwgJ0knXG4gIHwgJ0wnXG4gIHwgJ0snXG4gIHwgJ00nXG4gIHwgJ0YnXG4gIHwgJ1AnXG4gIHwgJ1MnXG4gIHwgJ1QnXG4gIHwgJ1cnXG4gIHwgJ1knXG4gIHwgJ1YnO1xuXG5leHBvcnQgdHlwZSBBTUlOT19BQ0lEX1RIUkVFX0xFVFRFUl9DT0RFID1cbiAgfCAnQUxBJ1xuICB8ICdBUkcnXG4gIHwgJ0FTTidcbiAgfCAnQVNQJ1xuICB8ICdDWVMnXG4gIHwgJ0dMTidcbiAgfCAnR0xVJ1xuICB8ICdHTFknXG4gIHwgJ0hJUydcbiAgfCAnSUxFJ1xuICB8ICdMRVUnXG4gIHwgJ0xZUydcbiAgfCAnTUVUJ1xuICB8ICdQSEUnXG4gIHwgJ1BSTydcbiAgfCAnU0VSJ1xuICB8ICdUSFInXG4gIHwgJ1RSUCdcbiAgfCAnVFlSJ1xuICB8ICdWQUwnO1xuXG5leHBvcnQgaW50ZXJmYWNlIElBbWlub0FjaWQge1xuICBmdWxsTmFtZTogc3RyaW5nO1xuICB0aHJlZUxldHRlckNvZGU6IEFNSU5PX0FDSURfVEhSRUVfTEVUVEVSX0NPREU7XG4gIHNpbmdsZUxldHRlckNvZGU6IEFNSU5PX0FDSURfU0lOR0xFX0xFVFRFUl9DT0RFO1xufVxuXG5jb25zdCBBbGE6IElBbWlub0FjaWQgPSB7IGZ1bGxOYW1lOiAnQWxhbmluZScsIHNpbmdsZUxldHRlckNvZGU6ICdBJywgdGhyZWVMZXR0ZXJDb2RlOiAnQUxBJyB9O1xuY29uc3QgQXJnOiBJQW1pbm9BY2lkID0geyBmdWxsTmFtZTogJ0FyZ2luaW5lJywgc2luZ2xlTGV0dGVyQ29kZTogJ1InLCB0aHJlZUxldHRlckNvZGU6ICdBUkcnIH07XG5jb25zdCBBc246IElBbWlub0FjaWQgPSB7IGZ1bGxOYW1lOiAnQXNwYXJhZ2luZScsIHNpbmdsZUxldHRlckNvZGU6ICdOJywgdGhyZWVMZXR0ZXJDb2RlOiAnQVNOJyB9O1xuY29uc3QgQXNwOiBJQW1pbm9BY2lkID0geyBmdWxsTmFtZTogJ0FzcGFydGljIEFjaWQnLCBzaW5nbGVMZXR0ZXJDb2RlOiAnRCcsIHRocmVlTGV0dGVyQ29kZTogJ0FTUCcgfTtcbmNvbnN0IEN5czogSUFtaW5vQWNpZCA9IHsgZnVsbE5hbWU6ICdDeXN0ZWluZScsIHNpbmdsZUxldHRlckNvZGU6ICdDJywgdGhyZWVMZXR0ZXJDb2RlOiAnQ1lTJyB9O1xuY29uc3QgR2xuOiBJQW1pbm9BY2lkID0geyBmdWxsTmFtZTogJ0dsdXRhbWluZScsIHNpbmdsZUxldHRlckNvZGU6ICdRJywgdGhyZWVMZXR0ZXJDb2RlOiAnR0xOJyB9O1xuY29uc3QgR2x1OiBJQW1pbm9BY2lkID0geyBmdWxsTmFtZTogJ0dsdXRhbWljIEFjaWQnLCBzaW5nbGVMZXR0ZXJDb2RlOiAnRScsIHRocmVlTGV0dGVyQ29kZTogJ0dMVScgfTtcbmNvbnN0IEdseTogSUFtaW5vQWNpZCA9IHsgZnVsbE5hbWU6ICdHbHljaW5lJywgc2luZ2xlTGV0dGVyQ29kZTogJ0cnLCB0aHJlZUxldHRlckNvZGU6ICdHTFknIH07XG5jb25zdCBIaXM6IElBbWlub0FjaWQgPSB7IGZ1bGxOYW1lOiAnSGlzdGlkaW5lJywgc2luZ2xlTGV0dGVyQ29kZTogJ0gnLCB0aHJlZUxldHRlckNvZGU6ICdISVMnIH07XG5jb25zdCBJbGU6IElBbWlub0FjaWQgPSB7IGZ1bGxOYW1lOiAnSXNvbGV1Y2luZScsIHNpbmdsZUxldHRlckNvZGU6ICdJJywgdGhyZWVMZXR0ZXJDb2RlOiAnSUxFJyB9O1xuY29uc3QgTGV1OiBJQW1pbm9BY2lkID0geyBmdWxsTmFtZTogJ0xldWNpbmUnLCBzaW5nbGVMZXR0ZXJDb2RlOiAnTCcsIHRocmVlTGV0dGVyQ29kZTogJ0xFVScgfTtcbmNvbnN0IEx5czogSUFtaW5vQWNpZCA9IHsgZnVsbE5hbWU6ICdMeXNpbmUnLCBzaW5nbGVMZXR0ZXJDb2RlOiAnSycsIHRocmVlTGV0dGVyQ29kZTogJ0xZUycgfTtcbmNvbnN0IE1ldDogSUFtaW5vQWNpZCA9IHsgZnVsbE5hbWU6ICdNZXRoaW9uaW5lJywgc2luZ2xlTGV0dGVyQ29kZTogJ00nLCB0aHJlZUxldHRlckNvZGU6ICdNRVQnIH07XG5jb25zdCBQaGU6IElBbWlub0FjaWQgPSB7IGZ1bGxOYW1lOiAnUGhlbnlsYWxhbmluZScsIHNpbmdsZUxldHRlckNvZGU6ICdGJywgdGhyZWVMZXR0ZXJDb2RlOiAnUEhFJyB9O1xuY29uc3QgUHJvOiBJQW1pbm9BY2lkID0geyBmdWxsTmFtZTogJ1Byb2xpbmUnLCBzaW5nbGVMZXR0ZXJDb2RlOiAnUCcsIHRocmVlTGV0dGVyQ29kZTogJ1BSTycgfTtcbmNvbnN0IFNlcjogSUFtaW5vQWNpZCA9IHsgZnVsbE5hbWU6ICdTZXJpbmUnLCBzaW5nbGVMZXR0ZXJDb2RlOiAnUycsIHRocmVlTGV0dGVyQ29kZTogJ1NFUicgfTtcbmNvbnN0IFRocjogSUFtaW5vQWNpZCA9IHsgZnVsbE5hbWU6ICdUaHJlb25pbmUnLCBzaW5nbGVMZXR0ZXJDb2RlOiAnVCcsIHRocmVlTGV0dGVyQ29kZTogJ1RIUicgfTtcbmNvbnN0IFRycDogSUFtaW5vQWNpZCA9IHsgZnVsbE5hbWU6ICdUcnlwdG9waGFuJywgc2luZ2xlTGV0dGVyQ29kZTogJ1cnLCB0aHJlZUxldHRlckNvZGU6ICdUUlAnIH07XG5jb25zdCBUeXI6IElBbWlub0FjaWQgPSB7IGZ1bGxOYW1lOiAnVHlyb3NpbmUnLCBzaW5nbGVMZXR0ZXJDb2RlOiAnWScsIHRocmVlTGV0dGVyQ29kZTogJ1RZUicgfTtcbmNvbnN0IFZhbDogSUFtaW5vQWNpZCA9IHsgZnVsbE5hbWU6ICdWYWxpbmUnLCBzaW5nbGVMZXR0ZXJDb2RlOiAnVicsIHRocmVlTGV0dGVyQ29kZTogJ1ZBTCcgfTtcblxuLy8gdHNsaW50OmRpc2FibGU6b2JqZWN0LWxpdGVyYWwtc29ydC1rZXlzXG5leHBvcnQgY29uc3QgQU1JTk9fQUNJRFNfQllfU0lOR0xFX0xFVFRFUl9DT0RFOiB7IFtrZXkgaW4gQU1JTk9fQUNJRF9TSU5HTEVfTEVUVEVSX0NPREVdOiBJQW1pbm9BY2lkIH0gPSB7XG4gIEE6IEFsYSxcbiAgUjogQXJnLFxuICBOOiBBc24sXG4gIEQ6IEFzcCxcbiAgQzogQ3lzLFxuICBROiBHbG4sXG4gIEU6IEdsdSxcbiAgRzogR2x5LFxuICBIOiBIaXMsXG4gIEk6IElsZSxcbiAgTDogTGV1LFxuICBLOiBMeXMsXG4gIE06IE1ldCxcbiAgRjogUGhlLFxuICBQOiBQcm8sXG4gIFM6IFNlcixcbiAgVDogVGhyLFxuICBXOiBUcnAsXG4gIFk6IFR5cixcbiAgVjogVmFsLFxufTtcbi8vIHRzbGludDplbmFibGU6b2JqZWN0LWxpdGVyYWwtc29ydC1rZXlzXG5cbmV4cG9ydCBjb25zdCBBTUlOT19BQ0lEU19CWV9USFJFRV9MRVRURVJfQ09ERTogeyBba2V5IGluIEFNSU5PX0FDSURfVEhSRUVfTEVUVEVSX0NPREVdOiBJQW1pbm9BY2lkIH0gPSB7XG4gIEFMQTogQWxhLFxuICBBUkc6IEFyZyxcbiAgQVNOOiBBc24sXG4gIEFTUDogQXNwLFxuICBDWVM6IEN5cyxcbiAgR0xOOiBHbG4sXG4gIEdMVTogR2x1LFxuICBHTFk6IEdseSxcbiAgSElTOiBIaXMsXG4gIElMRTogSWxlLFxuICBMRVU6IExldSxcbiAgTFlTOiBMeXMsXG4gIE1FVDogTWV0LFxuICBQSEU6IFBoZSxcbiAgUFJPOiBQcm8sXG4gIFNFUjogU2VyLFxuICBUSFI6IFRocixcbiAgVFJQOiBUcnAsXG4gIFRZUjogVHlyLFxuICBWQUw6IFZhbCxcbn07XG5cbmV4cG9ydCBjb25zdCBBTUlOT19BQ0lEUzogSUFtaW5vQWNpZFtdID0gW1xuICBBbGEsXG4gIEFyZyxcbiAgQXNuLFxuICBBc3AsXG4gIEN5cyxcbiAgR2xuLFxuICBHbHUsXG4gIEdseSxcbiAgSGlzLFxuICBJbGUsXG4gIExldSxcbiAgTHlzLFxuICBNZXQsXG4gIFBoZSxcbiAgUHJvLFxuICBTZXIsXG4gIFRocixcbiAgVHJwLFxuICBUeXIsXG4gIFZhbCxcbl07XG5cbmV4cG9ydCBpbnRlcmZhY2UgSVJlc2lkdWVNaXNtYXRjaFJlc3VsdCB7XG4gIGZpcnN0QW1pbm9BY2lkOiBJQW1pbm9BY2lkO1xuICByZXNubzogbnVtYmVyO1xuICBzZWNvbmRBbWlub0FjaWQ6IElBbWlub0FjaWQ7XG59XG5cbmV4cG9ydCBjb25zdCBnZXRQREJBbmRDb3VwbGluZ01pc21hdGNoID0gKHBkYkRhdGE6IENoZWxsUERCLCBjb3VwbGluZ1Njb3JlczogQ291cGxpbmdDb250YWluZXIpID0+IHtcbiAgY29uc3QgcGRiU2VxdWVuY2UgPSBwZGJEYXRhLnNlcXVlbmNlO1xuICBjb25zdCBjb3VwbGluZ1NlcXVlbmNlID0gY291cGxpbmdTY29yZXMuc2VxdWVuY2U7XG4gIGNvbnN0IG1pc21hdGNoZXMgPSBnZXRTZXF1ZW5jZU1pc21hdGNoKHBkYlNlcXVlbmNlLCBjb3VwbGluZ1NlcXVlbmNlKTtcblxuICBpZiAobWlzbWF0Y2hlcy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gcGRiRGF0YS5nZXRSZXNpZHVlTnVtYmVyaW5nTWlzbWF0Y2hlcyhjb3VwbGluZ1Njb3Jlcyk7XG4gIH1cblxuICByZXR1cm4gbWlzbWF0Y2hlcztcbn07XG5cbmV4cG9ydCBjb25zdCBnZXRTZXF1ZW5jZU1pc21hdGNoID0gKGZpcnN0U2VxdWVuY2U6IHN0cmluZywgc2Vjb25kU2VxdWVuY2U6IHN0cmluZykgPT4ge1xuICBjb25zdCBtaXNtYXRjaGVzID0gbmV3IEFycmF5PElSZXNpZHVlTWlzbWF0Y2hSZXN1bHQ+KCk7XG4gIGlmIChmaXJzdFNlcXVlbmNlLmxlbmd0aCA9PT0gc2Vjb25kU2VxdWVuY2UubGVuZ3RoKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBmaXJzdFNlcXVlbmNlLmxlbmd0aDsgKytpKSB7XG4gICAgICBjb25zdCBjb3VwbGluZ0FtaW5vQWNpZCA9IGZpcnN0U2VxdWVuY2VbaV0gYXMgQU1JTk9fQUNJRF9TSU5HTEVfTEVUVEVSX0NPREU7XG4gICAgICBjb25zdCBwZGJBbWlub0FjaWQgPSBzZWNvbmRTZXF1ZW5jZVtpXSBhcyBBTUlOT19BQ0lEX1NJTkdMRV9MRVRURVJfQ09ERTtcbiAgICAgIGlmIChjb3VwbGluZ0FtaW5vQWNpZCAhPT0gcGRiQW1pbm9BY2lkKSB7XG4gICAgICAgIG1pc21hdGNoZXMucHVzaCh7XG4gICAgICAgICAgZmlyc3RBbWlub0FjaWQ6IEFNSU5PX0FDSURTX0JZX1NJTkdMRV9MRVRURVJfQ09ERVtjb3VwbGluZ0FtaW5vQWNpZF0sXG4gICAgICAgICAgcmVzbm86IGksXG4gICAgICAgICAgc2Vjb25kQW1pbm9BY2lkOiBBTUlOT19BQ0lEU19CWV9TSU5HTEVfTEVUVEVSX0NPREVbcGRiQW1pbm9BY2lkXSxcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG1pc21hdGNoZXM7XG59O1xuIiwiLyoqXG4gKiBDbGFzcyB0byBlbmNhcHN1bGF0ZSBhIDEgRGltZW5zaW9uYWwgZGF0YSBzZWdtZW50LlxuICogVGhpcyBpcyBkZWZpbmVkIGFzIGEgbnVtZXJpY2FsIHJhbmdlIHdpdGggaW5jbHVzaXZlIHN0YXJ0LCBpbmNsdXNpdmUgZW5kLCBhbmQgbGFiZWwgYXNzb2NpYXRlZCB3aXRoIGl0LlxuICogQWRkaXRpb25hbGx5LCBhIFNlY3Rpb24gaXMgZGVmaW5lZCBzdWNoIHRoYXQgW3N0YXJ0IDw9IGVuZF0gLSBtZWFuaW5nIHZhbHVlcyB3aWxsIGJlIGZsaXBwZWQgdG8ga2VlcCB0aGlzIGNvbnN0cmFpbnQuXG4gKlxuICogQGV4cG9ydFxuICovXG5leHBvcnQgY2xhc3MgQ2hlbGwxRFNlY3Rpb248VD4ge1xuICBwcm90ZWN0ZWQgc2VjdGlvbkVuZDogbnVtYmVyID0gMDtcbiAgcHJvdGVjdGVkIHNlY3Rpb25TdGFydDogbnVtYmVyID0gMDtcblxuICBwdWJsaWMgZ2V0IGVuZCgpIHtcbiAgICByZXR1cm4gdGhpcy5zZWN0aW9uRW5kO1xuICB9XG5cbiAgcHVibGljIGdldCBsZW5ndGgoKSB7XG4gICAgcmV0dXJuIHRoaXMuc2VjdGlvbkVuZCAtIHRoaXMuc2VjdGlvblN0YXJ0ICsgMTtcbiAgfVxuXG4gIHB1YmxpYyBnZXQgc3RhcnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuc2VjdGlvblN0YXJ0O1xuICB9XG5cbiAgcHVibGljIGNvbnN0cnVjdG9yKHJlYWRvbmx5IGxhYmVsOiBULCBzdGFydDogbnVtYmVyLCBlbmQ6IG51bWJlciA9IHN0YXJ0KSB7XG4gICAgdGhpcy5zZWN0aW9uRW5kID0gTWF0aC5tYXgoZW5kLCBzdGFydCk7XG4gICAgdGhpcy5zZWN0aW9uU3RhcnQgPSBNYXRoLm1pbihzdGFydCwgZW5kKTtcbiAgfVxuXG4gIHB1YmxpYyBjb250YWlucyguLi52YWx1ZXM6IG51bWJlcltdKSB7XG4gICAgZm9yIChjb25zdCB2YWx1ZSBvZiB2YWx1ZXMpIHtcbiAgICAgIGlmICh2YWx1ZSA8IHRoaXMuc2VjdGlvblN0YXJ0IHx8IHZhbHVlID4gdGhpcy5zZWN0aW9uRW5kIHx8IHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgcHVibGljIHVwZGF0ZVN0YXJ0KG5ld051bTogbnVtYmVyKSB7XG4gICAgaWYgKG5ld051bSA+IHRoaXMuc2VjdGlvbkVuZCkge1xuICAgICAgdGhpcy5zZWN0aW9uU3RhcnQgPSB0aGlzLnNlY3Rpb25FbmQ7XG4gICAgICB0aGlzLnNlY3Rpb25FbmQgPSBuZXdOdW07XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc2VjdGlvblN0YXJ0ID0gbmV3TnVtO1xuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyB1cGRhdGVFbmQobmV3TnVtOiBudW1iZXIpIHtcbiAgICBpZiAobmV3TnVtIDwgdGhpcy5zZWN0aW9uU3RhcnQpIHtcbiAgICAgIHRoaXMuc2VjdGlvbkVuZCA9IHRoaXMuc2VjdGlvblN0YXJ0O1xuICAgICAgdGhpcy5zZWN0aW9uU3RhcnQgPSBuZXdOdW07XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc2VjdGlvbkVuZCA9IG5ld051bTtcbiAgICB9XG4gIH1cbn1cbiIsImltcG9ydCB7IEJ1dHRvblByb3BzLCBTZW1hbnRpY0lDT05TIH0gZnJvbSAnc2VtYW50aWMtdWktcmVhY3QnO1xuXG5leHBvcnQgZW51bSBDT05GSUdVUkFUSU9OX0NPTVBPTkVOVF9UWVBFIHtcbiAgQlVUVE9OID0gJ0JVVFRPTicsXG4gIExBQkVMID0gJ0xBQkVMJyxcbiAgUkFESU8gPSAnUkFESU8nLFxuICBTTElERVIgPSAnU0xJREVSJyxcbn1cblxuZXhwb3J0IGludGVyZmFjZSBJQmFzZUNoZWxsV2lkZ2V0Q29uZmlnIHtcbiAgaWNvbj86IFNlbWFudGljSUNPTlM7XG4gIGlkPzogc3RyaW5nO1xuICBuYW1lOiBzdHJpbmc7XG4gIHN0eWxlPzogUmVhY3QuQ1NTUHJvcGVydGllcztcbiAgb25DaGFuZ2U/KC4uLmFyZ3M6IGFueSk6IGFueTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBJQ2hlbGxXaWRnZXRWYWx1ZUNvbmZpZyB7XG4gIHZhbHVlczoge1xuICAgIGN1cnJlbnQ6IG51bWJlcjtcbiAgICBtYXg6IG51bWJlcjtcbiAgICBtaW46IG51bWJlcjtcbiAgfTtcbiAgb25DaGFuZ2U/KC4uLmFyZ3M6IGFueSk6IGFueTtcbiAgb25BZnRlckNoYW5nZT8oLi4uYXJnczogYW55KTogYW55O1xufVxuXG5leHBvcnQgdHlwZSBCdXR0b25XaWRnZXRDb25maWcgPSBJQmFzZUNoZWxsV2lkZ2V0Q29uZmlnICZcbiAgKHtcbiAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bm8tcmVzZXJ2ZWQta2V5d29yZHNcbiAgICB0eXBlOiBDT05GSUdVUkFUSU9OX0NPTVBPTkVOVF9UWVBFLkJVVFRPTjtcbiAgICBvbkNsaWNrKGV2ZW50OiBSZWFjdC5Nb3VzZUV2ZW50PEhUTUxCdXR0b25FbGVtZW50PiwgZGF0YTogQnV0dG9uUHJvcHMpOiB2b2lkO1xuICB9KTtcblxuZXhwb3J0IHR5cGUgTGFiZWxXaWRnZXRDb25maWcgPSBJQmFzZUNoZWxsV2lkZ2V0Q29uZmlnICZcbiAgKHtcbiAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bm8tcmVzZXJ2ZWQta2V5d29yZHNcbiAgICB0eXBlOiBDT05GSUdVUkFUSU9OX0NPTVBPTkVOVF9UWVBFLkxBQkVMO1xuICB9KTtcblxuZXhwb3J0IHR5cGUgUmFkaW9XaWRnZXRDb25maWcgPSBJQmFzZUNoZWxsV2lkZ2V0Q29uZmlnICZcbiAgKHtcbiAgICBjdXJyZW50OiBzdHJpbmc7XG4gICAgb3B0aW9uczogc3RyaW5nW107XG4gICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm5vLXJlc2VydmVkLWtleXdvcmRzXG4gICAgdHlwZTogQ09ORklHVVJBVElPTl9DT01QT05FTlRfVFlQRS5SQURJTztcbiAgfSk7XG5cbmV4cG9ydCB0eXBlIFNsaWRlcldpZGdldENvbmZpZyA9IElCYXNlQ2hlbGxXaWRnZXRDb25maWcgJlxuICBJQ2hlbGxXaWRnZXRWYWx1ZUNvbmZpZyAmXG4gICh7XG4gICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm5vLXJlc2VydmVkLWtleXdvcmRzXG4gICAgdHlwZTogQ09ORklHVVJBVElPTl9DT01QT05FTlRfVFlQRS5TTElERVI7XG4gIH0pO1xuXG5leHBvcnQgdHlwZSBDaGVsbFdpZGdldENvbmZpZyA9IEJ1dHRvbldpZGdldENvbmZpZyB8IFJhZGlvV2lkZ2V0Q29uZmlnIHwgU2xpZGVyV2lkZ2V0Q29uZmlnIHwgTGFiZWxXaWRnZXRDb25maWc7XG5cbi8vIFRoaXMgaXMgdG8gYWxsb3cgY29tcG9uZW50cyB0byB1c2UgYSBkaXJlY3QgaGVpZ2h0L3dpZHRoIHByb3AgYW5kIG5vdCBnZXQgdGhlIHR3byBtaXhlZCB1cC5cbmV4cG9ydCB0eXBlIENIRUxMX0NTU19TVFlMRSA9IE9taXQ8UmVhY3QuQ1NTUHJvcGVydGllcywgJ2hlaWdodCcgfCAnd2lkdGgnPjtcbiIsIi8vIFR5cGUgZGVmaW5pdGlvbnMgZm9yIENoZWxsIFZpc3VhbGl6YXRpb24gTGlicmFyeVxuLy8gUHJvamVjdDogaHR0cHM6Ly9naXRodWIuY29tL2NCaW9DZW50ZXIvY2hlbGwtdml6XG4vLyBEZWZpbml0aW9ucyBieTpcbi8vICAtIGNCaW9DZW50ZXIgQCBEYW5hLUZhcmJlciA8aHR0cHM6Ly9naXRodWIuY29tL2NCaW9DZW50ZXIvPlxuLy8gIC0gSmFtZXMgTGluZHNheSA8aHR0cHM6Ly9naXRodWIuY29tL2ppbS1ibz5cbi8vICAtIE5pY2sgR2F1dGhpZXIgPGh0dHBzOi8vZ2l0aHViLmNvbS9ucGdhdXRoPlxuLy8gIC0gRHJldyBEaWFtYW50b3Vrb3MgPGh0dHBzOi8vZ2l0aHViLmNvbS9NZXJjaWZ1bENvZGU+LFxuLy8gVHlwZVNjcmlwdCBWZXJzaW9uOiAzLjFcbmltcG9ydCB7IFN0cnVjdHVyZSB9IGZyb20gJ25nbCc7XG5cbmltcG9ydCB7XG4gIEFNSU5PX0FDSURfU0lOR0xFX0xFVFRFUl9DT0RFLFxuICBDaGVsbDFEU2VjdGlvbixcbiAgQ2hlbGxQREIsXG4gIENvdXBsaW5nQ29udGFpbmVyLFxuICBJU3ByaW5nR3JhcGhEYXRhLFxufSBmcm9tICd+Y2hlbGwtdml6fi9kYXRhJztcblxuZXhwb3J0IHR5cGUgQ09OVEFDVF9NQVBfREFUQV9UWVBFID0gSUNvbnRhY3RNYXBEYXRhO1xuZXhwb3J0IHR5cGUgTkdMX0RBVEFfVFlQRSA9IFN0cnVjdHVyZTtcbmV4cG9ydCB0eXBlIFNQUklOR19EQVRBX1RZUEUgPSBJU3ByaW5nR3JhcGhEYXRhO1xuZXhwb3J0IHR5cGUgVF9TTkVfREFUQV9UWVBFID0gbnVtYmVyW11bXTtcblxuZXhwb3J0IHR5cGUgQ0hFTExfREFUQV9UWVBFID0gQ09OVEFDVF9NQVBfREFUQV9UWVBFIHwgTkdMX0RBVEFfVFlQRSB8IFNQUklOR19EQVRBX1RZUEUgfCBUX1NORV9EQVRBX1RZUEU7XG5cbi8vIFRPRE8gQmV0dGVyIGRlZmluZSBDZWxsIHR5cGUgdG8gbm90IGJlIGluZGljZXMuXG4vKiogU2hhcmVkIGRhdGEgYmV0d2VlbiBTcHJpbmcvVC1TTkUuIFJlZmVycyB0byBpbmRleCBpbiBwb2ludHMgY29sbGVjdGlvbi4gKi9cbmV4cG9ydCB0eXBlIENFTExfVFlQRSA9IG51bWJlcjtcbmV4cG9ydCB0eXBlIFJFU0lEVUVfVFlQRSA9IG51bWJlcjtcblxuZXhwb3J0IGVudW0gVklaX1RZUEUge1xuICBDT05UQUNUX01BUCA9ICdDb250YWN0IE1hcCcsXG4gIElORk9fUEFORUwgPSAnSW5mbyBQYW5lbCcsXG4gIE5HTCA9ICdOR0wnLFxuICBTUFJJTkcgPSAnU3ByaW5nJyxcbiAgJ1RFTlNPUi1ULVNORScgPSAnVEVOU09SLVQtU05FJyxcbiAgJ1QtU05FJyA9ICdULVNORScsXG4gICdULVNORS1GUkFNRScgPSAnVC1TTkUtRlJBTUUnLFxufVxuXG5leHBvcnQgaW50ZXJmYWNlIElDb250YWN0TWFwRGF0YSB7XG4gIGNvdXBsaW5nU2NvcmVzOiBDb3VwbGluZ0NvbnRhaW5lcjtcbiAgcGRiRGF0YT86IENoZWxsUERCO1xuICBzZWNvbmRhcnlTdHJ1Y3R1cmVzOiBTRUNPTkRBUllfU1RSVUNUVVJFW107XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgSU1vbm9tZXJDb250YWN0IHtcbiAgaTogbnVtYmVyO1xuICBqOiBudW1iZXI7XG4gIGRpc3Q/OiBudW1iZXI7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgSUNvdXBsaW5nU2NvcmUge1xuICBpOiBudW1iZXI7XG4gIEFfaT86IEFNSU5PX0FDSURfU0lOR0xFX0xFVFRFUl9DT0RFO1xuICBqOiBudW1iZXI7XG4gIEFfaj86IEFNSU5PX0FDSURfU0lOR0xFX0xFVFRFUl9DT0RFO1xuICBmbj86IG51bWJlcjtcbiAgY24/OiBudW1iZXI7XG4gIHNlZ21lbnRfaT86IHN0cmluZztcbiAgc2VnbWVudF9qPzogc3RyaW5nO1xuICBwcm9iYWJpbGl0eT86IG51bWJlcjtcbiAgZGlzdF9pbnRyYT86IG51bWJlcjtcbiAgZGlzdF9tdWx0aW1lcj86IG51bWJlcjtcbiAgZGlzdD86IG51bWJlcjtcbiAgcHJlY2lzaW9uPzogbnVtYmVyO1xufVxuXG5leHBvcnQgZW51bSBDT05UQUNUX0RJU1RBTkNFX1BST1hJTUlUWSB7XG4gIENMT1NFU1QgPSAnQ0xPU0VTVCcsXG4gIENfQUxQSEEgPSAnQy3OsScsXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgSVNlY29uZGFyeVN0cnVjdHVyZURhdGEge1xuICByZXNubzogbnVtYmVyO1xuICBzdHJ1Y3RJZDogU0VDT05EQVJZX1NUUlVDVFVSRV9LRVlTO1xufVxuXG5leHBvcnQgdHlwZSBTRUNPTkRBUllfU1RSVUNUVVJFX1NFQ1RJT04gPSBDaGVsbDFEU2VjdGlvbjxTRUNPTkRBUllfU1RSVUNUVVJFX0tFWVM+O1xuZXhwb3J0IHR5cGUgU0VDT05EQVJZX1NUUlVDVFVSRSA9IEFycmF5PENoZWxsMURTZWN0aW9uPFNFQ09OREFSWV9TVFJVQ1RVUkVfS0VZUz4+O1xuXG5leHBvcnQgaW50ZXJmYWNlIElSZXNpZHVlUGFpciB7XG4gIGk6IG51bWJlcjtcbiAgajogbnVtYmVyO1xufVxuXG5leHBvcnQgZW51bSBTRUNPTkRBUllfU1RSVUNUVVJFX0NPREVTIHtcbiAgJ0cnID0gJzMxMF9IRUxJWCcsXG4gICdIJyA9ICdBTFBIQV9IRUxJWCcsXG4gICdJJyA9ICdQSV9IRUxJWCcsXG4gICdUJyA9ICdIWURST0dFTl9CT05ERURfVFVSTicsXG4gICdFJyA9ICdCRVRBX1NIRUVUJyxcbiAgJ0InID0gJ0JFVEFfQlJJREdFJyxcbiAgJ1MnID0gJ0JFTkQnLFxuICAnQycgPSAnQ09JTCcsXG59XG5cbmV4cG9ydCB0eXBlIFNFQ09OREFSWV9TVFJVQ1RVUkVfS0VZUyA9IGtleW9mIHR5cGVvZiBTRUNPTkRBUllfU1RSVUNUVVJFX0NPREVTO1xuXG5leHBvcnQgaW50ZXJmYWNlIElTZWNvbmRhcnlTdHJ1Y3R1cmUge1xuICBjb2RlOiBTRUNPTkRBUllfU1RSVUNUVVJFX0NPREVTO1xuICBuYW1lOiBzdHJpbmc7XG4gIG1pblJlc2lkdWVMZW5ndGg6IG51bWJlcjtcbn1cblxuZXhwb3J0IGVudW0gQ0hFTExfQ0hBUlRfRVZFTlRfVFlQRSB7XG4gIEFGVEVSX1BMT1QsXG4gIENMSUNLLFxuICBET1VCTEVfQ0xJQ0ssXG4gIEhPVkVSLFxuICBSRUxBWU9VVCxcbiAgU0VMRUNUSU9OLFxuICBVTkhPVkVSLFxufVxuXG5leHBvcnQgZW51bSBDSEVMTF9DSEFSVF9QSUVDRSB7XG4gIEFYSVMsXG4gIFBPSU5ULFxufVxuIiwiaW1wb3J0ICogYXMgTkdMIGZyb20gJ25nbCc7XG5cbmltcG9ydCB7XG4gIEFNSU5PX0FDSURfVEhSRUVfTEVUVEVSX0NPREUsXG4gIEFNSU5PX0FDSURTX0JZX1NJTkdMRV9MRVRURVJfQ09ERSxcbiAgQU1JTk9fQUNJRFNfQllfVEhSRUVfTEVUVEVSX0NPREUsXG4gIENoZWxsMURTZWN0aW9uLFxuICBDT05UQUNUX0RJU1RBTkNFX1BST1hJTUlUWSxcbiAgQ291cGxpbmdDb250YWluZXIsXG4gIElDb3VwbGluZ1Njb3JlLFxuICBJUmVzaWR1ZU1pc21hdGNoUmVzdWx0LFxuICBJU2Vjb25kYXJ5U3RydWN0dXJlRGF0YSxcbiAgU0VDT05EQVJZX1NUUlVDVFVSRV9LRVlTLFxuICBTRUNPTkRBUllfU1RSVUNUVVJFX1NFQ1RJT04sXG59IGZyb20gJ35jaGVsbC12aXp+L2RhdGEnO1xuXG4vKipcbiAqIEEgQ2hlbGxQREIgaW5zdGFuY2UgcHJvdmlkZXMgYW4gQVBJIHRvIGludGVyYWN0IHdpdGggYSBsb2FkZWQgUERCIGZpbGUgd2hpbGUgaGlkaW5nIHRoZSBpbXBsZW1lbnRhdGlvbiBkZXRhaWxzIG9mIGhvdyBpdCBpcyBsb2FkZWQuXG4gKlxuICogQGV4cG9ydFxuICovXG5leHBvcnQgY2xhc3MgQ2hlbGxQREIge1xuICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IE5HTF9DX0FMUEhBX0lOREVYID0gJ0NBfEMnO1xuXG4gIHB1YmxpYyBzdGF0aWMgY3JlYXRlRW1wdHlQREIoKSB7XG4gICAgcmV0dXJuIG5ldyBDaGVsbFBEQigpO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgQ2hlbGxQREIgd2l0aCBQREIgZGF0YS5cbiAgICpcbiAgICogIUlNUE9SVEFOVCEgU2luY2UgZmV0Y2hpbmcgdGhlIGRhdGEgaXMgYW4gYXN5bmNocm9ub3VzIGFjdGlvbiwgdGhpcyBtdXN0IGJlIHVzZWQgdG8gY3JlYXRlIGEgbmV3IGluc3RhbmNlIVxuICAgKi9cbiAgcHVibGljIHN0YXRpYyBhc3luYyBjcmVhdGVQREIoZmlsZTogRmlsZSB8IHN0cmluZyA9ICcnKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gbmV3IENoZWxsUERCKCk7XG4gICAgcmVzdWx0Lm5nbERhdGEgPSAoYXdhaXQgTkdMLmF1dG9Mb2FkKGZpbGUpKSBhcyBOR0wuU3RydWN0dXJlO1xuICAgIHJlc3VsdC5maWxlTmFtZSA9IHR5cGVvZiBmaWxlID09PSAnc3RyaW5nJyA/IGZpbGUgOiBmaWxlLm5hbWU7XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgcHVibGljIHN0YXRpYyBjcmVhdGVQREJGcm9tTkdMRGF0YShuZ2xEYXRhOiBOR0wuU3RydWN0dXJlKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gbmV3IENoZWxsUERCKCk7XG4gICAgcmVzdWx0Lm5nbERhdGEgPSBuZ2xEYXRhO1xuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIHByb3RlY3RlZCBjb250YWN0SW5mbz86IENvdXBsaW5nQ29udGFpbmVyO1xuXG4gIHB1YmxpYyBnZXQgY29udGFjdEluZm9ybWF0aW9uKCk6IENvdXBsaW5nQ29udGFpbmVyIHtcbiAgICBpZiAoIXRoaXMuY29udGFjdEluZm8pIHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBDb3VwbGluZ0NvbnRhaW5lcigpO1xuICAgICAgdGhpcy5uZ2xEYXRhLmVhY2hSZXNpZHVlKG91dGVyUmVzaWR1ZSA9PiB7XG4gICAgICAgIGlmIChvdXRlclJlc2lkdWUuaXNQcm90ZWluKCkpIHtcbiAgICAgICAgICBjb25zdCBpID0gb3V0ZXJSZXNpZHVlLnJlc25vO1xuICAgICAgICAgIHRoaXMubmdsRGF0YS5lYWNoUmVzaWR1ZShpbm5lclJlc2lkdWUgPT4ge1xuICAgICAgICAgICAgY29uc3QgaiA9IGlubmVyUmVzaWR1ZS5yZXNubztcbiAgICAgICAgICAgIGlmIChpbm5lclJlc2lkdWUuaXNQcm90ZWluKCkgJiYgaSAhPT0gaikge1xuICAgICAgICAgICAgICByZXN1bHQuYWRkQ291cGxpbmdTY29yZSh7XG4gICAgICAgICAgICAgICAgZGlzdDogdGhpcy5nZXRNaW5EaXN0QmV0d2VlblJlc2lkdWVzKGksIGopLmRpc3QsXG4gICAgICAgICAgICAgICAgaSxcbiAgICAgICAgICAgICAgICBqLFxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICB0aGlzLmNvbnRhY3RJbmZvID0gcmVzdWx0O1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmNvbnRhY3RJbmZvO1xuICB9XG5cbiAgcHVibGljIGdldCBuZ2xTdHJ1Y3R1cmUoKTogTkdMLlN0cnVjdHVyZSB7XG4gICAgcmV0dXJuIHRoaXMubmdsRGF0YTtcbiAgfVxuXG4gIHB1YmxpYyBnZXQgc2Vjb25kYXJ5U3RydWN0dXJlKCk6IElTZWNvbmRhcnlTdHJ1Y3R1cmVEYXRhW10ge1xuICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBBcnJheTxJU2Vjb25kYXJ5U3RydWN0dXJlRGF0YT4oKTtcbiAgICB0aGlzLm5nbERhdGEuZWFjaFJlc2lkdWUocmVzaWR1ZSA9PiB7XG4gICAgICBpZiAocmVzaWR1ZS5pc1Byb3RlaW4oKSkge1xuICAgICAgICBsZXQgc3RydWN0SWQgPSAnQycgYXMgU0VDT05EQVJZX1NUUlVDVFVSRV9LRVlTO1xuICAgICAgICBpZiAocmVzaWR1ZS5pc1NoZWV0KCkpIHtcbiAgICAgICAgICBzdHJ1Y3RJZCA9ICdFJztcbiAgICAgICAgfSBlbHNlIGlmIChyZXNpZHVlLmlzSGVsaXgoKSkge1xuICAgICAgICAgIHN0cnVjdElkID0gJ0gnO1xuICAgICAgICB9IGVsc2UgaWYgKHJlc2lkdWUuaXNUdXJuKCkpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0LnB1c2goeyByZXNubzogcmVzaWR1ZS5yZXNubywgc3RydWN0SWQgfSk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgcHVibGljIGdldCBzZWNvbmRhcnlTdHJ1Y3R1cmVTZWN0aW9ucygpOiBTRUNPTkRBUllfU1RSVUNUVVJFX1NFQ1RJT05bXVtdIHtcbiAgICBjb25zdCByZXN1bHQgPSBuZXcgQXJyYXk8U0VDT05EQVJZX1NUUlVDVFVSRV9TRUNUSU9OW10+KCk7XG4gICAgdGhpcy5uZ2xEYXRhLmVhY2hSZXNpZHVlKHJlc2lkdWUgPT4ge1xuICAgICAgaWYgKHJlc2lkdWUuaXNQcm90ZWluKCkpIHtcbiAgICAgICAgY29uc3QgeyBjaGFpbkluZGV4IH0gPSByZXNpZHVlO1xuICAgICAgICB3aGlsZSAoIXJlc3VsdFtjaGFpbkluZGV4XSkge1xuICAgICAgICAgIHJlc3VsdC5wdXNoKG5ldyBBcnJheTxTRUNPTkRBUllfU1RSVUNUVVJFX1NFQ1RJT04+KCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IHN0cnVjdElkID0gJ0MnIGFzIFNFQ09OREFSWV9TVFJVQ1RVUkVfS0VZUztcbiAgICAgICAgaWYgKHJlc2lkdWUuaXNTaGVldCgpKSB7XG4gICAgICAgICAgc3RydWN0SWQgPSAnRSc7XG4gICAgICAgIH0gZWxzZSBpZiAocmVzaWR1ZS5pc0hlbGl4KCkpIHtcbiAgICAgICAgICBzdHJ1Y3RJZCA9ICdIJztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChyZXN1bHRbY2hhaW5JbmRleF0ubGVuZ3RoID49IDEgJiYgcmVzdWx0W2NoYWluSW5kZXhdW3Jlc3VsdFtjaGFpbkluZGV4XS5sZW5ndGggLSAxXS5sYWJlbCA9PT0gc3RydWN0SWQpIHtcbiAgICAgICAgICByZXN1bHRbY2hhaW5JbmRleF1bcmVzdWx0W2NoYWluSW5kZXhdLmxlbmd0aCAtIDFdLnVwZGF0ZUVuZChyZXNpZHVlLnJlc25vKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXN1bHRbY2hhaW5JbmRleF0ucHVzaChuZXcgQ2hlbGwxRFNlY3Rpb24oc3RydWN0SWQsIHJlc2lkdWUucmVzbm8pKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIHB1YmxpYyBnZXQgbmFtZSgpOiBzdHJpbmcge1xuICAgIGNvbnN0IHNwbGl0TmFtZSA9IHRoaXMuZmlsZU5hbWUuc3BsaXQoJy8nKTtcbiAgICBjb25zdCBsYXN0UGFydCA9IHNwbGl0TmFtZVtzcGxpdE5hbWUubGVuZ3RoIC0gMV07XG5cbiAgICByZXR1cm4gbGFzdFBhcnQuc2xpY2UoMCwgbGFzdFBhcnQubGFzdEluZGV4T2YoJy4nKSk7XG4gIH1cblxuICBwdWJsaWMgZ2V0IHNlcXVlbmNlKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuIHRoaXMubmdsRGF0YSA/IHRoaXMubmdsRGF0YS5nZXRTZXF1ZW5jZSgpLmpvaW4oJycpIDogJyc7XG4gIH1cblxuICBwcm90ZWN0ZWQgZmlsZU5hbWU6IHN0cmluZyA9ICcnO1xuICBwcm90ZWN0ZWQgbmdsRGF0YTogTkdMLlN0cnVjdHVyZSA9IG5ldyBOR0wuU3RydWN0dXJlKCk7XG5cbiAgcHJpdmF0ZSBjb25zdHJ1Y3RvcigpIHt9XG5cbiAgcHVibGljIGVhY2hSZXNpZHVlKGNhbGxiYWNrOiAocmVzaWR1ZTogTkdMLlJlc2lkdWVQcm94eSkgPT4gdm9pZCkge1xuICAgIHRoaXMubmdsRGF0YS5lYWNoUmVzaWR1ZShjYWxsYmFjayk7XG4gIH1cblxuICAvKipcbiAgICogR2l2ZW4gc29tZSBleGlzdGluZyBjb3VwbGluZyBzY29yZXMsIGEgbmV3IENvdXBsaW5nQ29udGFpbmVyIHdpbGwgYmUgY3JlYXRlZCB3aXRoIGRhdGEgYXVnbWVudGVkIHdpdGggaW5mbyBkZXJpdmVkIGZyb20gdGhpcyBQREIuXG4gICAqXG4gICAqIEBwYXJhbSBjb3VwbGluZ1Njb3JlcyBBIGNvbGxlY3Rpb24gb2YgY291cGxpbmcgc2NvcmVzIHRvIGJlIGF1Z21lbnRlZC5cbiAgICogQHBhcmFtIG1lYXN1cmVkUHJveGltaXR5IEhvdyB0byBjYWxjdWxhdGUgdGhlIGRpc3RhbmNlIGJldHdlZW4gdHdvIHJlc2lkdWVzLlxuICAgKiBAcmV0dXJucyBBIENvdXBsaW5nQ29udGFpbmVyIHdpdGggY29udGFjdCBpbmZvcm1hdGlvbiBmcm9tIGJvdGggdGhlIG9yaWdpbmFsIGFycmF5IGFuZCB0aGlzIFBEQiBmaWxlLlxuICAgKi9cbiAgcHVibGljIGFtZW5kUERCV2l0aENvdXBsaW5nU2NvcmVzKGNvdXBsaW5nU2NvcmVzOiBJQ291cGxpbmdTY29yZVtdLCBtZWFzdXJlZFByb3hpbWl0eTogQ09OVEFDVF9ESVNUQU5DRV9QUk9YSU1JVFkpIHtcbiAgICBjb25zdCByZXN1bHQgPSBuZXcgQ291cGxpbmdDb250YWluZXIoY291cGxpbmdTY29yZXMpO1xuICAgIGNvbnN0IGFscGhhSWQgPSB0aGlzLm5nbERhdGEuYXRvbU1hcC5kaWN0W0NoZWxsUERCLk5HTF9DX0FMUEhBX0lOREVYXTtcblxuICAgIGNvbnN0IG1pbkRpc3Q6IHtcbiAgICAgIFtrZXk6IHN0cmluZ106IG51bWJlcjtcbiAgICB9ID0ge307XG5cbiAgICB0aGlzLm5nbERhdGEuZWFjaFJlc2lkdWUob3V0ZXJSZXNpZHVlID0+IHtcbiAgICAgIHRoaXMubmdsRGF0YS5lYWNoUmVzaWR1ZShpbm5lclJlc2lkdWUgPT4ge1xuICAgICAgICBpZiAob3V0ZXJSZXNpZHVlLmlzUHJvdGVpbigpICYmIGlubmVyUmVzaWR1ZS5pc1Byb3RlaW4oKSkge1xuICAgICAgICAgIGlmIChtZWFzdXJlZFByb3hpbWl0eSA9PT0gQ09OVEFDVF9ESVNUQU5DRV9QUk9YSU1JVFkuQ19BTFBIQSkge1xuICAgICAgICAgICAgY29uc3QgZmlyc3RSZXNpZHVlQ0FscGhhSW5kZXggPSB0aGlzLmdldENBbHBoYUF0b21JbmRleEZyb21SZXNpZHVlKG91dGVyUmVzaWR1ZS5pbmRleCwgYWxwaGFJZCk7XG4gICAgICAgICAgICBjb25zdCBzZWNvbmRSZXNpZHVlQ0FscGhhSW5kZXggPSB0aGlzLmdldENBbHBoYUF0b21JbmRleEZyb21SZXNpZHVlKGlubmVyUmVzaWR1ZS5pbmRleCwgYWxwaGFJZCk7XG4gICAgICAgICAgICByZXN1bHQuYWRkQ291cGxpbmdTY29yZSh7XG4gICAgICAgICAgICAgIGRpc3Q6IHRoaXMubmdsRGF0YVxuICAgICAgICAgICAgICAgIC5nZXRBdG9tUHJveHkoZmlyc3RSZXNpZHVlQ0FscGhhSW5kZXgpXG4gICAgICAgICAgICAgICAgLmRpc3RhbmNlVG8odGhpcy5uZ2xEYXRhLmdldEF0b21Qcm94eShzZWNvbmRSZXNpZHVlQ0FscGhhSW5kZXgpKSxcbiAgICAgICAgICAgICAgaTogb3V0ZXJSZXNpZHVlLnJlc25vLFxuICAgICAgICAgICAgICBqOiBpbm5lclJlc2lkdWUucmVzbm8sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc3Qga2V5ID0gYCR7TWF0aC5taW4ob3V0ZXJSZXNpZHVlLnJlc25vLCBpbm5lclJlc2lkdWUucmVzbm8pfSwke01hdGgubWF4KFxuICAgICAgICAgICAgICBvdXRlclJlc2lkdWUucmVzbm8sXG4gICAgICAgICAgICAgIGlubmVyUmVzaWR1ZS5yZXNubyxcbiAgICAgICAgICAgICl9YDtcbiAgICAgICAgICAgIGlmICghbWluRGlzdFtrZXldKSB7XG4gICAgICAgICAgICAgIG1pbkRpc3Rba2V5XSA9IHRoaXMuZ2V0TWluRGlzdEJldHdlZW5SZXNpZHVlSW5kaWNlcyhvdXRlclJlc2lkdWUuaW5kZXgsIGlubmVyUmVzaWR1ZS5pbmRleCkuZGlzdDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmVzdWx0LmFkZENvdXBsaW5nU2NvcmUoe1xuICAgICAgICAgICAgICBkaXN0OiBtaW5EaXN0W2tleV0sXG4gICAgICAgICAgICAgIGk6IG91dGVyUmVzaWR1ZS5yZXNubyxcbiAgICAgICAgICAgICAgajogaW5uZXJSZXNpZHVlLnJlc25vLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcbiAgICB0aGlzLmNvbnRhY3RJbmZvID0gcmVzdWx0O1xuXG4gICAgcmV0dXJuIHRoaXMuY29udGFjdEluZm87XG4gIH1cblxuICAvKipcbiAgICogRmluZCB0aGUgaW5kZXggb2YgdGhlIGMtYWxwaGEgYXRvbSBmb3IgYSBnaXZlbiByZXNpZHVlLlxuICAgKlxuICAgKiBAcGFyYW0gcmVzaWR1ZUluZGV4IEluZGV4IG9mIHRoZSByZXNpZHVlIHRvIGZpbmQgdGhlIGMtYWxwaGEgYXRvbSBmb3IuXG4gICAqIEBwYXJhbSBhbHBoYUlkIEluZGV4IHRoYXQgZGV0ZXJtaW5lcyBpZiBhbiBhdG9tIGlzIGEgYy1hbHBoYS5cbiAgICogQHJldHVybnMgSW5kZXggb2YgdGhlIGMtYWxwaGEgYXRvbSB3aXRoIHJlc3BlY3QgdG8gdGhlIGFycmF5IG9mIGFsbCBvZiB0aGUgYXRvbXMuXG4gICAqL1xuICBwdWJsaWMgZ2V0Q0FscGhhQXRvbUluZGV4RnJvbVJlc2lkdWUocmVzaWR1ZUluZGV4OiBudW1iZXIsIGFscGhhSWQ6IG51bWJlcik6IG51bWJlciB7XG4gICAgY29uc3QgeyByZXNpZHVlU3RvcmUgfSA9IHRoaXMubmdsRGF0YTtcbiAgICBjb25zdCBhdG9tT2Zmc2V0ID0gcmVzaWR1ZVN0b3JlLmF0b21PZmZzZXRbcmVzaWR1ZUluZGV4XTtcbiAgICBjb25zdCBhdG9tQ291bnQgPSByZXNpZHVlU3RvcmUuYXRvbUNvdW50W3Jlc2lkdWVJbmRleF07XG5cbiAgICBsZXQgcmVzdWx0ID0gYXRvbU9mZnNldDtcbiAgICB3aGlsZSAocmVzaWR1ZVN0b3JlLnJlc2lkdWVUeXBlSWRbcmVzdWx0XSAhPT0gYWxwaGFJZCAmJiByZXN1bHQgPCBhdG9tT2Zmc2V0ICsgYXRvbUNvdW50KSB7XG4gICAgICByZXN1bHQrKztcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIEhlbHBlciBmdW5jdGlvbiB0byBmaW5kIHRoZSBzbWFsbGVzdCBwb3NzaWJsZSBkaXN0YW5jZSBiZXR3ZWVuIHR3byByZXNpZHVlcyB2aWEgdGhlaXIgYXRvbXMuXG4gICAqXG4gICAqIEBwYXJhbSByZXNub0kgVGhlIGZpcnN0IHJlc2lkdWUuXG4gICAqIEBwYXJhbSByZXNub0ogVGhlIHNlY29uZCByZXNpZHVlLlxuICAgKiBAcmV0dXJucyBTaG9ydGVzdCBkaXN0YW5jZSBiZXR3ZWVuIHRoZSB0d28gcmVzaWR1ZXMgaW4gw6VuZ3N0csO2bXMuXG4gICAqL1xuICBwdWJsaWMgZ2V0TWluRGlzdEJldHdlZW5SZXNpZHVlcyhyZXNub0k6IG51bWJlciwgcmVzbm9KOiBudW1iZXIpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRNaW5EaXN0QmV0d2VlblJlc2lkdWVJbmRpY2VzKFxuICAgICAgdGhpcy5uZ2xEYXRhLnJlc2lkdWVTdG9yZS5yZXNuby5pbmRleE9mKHJlc25vSSksXG4gICAgICB0aGlzLm5nbERhdGEucmVzaWR1ZVN0b3JlLnJlc25vLmluZGV4T2YocmVzbm9KKSxcbiAgICApO1xuICB9XG5cbiAgcHVibGljIGdldFJlc2lkdWVOdW1iZXJpbmdNaXNtYXRjaGVzKGNvbnRhY3RzOiBDb3VwbGluZ0NvbnRhaW5lcikge1xuICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBBcnJheTxJUmVzaWR1ZU1pc21hdGNoUmVzdWx0PigpO1xuICAgIHRoaXMuZWFjaFJlc2lkdWUocmVzaWR1ZSA9PiB7XG4gICAgICBjb25zdCBwZGJSZXNDb2RlID0gcmVzaWR1ZS5yZXNuYW1lLnRvVXBwZXJDYXNlKCkgYXMgQU1JTk9fQUNJRF9USFJFRV9MRVRURVJfQ09ERTtcbiAgICAgIGNvbnN0IGNvdXBsaW5nQW1pbm9BY2lkID0gY29udGFjdHMuZ2V0QW1pbm9BY2lkT2ZDb250YWN0KHJlc2lkdWUucmVzbm8pO1xuICAgICAgaWYgKFxuICAgICAgICBjb3VwbGluZ0FtaW5vQWNpZCAmJlxuICAgICAgICBBTUlOT19BQ0lEU19CWV9USFJFRV9MRVRURVJfQ09ERVtwZGJSZXNDb2RlXSAhPT1cbiAgICAgICAgICBBTUlOT19BQ0lEU19CWV9TSU5HTEVfTEVUVEVSX0NPREVbY291cGxpbmdBbWlub0FjaWQuc2luZ2xlTGV0dGVyQ29kZV1cbiAgICAgICkge1xuICAgICAgICByZXN1bHQucHVzaCh7XG4gICAgICAgICAgZmlyc3RBbWlub0FjaWQ6IEFNSU5PX0FDSURTX0JZX1NJTkdMRV9MRVRURVJfQ09ERVtjb3VwbGluZ0FtaW5vQWNpZC5zaW5nbGVMZXR0ZXJDb2RlXSxcbiAgICAgICAgICByZXNubzogcmVzaWR1ZS5yZXNubyxcbiAgICAgICAgICBzZWNvbmRBbWlub0FjaWQ6IEFNSU5PX0FDSURTX0JZX1RIUkVFX0xFVFRFUl9DT0RFW3BkYlJlc0NvZGVdLFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogSGVscGVyIGZ1bmN0aW9uIHRvIGZpbmQgdGhlIHNtYWxsZXN0IHBvc3NpYmxlIGRpc3RhbmNlIGJldHdlZW4gdHdvIHJlc2lkdWVzIHZpYSB0aGVpciBhdG9tcy5cbiAgICpcbiAgICogQHBhcmFtIGluZGV4SSBJbmRleCBvZiB0aGUgZmlyc3QgcmVzaWR1ZSB3aXRoIHJlc3BlY3QgdG8gdGhlIGFycmF5IG9mIGFsbCByZXNpZHVlcy5cbiAgICogQHBhcmFtIGluZGV4SiBJbmRleCBvZiB0aGUgc2Vjb25kIHJlc2lkdWUgd2l0aCByZXNwZWN0IHRvIHRoZSBhcnJheSBvZiBhbGwgcmVzaWR1ZXMuXG4gICAqIEByZXR1cm5zIFNob3J0ZXN0IGRpc3RhbmNlIGJldHdlZW4gdGhlIHR3byByZXNpZHVlcyBpbiDDpW5nc3Ryw7Ztcy5cbiAgICovXG4gIHByb3RlY3RlZCBnZXRNaW5EaXN0QmV0d2VlblJlc2lkdWVJbmRpY2VzKGluZGV4STogbnVtYmVyLCBpbmRleEo6IG51bWJlcikge1xuICAgIGNvbnN0IHsgcmVzaWR1ZVN0b3JlIH0gPSB0aGlzLm5nbERhdGE7XG4gICAgY29uc3QgZmlyc3RSZXNDb3VudCA9IHJlc2lkdWVTdG9yZS5hdG9tQ291bnRbaW5kZXhJXTtcbiAgICBjb25zdCBzZWNvbmRSZXNDb3VudCA9IHJlc2lkdWVTdG9yZS5hdG9tQ291bnRbaW5kZXhKXTtcbiAgICBjb25zdCBmaXJzdEF0b21JbmRleCA9IHJlc2lkdWVTdG9yZS5hdG9tT2Zmc2V0W2luZGV4SV07XG4gICAgY29uc3Qgc2Vjb25kQXRvbUluZGV4ID0gcmVzaWR1ZVN0b3JlLmF0b21PZmZzZXRbaW5kZXhKXTtcblxuICAgIGxldCByZXN1bHQgPSB7XG4gICAgICBhdG9tSW5kZXhJOiAtMSxcbiAgICAgIGF0b21JbmRleEo6IC0xLFxuICAgICAgZGlzdDogTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIsXG4gICAgfTtcbiAgICBmb3IgKGxldCBmaXJzdENvdW50ZXIgPSAwOyBmaXJzdENvdW50ZXIgPCBmaXJzdFJlc0NvdW50OyArK2ZpcnN0Q291bnRlcikge1xuICAgICAgZm9yIChsZXQgc2Vjb25kQ291bnRlciA9IDA7IHNlY29uZENvdW50ZXIgPCBzZWNvbmRSZXNDb3VudDsgKytzZWNvbmRDb3VudGVyKSB7XG4gICAgICAgIGNvbnN0IGF0b21JbmRleEkgPSBmaXJzdEF0b21JbmRleCArIGZpcnN0Q291bnRlcjtcbiAgICAgICAgY29uc3QgYXRvbUluZGV4SiA9IHNlY29uZEF0b21JbmRleCArIHNlY29uZENvdW50ZXI7XG4gICAgICAgIGNvbnN0IGRpc3QgPSB0aGlzLm5nbERhdGEuZ2V0QXRvbVByb3h5KGF0b21JbmRleEkpLmRpc3RhbmNlVG8odGhpcy5uZ2xEYXRhLmdldEF0b21Qcm94eShhdG9tSW5kZXhKKSk7XG4gICAgICAgIGlmIChkaXN0IDwgcmVzdWx0LmRpc3QpIHtcbiAgICAgICAgICByZXN1bHQgPSB7XG4gICAgICAgICAgICBhdG9tSW5kZXhJLFxuICAgICAgICAgICAgYXRvbUluZGV4SixcbiAgICAgICAgICAgIGRpc3QsXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbn1cbiIsImltcG9ydCB7IEFNSU5PX0FDSURTX0JZX1NJTkdMRV9MRVRURVJfQ09ERSwgSUFtaW5vQWNpZCwgSUNvdXBsaW5nU2NvcmUgfSBmcm9tICd+Y2hlbGwtdml6fi9kYXRhJztcblxuLyoqXG4gKiBBIENvdXBsaW5nQ29udGFpbmVyIHByb3ZpZGVzIGFjY2VzcyB0byB0aGUgY291cGxpbmcgaW5mb3JtYXRpb24gb2YgcmVzaWR1ZSBwYWlycy5cbiAqXG4gKiBCZWhpbmQgdGhlIHNjZW5lcywgaXQgaXMgYmFja2VkIGJ5IGEgc3BhcnNlIDJEIGFycmF5IHRvIGF2b2lkIGRhdGEgZHVwbGljYXRpb24gYW5kIHByb3ZpZGUgTygxKSBhY2Nlc3MuXG4gKlxuICogQGV4cG9ydFxuICovXG5leHBvcnQgY2xhc3MgQ291cGxpbmdDb250YWluZXIgaW1wbGVtZW50cyBJdGVyYWJsZUl0ZXJhdG9yPElDb3VwbGluZ1Njb3JlPiB7XG4gIHByb3RlY3RlZCBjb250YWN0czogSUNvdXBsaW5nU2NvcmVbXVtdID0gbmV3IEFycmF5PElDb3VwbGluZ1Njb3JlW10+KCk7XG5cbiAgLyoqIEhvdyBtYW55IGRpc3RpbmN0IGNvbnRhY3RzIGFyZSBjdXJyZW50bHkgc3RvcmVkLiAqL1xuICBwcm90ZWN0ZWQgdG90YWxTdG9yZWRDb250YWN0czogbnVtYmVyID0gMDtcblxuICBwcm90ZWN0ZWQgaW5kZXhSYW5nZSA9IHtcbiAgICBtYXg6IDUwLFxuICAgIG1pbjogMSxcbiAgfTtcblxuICAvKiogVXNlZCBmb3IgaXRlcmF0b3IgYWNjZXNzLiAqL1xuICBwcml2YXRlIHJvd0NvdW50ZXIgPSAwO1xuXG4gIC8qKiBVc2VkIGZvciBpdGVyYXRvciBhY2Nlc3MuICovXG4gIHByaXZhdGUgY29sQ291bnRlciA9IDA7XG5cbiAgcHVibGljIGNvbnN0cnVjdG9yKHNjb3JlczogSUNvdXBsaW5nU2NvcmVbXSA9IFtdKSB7XG4gICAgZm9yIChjb25zdCBzY29yZSBvZiBzY29yZXMpIHtcbiAgICAgIHRoaXMuYWRkQ291cGxpbmdTY29yZShzY29yZSk7XG4gICAgfVxuICB9XG5cbiAgcHVibGljIGdldCBhbGxDb250YWN0cygpIHtcbiAgICByZXR1cm4gdGhpcy5jb250YWN0cztcbiAgfVxuXG4gIHB1YmxpYyBnZXQgY2hhaW5MZW5ndGgoKSB7XG4gICAgcmV0dXJuIHRoaXMuaW5kZXhSYW5nZS5tYXggLSB0aGlzLmluZGV4UmFuZ2UubWluICsgMTtcbiAgfVxuXG4gIHB1YmxpYyBnZXQgcmFua2VkQ29udGFjdHMoKSB7XG4gICAgcmV0dXJuIEFycmF5LmZyb20odGhpcykuc29ydCgoYSwgYikgPT4ge1xuICAgICAgaWYgKGEuY24gJiYgYi5jbikge1xuICAgICAgICByZXR1cm4gYi5jbiAtIGEuY247XG4gICAgICB9IGVsc2UgaWYgKGEuY24gJiYgIWIuY24pIHtcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgfSBlbHNlIGlmICghYS5jbiAmJiBiLmNuKSB7XG4gICAgICAgIHJldHVybiAxO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gMDtcbiAgICB9KTtcbiAgfVxuXG4gIHB1YmxpYyBnZXQgcmVzaWR1ZUluZGV4UmFuZ2UoKSB7XG4gICAgcmV0dXJuIHRoaXMuaW5kZXhSYW5nZTtcbiAgfVxuXG4gIHB1YmxpYyBnZXQgc2VxdWVuY2UoKSB7XG4gICAgbGV0IHJlc3VsdCA9ICcnO1xuICAgIGZvciAobGV0IGkgPSB0aGlzLmluZGV4UmFuZ2UubWluOyBpIDw9IHRoaXMuaW5kZXhSYW5nZS5tYXg7ICsraSkge1xuICAgICAgY29uc3QgYW1pbm9BY2lkID0gdGhpcy5nZXRBbWlub0FjaWRPZkNvbnRhY3QoaSk7XG4gICAgICBpZiAoYW1pbm9BY2lkKSB7XG4gICAgICAgIHJlc3VsdCArPSBhbWlub0FjaWQuc2luZ2xlTGV0dGVyQ29kZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgcHVibGljIGdldCB0b3RhbENvbnRhY3RzKCkge1xuICAgIHJldHVybiB0aGlzLnRvdGFsU3RvcmVkQ29udGFjdHM7XG4gIH1cblxuICBwdWJsaWMgW1N5bWJvbC5pdGVyYXRvcl0oKTogSXRlcmFibGVJdGVyYXRvcjxJQ291cGxpbmdTY29yZT4ge1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZCBhIGNvdXBsaW5nIHNjb3JlIHRvIHRoaXMgY29sbGVjdGlvbi4gSWYgdGhlcmUgaXMgYWxyZWFkeSBhbiBlbnRyeSBmb3IgdGhpcyAoaSxqKSBjb250YWN0LCBpdCB3aWxsIGJlIG92ZXJyaWRkZW4hXG4gICAqXG4gICAqIEBwYXJhbSBzY29yZSBBIENvdXBsaW5nIFNjb3JlIHRvIGFkZCB0byB0aGUgY29sbGVjdGlvbi5cbiAgICovXG4gIHB1YmxpYyBhZGRDb3VwbGluZ1Njb3JlKHNjb3JlOiBJQ291cGxpbmdTY29yZSk6IHZvaWQge1xuICAgIGNvbnN0IHsgQV9pLCBBX2osIGksIGogfSA9IHNjb3JlO1xuXG4gICAgY29uc3QgbWluUmVzaWR1ZUluZGV4ID0gTWF0aC5taW4oaSwgaikgLSAxO1xuICAgIGNvbnN0IG1heFJlc2lkdWVJbmRleCA9IE1hdGgubWF4KGksIGopIC0gMTtcblxuICAgIGNvbnN0IGlzRmxpcHBlZCA9IG1pblJlc2lkdWVJbmRleCArIDEgPT09IGo7XG5cbiAgICBpZiAoIXRoaXMuY29udGFjdHNbbWluUmVzaWR1ZUluZGV4XSkge1xuICAgICAgdGhpcy5jb250YWN0c1ttaW5SZXNpZHVlSW5kZXhdID0gbmV3IEFycmF5PElDb3VwbGluZ1Njb3JlPigpO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuY29udGFjdHNbbWluUmVzaWR1ZUluZGV4XVttYXhSZXNpZHVlSW5kZXhdKSB7XG4gICAgICB0aGlzLnRvdGFsU3RvcmVkQ29udGFjdHMrKztcbiAgICB9XG4gICAgdGhpcy5jb250YWN0c1ttaW5SZXNpZHVlSW5kZXhdW21heFJlc2lkdWVJbmRleF0gPSB7XG4gICAgICAuLi50aGlzLmNvbnRhY3RzW21pblJlc2lkdWVJbmRleF1bbWF4UmVzaWR1ZUluZGV4XSxcbiAgICAgIC4uLnNjb3JlLFxuICAgIH07XG5cbiAgICBpZiAoaXNGbGlwcGVkKSB7XG4gICAgICB0aGlzLmNvbnRhY3RzW21pblJlc2lkdWVJbmRleF1bbWF4UmVzaWR1ZUluZGV4XS5pID0gajtcbiAgICAgIHRoaXMuY29udGFjdHNbbWluUmVzaWR1ZUluZGV4XVttYXhSZXNpZHVlSW5kZXhdLmogPSBpO1xuICAgICAgaWYgKEFfaSAmJiBBX2opIHtcbiAgICAgICAgdGhpcy5jb250YWN0c1ttaW5SZXNpZHVlSW5kZXhdW21heFJlc2lkdWVJbmRleF0uQV9pID0gQV9qO1xuICAgICAgICB0aGlzLmNvbnRhY3RzW21pblJlc2lkdWVJbmRleF1bbWF4UmVzaWR1ZUluZGV4XS5BX2ogPSBBX2k7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5pbmRleFJhbmdlID0ge1xuICAgICAgbWF4OiBNYXRoLm1heCh0aGlzLmluZGV4UmFuZ2UubWF4LCBtYXhSZXNpZHVlSW5kZXggKyAxKSxcbiAgICAgIG1pbjogTWF0aC5taW4odGhpcy5pbmRleFJhbmdlLm1pbiwgbWluUmVzaWR1ZUluZGV4ICsgMSksXG4gICAgfTtcbiAgfVxuXG4gIHB1YmxpYyBnZXRBbWlub0FjaWRPZkNvbnRhY3QocmVzbm86IG51bWJlcik6IElBbWlub0FjaWQgfCB1bmRlZmluZWQge1xuICAgIGlmIChyZXNubyA+IHRoaXMuY2hhaW5MZW5ndGggKyAxKSB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IG91dGVyQ29udGFjdCBvZiB0aGlzLmFsbENvbnRhY3RzKSB7XG4gICAgICBpZiAob3V0ZXJDb250YWN0KSB7XG4gICAgICAgIGZvciAoY29uc3QgaW5uZXJDb250YWN0IG9mIG91dGVyQ29udGFjdCkge1xuICAgICAgICAgIGlmIChpbm5lckNvbnRhY3QgJiYgaW5uZXJDb250YWN0LmkgPT09IHJlc25vICYmIGlubmVyQ29udGFjdC5BX2kpIHtcbiAgICAgICAgICAgIHJldHVybiBBTUlOT19BQ0lEU19CWV9TSU5HTEVfTEVUVEVSX0NPREVbaW5uZXJDb250YWN0LkFfaV07XG4gICAgICAgICAgfSBlbHNlIGlmIChpbm5lckNvbnRhY3QgJiYgaW5uZXJDb250YWN0LmogPT09IHJlc25vICYmIGlubmVyQ29udGFjdC5BX2opIHtcbiAgICAgICAgICAgIHJldHVybiBBTUlOT19BQ0lEU19CWV9TSU5HTEVfTEVUVEVSX0NPREVbaW5uZXJDb250YWN0LkFfal07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXRlcm1pbmUgd2hpY2ggY29udGFjdHMgaW4gdGhpcyBjb3VwbGluZyBjb250YWluZXIgYXJlIG9ic2VydmVkLlxuICAgKlxuICAgKiBAcGFyYW0gW2Rpc3RGaWx0ZXI9NV0gRm9yIGVhY2ggc2NvcmUsIGlmIGRpc3QgPD0gZGlzdEZpbHRlciwgaXQgaXMgY29uc2lkZXJlZCBvYnNlcnZlZC5cbiAgICogQHBhcmFtIFtsaW5lYXJEaXN0RmlsdGVyPTVdIEZvciBlYWNoIHNjb3JlLCBpZiB8aSAtIGp8ID49IGxpbmVhckRpc3RGaWx0ZXIsIGl0IHdpbGwgYmUgYSBjYW5kaWRhdGUgZm9yIGJlaW5nIGNvcnJlY3QvaW5jb3JyZWN0LlxuICAgKiBAcmV0dXJucyBDb250YWN0cyB0aGF0IHNob3VsZCBiZSBjb25zaWRlcmVkIG9ic2VydmVkIGluIHRoZSBjdXJyZW50IGRhdGEgc2V0LlxuICAgKi9cbiAgcHVibGljIGdldE9ic2VydmVkQ29udGFjdHMoZGlzdEZpbHRlcjogbnVtYmVyID0gNSwgbGluZWFyRGlzdEZpbHRlciA9IDUpOiBJQ291cGxpbmdTY29yZVtdIHtcbiAgICBjb25zdCByZXN1bHQgPSBuZXcgQXJyYXk8SUNvdXBsaW5nU2NvcmU+KCk7XG4gICAgZm9yIChjb25zdCBzY29yZSBvZiB0aGlzKSB7XG4gICAgICBpZiAoc2NvcmUuZGlzdCAmJiBzY29yZS5kaXN0IDw9IGRpc3RGaWx0ZXIgJiYgTWF0aC5hYnMoc2NvcmUuaSAtIHNjb3JlLmopID49IGxpbmVhckRpc3RGaWx0ZXIpIHtcbiAgICAgICAgcmVzdWx0LnB1c2goc2NvcmUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogRGV0ZXJtaW5lIHdoaWNoIGNvbnRhY3RzIGluIHRoaXMgY291cGxpbmcgY29udGFpbmVyIGFyZSBib3RoIHByZWRpY3RlZCBhbmQgY29ycmVjdC5cbiAgICpcbiAgICogQHBhcmFtIHRvdGFsUHJlZGljdGlvbnNUb1Nob3cgSG93IG1hbnkgcHJlZGljdGlvbnMsIG1heCwgdG8gcmV0dXJuLlxuICAgKiBAcGFyYW0gW2xpbmVhckRpc3RGaWx0ZXI9NV0gRm9yIGVhY2ggc2NvcmUsIGlmIHxpIC0ganwgPj0gbGluZWFyRGlzdEZpbHRlciwgaXQgd2lsbCBiZSBhIGNhbmRpZGF0ZSBmb3IgYmVpbmcgY29ycmVjdC9pbmNvcnJlY3QuXG4gICAqIEBwYXJhbSBbbWVhc3VyZWRDb250YWN0RGlzdEZpbHRlcj01XSAgSWYgdGhlIGRpc3QgZm9yIHRoZSBjb250YWN0IGlzIGxlc3MgdGhhbiBwcmVkaWN0aW9uQ3V0b2ZmRGlzdCwgaXQgaXMgY29uc2lkZXJlZCBjb3JyZWN0LlxuICAgKiBAcmV0dXJucyBBbiBvYmplY3QgY29udGFpbmluZyAyIGFycmF5IGZpZWxkczogY29ycmVjdCBhbmQgcHJlZGljdGVkLlxuICAgKi9cbiAgcHVibGljIGdldFByZWRpY3RlZENvbnRhY3RzKHRvdGFsUHJlZGljdGlvbnNUb1Nob3c6IG51bWJlciwgbGluZWFyRGlzdEZpbHRlciA9IDUsIG1lYXN1cmVkQ29udGFjdERpc3RGaWx0ZXIgPSA1KSB7XG4gICAgY29uc3QgcmVzdWx0ID0ge1xuICAgICAgY29ycmVjdDogbmV3IEFycmF5PElDb3VwbGluZ1Njb3JlPigpLFxuICAgICAgcHJlZGljdGVkOiBuZXcgQXJyYXk8SUNvdXBsaW5nU2NvcmU+KCksXG4gICAgfTtcblxuICAgIGZvciAoY29uc3QgY29udGFjdCBvZiB0aGlzLnJhbmtlZENvbnRhY3RzXG4gICAgICAuZmlsdGVyKHNjb3JlID0+IE1hdGguYWJzKHNjb3JlLmkgLSBzY29yZS5qKSA+PSBsaW5lYXJEaXN0RmlsdGVyKVxuICAgICAgLnNsaWNlKDAsIHRvdGFsUHJlZGljdGlvbnNUb1Nob3cpKSB7XG4gICAgICBpZiAoY29udGFjdC5kaXN0ICYmIGNvbnRhY3QuZGlzdCA8IG1lYXN1cmVkQ29udGFjdERpc3RGaWx0ZXIpIHtcbiAgICAgICAgcmVzdWx0LmNvcnJlY3QucHVzaChjb250YWN0KTtcbiAgICAgIH1cbiAgICAgIHJlc3VsdC5wcmVkaWN0ZWQucHVzaChjb250YWN0KTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIFByaW1hcnkgaW50ZXJmYWNlIGZvciBnZXR0aW5nIGEgY291cGxpbmcgc2NvcmUsIHByb3ZpZGVzIGFjY2VzcyB0byB0aGUgc2FtZSBkYXRhIG9iamVjdCByZWdhcmRsZXNzIG9mIG9yZGVyIG9mIChmaXJzdFJlcywgc2Vjb25kUmVzKS5cbiAgICovXG4gIHB1YmxpYyBnZXRDb3VwbGluZ1Njb3JlID0gKGZpcnN0UmVzOiBudW1iZXIsIHNlY29uZFJlczogbnVtYmVyKTogSUNvdXBsaW5nU2NvcmUgfCB1bmRlZmluZWQgPT4ge1xuICAgIGNvbnN0IHJvdyA9IHRoaXMuY29udGFjdHNbTWF0aC5taW4oZmlyc3RSZXMsIHNlY29uZFJlcykgLSAxXTtcblxuICAgIHJldHVybiByb3cgPyByb3dbTWF0aC5tYXgoZmlyc3RSZXMsIHNlY29uZFJlcykgLSAxXSA6IHVuZGVmaW5lZDtcbiAgfTtcblxuICBwdWJsaWMgaW5jbHVkZXMgPSAoZmlyc3RSZXM6IG51bWJlciwgc2Vjb25kUmVzOiBudW1iZXIpID0+XG4gICAgdGhpcy5jb250YWN0c1tNYXRoLm1pbihmaXJzdFJlcywgc2Vjb25kUmVzKSAtIDFdICYmXG4gICAgdGhpcy5jb250YWN0c1tNYXRoLm1pbihmaXJzdFJlcywgc2Vjb25kUmVzKSAtIDFdW01hdGgubWF4KGZpcnN0UmVzLCBzZWNvbmRSZXMpIC0gMV0gIT09IHVuZGVmaW5lZDtcblxuICBwdWJsaWMgbmV4dCgpOiBJdGVyYXRvclJlc3VsdDxJQ291cGxpbmdTY29yZT4ge1xuICAgIGZvciAobGV0IGkgPSB0aGlzLnJvd0NvdW50ZXI7IGkgPCB0aGlzLmNvbnRhY3RzLmxlbmd0aDsgKytpKSB7XG4gICAgICBpZiAodGhpcy5jb250YWN0c1tpXSkge1xuICAgICAgICBmb3IgKGxldCBqID0gdGhpcy5jb2xDb3VudGVyOyBqIDwgdGhpcy5jb250YWN0c1tpXS5sZW5ndGg7ICsraikge1xuICAgICAgICAgIGNvbnN0IHNjb3JlID0gdGhpcy5jb250YWN0c1tpXVtqXTtcbiAgICAgICAgICBpZiAoc2NvcmUpIHtcbiAgICAgICAgICAgIHRoaXMucm93Q291bnRlciA9IGk7XG4gICAgICAgICAgICB0aGlzLmNvbENvdW50ZXIgPSBqICsgMTtcblxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgZG9uZTogZmFsc2UsXG4gICAgICAgICAgICAgIHZhbHVlOiBzY29yZSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuY29sQ291bnRlciA9IDA7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5yb3dDb3VudGVyID0gMDtcbiAgICB0aGlzLmNvbENvdW50ZXIgPSAwO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIGRvbmU6IHRydWUsXG4gICAgICB2YWx1ZTogbnVsbCBhcyBhbnksXG4gICAgfTtcbiAgfVxuXG4gIHB1YmxpYyB1cGRhdGVDb250YWN0KGk6IG51bWJlciwgajogbnVtYmVyLCBzY29yZTogUGFydGlhbDxPbWl0PElDb3VwbGluZ1Njb3JlLCAnaScgfCAnaic+Pikge1xuICAgIHRoaXMuYWRkQ291cGxpbmdTY29yZSh7IGksIGosIC4uLnNjb3JlIH0pO1xuICB9XG59XG4iLCJpbXBvcnQgKiBhcyBwbG90bHkgZnJvbSAncGxvdGx5LmpzLWdsMmQtZGlzdCc7XG5cbmV4cG9ydCBlbnVtIFBMT1RMWV9DSEFSVF9UWVBFIHtcbiAgLyoqIFtQbG90bHkgQmFyIENoYXJ0XShodHRwczovL3Bsb3QubHkvamF2YXNjcmlwdC9iYXItY2hhcnRzLykgKi9cbiAgJ2JhcicgPSAnYmFyJyxcbiAgLyoqIFtQbG90bHkgUG9pbnQgQ2xvdWRdKGh0dHBzOi8vcGxvdC5seS9qYXZhc2NyaXB0L3BvaW50Y2xvdWQvKSAqL1xuICAncG9pbnRjbG91ZCcgPSAncG9pbnRjbG91ZCcsXG4gIC8qKiBbUGxvdGx5IExpbmUvU2NhdHRlciBDaGFydF0oaHR0cHM6Ly9wbG90Lmx5L2phdmFzY3JpcHQvbGluZS1hbmQtc2NhdHRlci8pICovXG4gICdzY2F0dGVyJyA9ICdzY2F0dGVyJyxcbiAgLyoqIFtQbG90bHkgTGluZS9TY2F0dGVyIENoYXJ0IGluIFdlYkdMXShodHRwczovL3Bsb3QubHkvamF2YXNjcmlwdC9saW5lLWFuZC1zY2F0dGVyLykgKi9cbiAgJ3NjYXR0ZXJnbCcgPSAnc2NhdHRlcmdsJyxcbiAgLyoqIFtQbG90bHkgM0QgU2NhdHRlciBQbG90XShodHRwczovL3Bsb3QubHkvamF2YXNjcmlwdC8zZC1zY2F0dGVyLXBsb3RzLykgKi9cbiAgJ3NjYXR0ZXIzZCcgPSAnc2NhdHRlcjNkJyxcbn1cblxuZXhwb3J0IGludGVyZmFjZSBJUGxvdGx5RGF0YSBleHRlbmRzIHBsb3RseS5TY2F0dGVyRGF0YSB7XG4gIGJveHBvaW50czogJ2FsbCcgfCAnb3V0bGllcnMnIHwgJ3N1c3BlY3RlZG91dGxpZXJzJyB8IGZhbHNlO1xuICBuYW1lOiBzdHJpbmc7XG4gIG5vdGNoZWQ6IGJvb2xlYW47XG4gIG9yaWVudGF0aW9uOiAnaCcgfCAndic7XG4gIHNob3dsZWdlbmQ6IGJvb2xlYW47XG4gIHRleHRmb250OiBQYXJ0aWFsPHBsb3RseS5Gb250PjtcbiAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm5vLXJlc2VydmVkLWtleXdvcmRzXG4gIHR5cGU6IFBMT1RMWV9DSEFSVF9UWVBFIHwgJ2JhcicgfCAncG9pbnRjbG91ZCcgfCAnc2NhdHRlcicgfCAnc2NhdHRlcmdsJyB8ICdzY2F0dGVyM2QnO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIElQbG90bHlMYXlvdXQgZXh0ZW5kcyBQbG90bHkuTGF5b3V0IHtcbiAgLy8gVE9ETyBPcGVuIFBSIHRvIGFkZCB0aGVzZSBtaXNzaW5nIFBsb3RseSB0eXBlcy4gLSBodHRwczovL3Bsb3QubHkvamF2YXNjcmlwdC9yZWZlcmVuY2UvI2JveFxuICB4YXhpczI6IFBhcnRpYWw8UGxvdGx5LkxheW91dEF4aXM+O1xuICAvLyBUT0RPIE9wZW4gUFIgdG8gYWRkIHRoZXNlIG1pc3NpbmcgUGxvdGx5IHR5cGVzLiAtIGh0dHBzOi8vcGxvdC5seS9qYXZhc2NyaXB0L3JlZmVyZW5jZS8jYm94XG59XG5cbmV4cG9ydCB0eXBlIFJFUVVJUkVEX0NIRUxMX1BMT1RMWV9EQVRBID0gUmVxdWlyZWQ8XG4gIFBpY2s8XG4gICAgSVBsb3RseURhdGEsXG4gICAgJ2Nvbm5lY3RnYXBzJyB8ICdob3ZlcmluZm8nIHwgJ2xpbmUnIHwgJ21hcmtlcicgfCAnbW9kZScgfCAnbmFtZScgfCAnc2hvd2xlZ2VuZCcgfCAndHlwZScgfCAneCcgfCAneSdcbiAgPlxuPjtcblxuZXhwb3J0IHR5cGUgQ0hFTExfUExPVExZX0RBVEEgPSBSRVFVSVJFRF9DSEVMTF9QTE9UTFlfREFUQSAmIFBhcnRpYWw8SVBsb3RseURhdGE+O1xuIiwiLy8gY1NwZWxsOmRpc2FibGVcbi8vIHRzbGludDpkaXNhYmxlOm1heC1saW5lLWxlbmd0aCBuby1yZXNlcnZlZC1rZXl3b3Jkc1xuXG5leHBvcnQgaW50ZXJmYWNlIEluZm8ge1xuICBjcmVhdGVkOiBzdHJpbmc7XG4gIG1vZGlmaWVkOiBzdHJpbmc7XG4gIHR5cGU6IHN0cmluZztcbiAgdmVyc2lvbjogbnVtYmVyO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIElOYW1lIHtcbiAgdHlwZTogc3RyaW5nO1xuICB2YWx1ZTogc3RyaW5nO1xufVxuXG5leHBvcnQgY29uc3QgZW51bSBMSU5FQUdFX1RZUEVTIHtcbiAgJ0NhdGFycmhpbmknLFxuICAnQ2hvcmRhdGEnLFxuICAnQ3JhbmlhdGEnLFxuICAnRXVhcmNob250b2dsaXJlcycsXG4gICdFdWthcnlvdGEnLFxuICAnRXV0ZWxlb3N0b21pJyxcbiAgJ0V1dGhlcmlhJyxcbiAgJ0hhcGxvcnJoaW5pJyxcbiAgJ0hvbWluaWRhZScsXG4gICdIb21vJyxcbiAgJ01hbW1hbGlhJyxcbiAgJ01ldGF6b2EnLFxuICAnUHJpbWF0ZXMnLFxuICAnVmVydGVicmF0YScsXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgSU9yZ2FuaXNtIHtcbiAgbGluZWFnZTogQXJyYXk8a2V5b2YgdHlwZW9mIExJTkVBR0VfVFlQRVM+O1xuICBuYW1lczogSU5hbWVbXTtcbiAgdGF4b25vbXk6IG51bWJlcjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBJTmFtZVBhaXIge1xuICBmdWxsTmFtZTogSVRleHRWYWx1ZTtcbiAgc2hvcnROYW1lPzogSVRleHRWYWx1ZVtdO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIElQcm90ZWluTmFtZSB7XG4gIGFsdGVybmF0aXZlTmFtZTogSU5hbWVQYWlyW107XG4gIHJlY29tbWVuZGVkTmFtZTogSU5hbWVQYWlyO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIElHZW5lIHtcbiAgbmFtZTogSVRleHRWYWx1ZTtcbiAgc3lub255bXM6IElUZXh0VmFsdWVbXTtcbn1cblxuZXhwb3J0IGNvbnN0IGVudW0gSU5URVJBQ1RJT05fVFlQRSB7XG4gICdCSU5BUlknLFxuICAnU0VMRicsXG4gICdYRU5PJyxcbn1cbmV4cG9ydCBpbnRlcmZhY2UgSUludGVyYWN0aW9uIHtcbiAgZXhwZXJpbWVudHM6IG51bWJlcjtcbiAgZ2VuZTogc3RyaW5nO1xuICBpZDogc3RyaW5nO1xuICBpbnRlcmFjdGlvblR5cGU6IGtleW9mIHR5cGVvZiBJTlRFUkFDVElPTl9UWVBFO1xuICBpbnRlcmFjdG9yMTogc3RyaW5nO1xuICBpbnRlcmFjdG9yMjogc3RyaW5nO1xuICBvcmdhbmlzbURpZmZlcjogYm9vbGVhbjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBJU291cmNlIHtcbiAgYWx0ZXJuYXRpdmVVcmw6IHN0cmluZztcbiAgaWQ6IHN0cmluZztcbiAgbmFtZTogc3RyaW5nO1xuICB0aXNzdWU6IElUZXh0VmFsdWVbXTtcbiAgdXJsOiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgSUV2aWRlbmNlIHtcbiAgY29kZTogc3RyaW5nO1xuICBzb3VyY2U6IFBhcnRpYWw8SVNvdXJjZT47XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgSUNvbW1lbnRMb2NhdGlvbiB7XG4gIGxvY2F0aW9uOiBQYXJ0aWFsPElMb2NhdGlvbkRlc2NyaXB0aW9uPjtcbn1cblxuZXhwb3J0IGNvbnN0IGVudW0gREJfUkVGRVJFTkNFX1RZUEUge1xuICAnQmdlZScsXG4gICdCaW9HcmlkJyxcbiAgJ0Jpb011dGEnLFxuICAnQ0NEUycsXG4gICdDT1JVTScsXG4gICdDVEQnLFxuICAnQ2hpVGFSUycsXG4gICdDbGVhbkV4JyxcbiAgJ0NvbXBsZXhQb3J0YWwnLFxuICAnRElQJyxcbiAgJ0RNRE0nLFxuICAnRE5BU1UnLFxuICAnRE9JJyxcbiAgJ0Rpc0dlTkVUJyxcbiAgJ0Rpc1Byb3QnLFxuICAnRU1CTCcsXG4gICdFUEQnLFxuICAnRW5zZW1ibCcsXG4gICdFdVBhdGhEQicsXG4gICdFdm9sdXRpb25hcnlUcmFjZScsXG4gICdFeHByZXNzaW9uQXRsYXMnLFxuICAnR08nLFxuICAnR2VuZTNEJyxcbiAgJ0dlbmVDYXJkcycsXG4gICdHZW5lSUQnLFxuICAnR2VuZVJldmlld3MnLFxuICAnR2VuZVRyZWUnLFxuICAnR2VuZVdpa2knLFxuICAnR2VuZXZpc2libGUnLFxuICAnR2Vub21lUk5BaScsXG4gICdIR05DJyxcbiAgJ0hPR0VOT00nLFxuICAnSE9WRVJHRU4nLFxuICAnSFBBJyxcbiAgJ0luUGFyYW5vaWQnLFxuICAnSW50QWN0JyxcbiAgJ0ludGVyUHJvJyxcbiAgJ0tFR0cnLFxuICAnS08nLFxuICAnTUlNJyxcbiAgJ01JTlQnLFxuICAnTWFsYUNhcmRzJyxcbiAgJ01heFFCJyxcbiAgJ09NQScsXG4gICdPcGVuVGFyZ2V0cycsXG4gICdPcnBoYW5ldCcsXG4gICdPcnRob0RCJyxcbiAgJ1BBTlRIRVInLFxuICAnUERCJyxcbiAgJ1BEQnN1bScsXG4gICdQSVInLFxuICAnUFJJREUnLFxuICAnUFJPJyxcbiAgJ1BST1NJVEUnLFxuICAnUGF4RGInLFxuICAnUGVwdGlkZUF0bGFzJyxcbiAgJ1BmYW0nLFxuICAnUGhhcm1HS0InLFxuICAnUGhvc3Bob1NpdGVQbHVzJyxcbiAgJ1BoeWxvbWVEQicsXG4gICdQcm90ZWluTW9kZWxQb3J0YWwnLFxuICAnUHJvdGVvbWVzJyxcbiAgJ1Byb3Rlb21pY3NEQicsXG4gICdQdWJNZWQnLFxuICAnUmVhY3RvbWUnLFxuICAnUmVmU2VxJyxcbiAgJ1NJR05PUicsXG4gICdTTUFSVCcsXG4gICdTTVInLFxuICAnU1RSSU5HJyxcbiAgJ1NVUEZBTScsXG4gICdTaWduYUxpbmsnLFxuICAnVHJlZUZhbScsXG4gICdVQ1NDJyxcbiAgJ1VuaUdlbmUnLFxuICAnZWdnTk9HJyxcbiAgJ2lQVE1uZXQnLFxuICAnbmVYdFByb3QnLFxufVxuXG5leHBvcnQgaW50ZXJmYWNlIElEYlJlZmVyZW5jZSB7XG4gIGV2aWRlbmNlczogQXJyYXk8UGFydGlhbDxJRXZpZGVuY2U+PjtcbiAgaWQ6IHN0cmluZztcbiAgcHJvcGVydGllczogUGFydGlhbDxJUHJvcGVydGllcz47XG4gIHR5cGU6IGtleW9mIHR5cGVvZiBEQl9SRUZFUkVOQ0VfVFlQRTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBJTG9jYXRpb25EZXNjcmlwdGlvbiB7XG4gIHZhbHVlOiBzdHJpbmc7XG4gIGV2aWRlbmNlczogQXJyYXk8UGFydGlhbDxJRXZpZGVuY2U+Pjtcbn1cblxuZXhwb3J0IGVudW0gUFJPVEVJTl9DT01NRU5UX1RZUEUge1xuICAnRElTRUFTRScsXG4gICdET01BSU4nLFxuICAnRlVOQ1RJT04nLFxuICAnSU5URVJBQ1RJT04nLFxuICAnTUlNJyxcbiAgJ1BUTScsXG4gICdTSU1JTEFSSVRZJyxcbiAgJ1NVQkNFTExVTEFSX0xPQ0FUSU9OJyxcbiAgJ1NVQlVOSVQnLFxuICAnV0VCUkVTT1VSQ0UnLFxufVxuXG5leHBvcnQgaW50ZXJmYWNlIElDb21tZW50IHtcbiAgdHlwZToga2V5b2YgdHlwZW9mIFBST1RFSU5fQ09NTUVOVF9UWVBFO1xuICB0ZXh0OiBhbnk7XG4gIGludGVyYWN0aW9uczogQXJyYXk8UGFydGlhbDxJSW50ZXJhY3Rpb24+PjtcbiAgbG9jYXRpb25zOiBBcnJheTxQYXJ0aWFsPElDb21tZW50TG9jYXRpb24+PjtcbiAgZGlzZWFzZUlkOiBzdHJpbmc7XG4gIGFjcm9ueW06IHN0cmluZztcbiAgZGJSZWZlcmVuY2U6IFBhcnRpYWw8SURiUmVmZXJlbmNlPjtcbiAgZGVzY3JpcHRpb246IFBhcnRpYWw8SUxvY2F0aW9uRGVzY3JpcHRpb24+O1xuICBuYW1lOiBzdHJpbmc7XG4gIHVybDogc3RyaW5nO1xufVxuXG5leHBvcnQgY29uc3QgZW51bSBGRUFUVVJFX1RZUEVTIHtcbiAgJ0NIQUlOJyxcbiAgJ0NPTVBCSUFTJyxcbiAgJ0NST1NTTE5LJyxcbiAgJ0RPTUFJTicsXG4gICdIRUxJWCcsXG4gICdNRVRBTCcsXG4gICdNT0RfUkVTJyxcbiAgJ01VVEFHRU4nLFxuICAnUkVHSU9OJyxcbiAgJ1NJVEUnLFxuICAnU1RSQU5EJyxcbiAgJ1RVUk4nLFxuICAnVkFSSUFOVCcsXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgSUZlYXR1cmUge1xuICB0eXBlOiBrZXlvZiB0eXBlb2YgRkVBVFVSRV9UWVBFUztcbiAgY2F0ZWdvcnk6IHN0cmluZztcbiAgZnRJZDogc3RyaW5nO1xuICBkZXNjcmlwdGlvbjogc3RyaW5nO1xuICBiZWdpbjogc3RyaW5nO1xuICBlbmQ6IHN0cmluZztcbiAgZXZpZGVuY2VzOiBBcnJheTxQYXJ0aWFsPElFdmlkZW5jZT4+O1xuICBhbHRlcm5hdGl2ZVNlcXVlbmNlOiBzdHJpbmc7XG59XG5cbmV4cG9ydCBjb25zdCBlbnVtIERCX1JFRkVSRU5DRV9QUk9QRVJUWV9UWVBFIHtcbiAgJ2dlbmUnLFxuICAncGhlbm90eXBlJyxcbn1cblxuZXhwb3J0IGludGVyZmFjZSBJUHJvcGVydGllcyB7XG4gICdlbnRyeSBuYW1lJzogc3RyaW5nO1xuICAnZXhwcmVzc2lvbiBwYXR0ZXJucyc6IHN0cmluZztcbiAgJ2dlbmUgSUQnOiBzdHJpbmc7XG4gICdnZW5lIGRlc2lnbmF0aW9uJzogc3RyaW5nO1xuICAnbWF0Y2ggc3RhdHVzJzogc3RyaW5nO1xuICAnbW9sZWN1bGUgdHlwZSc6IHN0cmluZztcbiAgJ251Y2xlb3RpZGUgc2VxdWVuY2UgSUQnOiBzdHJpbmc7XG4gICdvcmdhbmlzbSBuYW1lJzogc3RyaW5nO1xuICAncGF0aHdheSBuYW1lJzogc3RyaW5nO1xuICAncHJvdGVpbiBzZXF1ZW5jZSBJRCc6IHN0cmluZztcbiAgJ3RheG9ub21pYyBzY29wZSc6IHN0cmluZztcbiAgRGVzY3JpcHRpb246IHN0cmluZztcbiAgY2hhaW5zOiBzdHJpbmc7XG4gIGNvbXBvbmVudDogc3RyaW5nO1xuICBkaXNlYXNlOiBzdHJpbmc7XG4gIGVudHJ5TmFtZTogc3RyaW5nO1xuICBpbnRlcmFjdGlvbnM6IHN0cmluZztcbiAgbWV0aG9kOiBzdHJpbmc7XG4gIHJlc29sdXRpb246IHN0cmluZztcbiAgc291cmNlOiBzdHJpbmc7XG4gIHN0YXR1czogc3RyaW5nO1xuICB0ZXJtOiBzdHJpbmc7XG4gIHR5cGU6IGtleW9mIHR5cGVvZiBEQl9SRUZFUkVOQ0VfUFJPUEVSVFlfVFlQRTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBJVGV4dFZhbHVlIHtcbiAgdmFsdWU6IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBJUHVibGljYXRpb24ge1xuICBqb3VybmFsTmFtZTogc3RyaW5nO1xuICBzdWJtaXNzaW9uRGF0YWJhc2U6IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBJUHVibGljYXRpb25Mb2NhdGlvbiB7XG4gIGZpcnN0UGFnZTogc3RyaW5nO1xuICBsYXN0UGFnZTogc3RyaW5nO1xuICB2b2x1bWU6IHN0cmluZztcbn1cblxuZXhwb3J0IGNvbnN0IGVudW0gQ0lUQVRJT05fVFlQRSB7XG4gICdqb3VybmFsIGFydGljbGUnLFxuICAnc3VibWlzc2lvbicsXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgSUNpdGF0aW9uIHtcbiAgYXV0aG9yczogc3RyaW5nW107XG4gIGNvbnNvcnRpdW1zOiBzdHJpbmdbXTtcbiAgZGJSZWZlcmVuY2VzOiBBcnJheTxQYXJ0aWFsPElEYlJlZmVyZW5jZT4+O1xuICBsb2NhdGlvbjogUGFydGlhbDxJUHVibGljYXRpb25Mb2NhdGlvbj47XG4gIHB1YmxpY2F0aW9uOiBQYXJ0aWFsPElQdWJsaWNhdGlvbj47XG4gIHB1YmxpY2F0aW9uRGF0ZTogc3RyaW5nO1xuICB0aXRsZTogc3RyaW5nO1xuICB0eXBlOiBrZXlvZiB0eXBlb2YgQ0lUQVRJT05fVFlQRTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBJUmVmZXJlbmNlIHtcbiAgY2l0YXRpb246IFBhcnRpYWw8SUNpdGF0aW9uPjtcbiAgc2NvcGU6IHN0cmluZ1tdO1xuICBzb3VyY2U6IFBhcnRpYWw8SVNvdXJjZT47XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgSVNlcXVlbmNlIHtcbiAgbGVuZ3RoOiBudW1iZXI7XG4gIG1hc3M6IG51bWJlcjtcbiAgbW9kaWZpZWQ6IHN0cmluZztcbiAgc2VxdWVuY2U6IHN0cmluZztcbiAgdmVyc2lvbjogbnVtYmVyO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIElQcm90ZWluIHtcbiAgW2tleTogc3RyaW5nXTogYW55O1xuICBhY2Nlc3Npb246IHN0cmluZztcbiAgY29tbWVudHM6IEFycmF5PFBhcnRpYWw8SUNvbW1lbnQ+PjtcbiAgZGJSZWZlcmVuY2VzOiBBcnJheTxQYXJ0aWFsPElEYlJlZmVyZW5jZT4+O1xuICBmZWF0dXJlczogQXJyYXk8UGFydGlhbDxJRmVhdHVyZT4+O1xuICBnZW5lOiBBcnJheTxQYXJ0aWFsPElHZW5lPj47XG4gIGlkOiBzdHJpbmc7XG4gIGluZm86IEluZm87XG4gIGtleXdvcmRzOiBBcnJheTxQYXJ0aWFsPElUZXh0VmFsdWU+PjtcbiAgb3JnYW5pc206IFBhcnRpYWw8SU9yZ2FuaXNtPjtcbiAgcHJvdGVpbjogUGFydGlhbDxJUHJvdGVpbk5hbWU+O1xuICBwcm90ZWluRXhpc3RlbmNlOiBzdHJpbmc7XG4gIHJlZmVyZW5jZXM6IEFycmF5PFBhcnRpYWw8SVJlZmVyZW5jZT4+O1xuICBzZWNvbmRhcnlBY2Nlc3Npb246IHN0cmluZ1tdO1xuICBzZXF1ZW5jZTogSVNlcXVlbmNlO1xufVxuIiwiaW1wb3J0IHsgQ29sb3IgfSBmcm9tICdwbG90bHkuanMtZ2wyZC1kaXN0JztcblxuaW1wb3J0IHsgQ2hlbGwxRFNlY3Rpb24gfSBmcm9tICd+Y2hlbGwtdml6fi9kYXRhJztcblxuLyoqXG4gKiBDbGFzcyB0byBlbmNhcHN1bGF0ZSBhIDEgRGltZW5zaW9uYWwgZGF0YSBzZWdtZW50IHRoYXQgaGFzIGFuIGFzc29jaWF0ZWQgY29sb3Igd2l0aCBpdC5cbiAqXG4gKiBAZXhwb3J0XG4gKiBAZXh0ZW5kcyBDaGVsbDFEU2VjdGlvblxuICovXG5leHBvcnQgY2xhc3MgVGludGVkQ2hlbGwxRFNlY3Rpb248VD4gZXh0ZW5kcyBDaGVsbDFEU2VjdGlvbjxUPiB7XG4gIHByb3RlY3RlZCBzZWN0aW9uQ29sb3I6IENvbG9yID0gJ29yYW5nZSc7XG5cbiAgcHVibGljIGdldCBjb2xvcigpIHtcbiAgICByZXR1cm4gdGhpcy5zZWN0aW9uQ29sb3I7XG4gIH1cblxuICBwdWJsaWMgY29uc3RydWN0b3IocmVhZG9ubHkgbGFiZWw6IFQsIHN0YXJ0OiBudW1iZXIsIGVuZDogbnVtYmVyID0gc3RhcnQsIGNvbG9yOiBDb2xvciA9ICdvcmFuZ2UnKSB7XG4gICAgc3VwZXIobGFiZWwsIHN0YXJ0LCBlbmQpO1xuICAgIHRoaXMuc2VjdGlvbkNvbG9yID0gY29sb3I7XG4gIH1cblxuICBwdWJsaWMgdXBkYXRlQ29sb3IoY29sb3I6IENvbG9yKSB7XG4gICAgdGhpcy5zZWN0aW9uQ29sb3IgPSBjb2xvcjtcbiAgfVxufVxuIiwiZXhwb3J0IGludGVyZmFjZSBJVml6U3VtbWFyeURhdGEge1xuICBhdXRob3JzOiBzdHJpbmdbXTtcbiAgbGlzdEFzT3JpZ2luYWw6IGJvb2xlYW47XG4gIG5hbWU6IHN0cmluZztcbiAgcmVsZXZhbnREYXRhOiBzdHJpbmc7XG4gIHN1bW1hcnk6IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBJVml6RXhhbXBsZSB7XG4gIGljb246IHN0cmluZztcbiAgbmFtZTogc3RyaW5nO1xuICBsaW5rOiBzdHJpbmc7XG4gIHN1bW1hcnk6IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBJVml6T3ZlcnZpZXdEYXRhIGV4dGVuZHMgSVZpelN1bW1hcnlEYXRhIHtcbiAgY2l0YXRpb25zOiBBcnJheTx7XG4gICAgZnVsbENpdGF0aW9uOiBzdHJpbmc7XG4gICAgbGluazogc3RyaW5nO1xuICB9PjtcbiAgY29tcGF0aWJpbGl0eTogc3RyaW5nW107XG4gIGRldGFpbGVkU3VtbWFyeTogc3RyaW5nO1xuICBleGFtcGxlczogSVZpekV4YW1wbGVbXTtcbiAgcmVwbzoge1xuICAgIHZlcnNpb246IHN0cmluZztcbiAgICBsYXN0VXBkYXRlOiBzdHJpbmc7XG4gICAgbGluazogc3RyaW5nO1xuICB9O1xufVxuXG5jb25zdCBzcHJpbmdFeGFtcGxlcyA9IFtcbiAge1xuICAgIGljb246ICdhc3NldHMvaWNvbnMvZXhhbXBsZV9ocGNfc2YyLXNwcmluZy5wbmcnLFxuICAgIGxpbms6ICcvZGF0YXNldD9uYW1lPWhwY19zZjIvZnVsbCZ2aXo9c3ByaW5nJyxcbiAgICBuYW1lOiAnSFBDIChoZW1hdG9wb2lldGljIHByb2dlbml0b3IgY2VsbHMpJyxcbiAgICBzdW1tYXJ5OlxuICAgICAgJ0FuYWx5c2lzIG9mIDMzLDQ3MyBoZW1hdG9wb2lldGljIHByb2dlbml0b3IgY2VsbHMgYXMgdGhleSBkaWZmZXJlbnRpYXRlIG92ZXIgNiBkYXlzLlxcXG4gICAgICAgQmFyY29kZXMgd2VyZSBpbnRyb2R1Y2VkIGF0IGRheSAwIGFuZCBjZWxsIGxpbmVhZ2UgcmVsYXRpb25zaGlwcyB3ZXJlIHRyYWNlZCBieVxcXG4gICAgICAgaWRlbnRpZnlpbmcgcHJvZ2VueSBmcm9tIHRoZWlyIGJhcmNvZGVzIGluIHNjUk5Bc2VxIG9mIGFsaXF1b3RzIG9mIHRoZSBzYW1lIHBvcHVsYXRpb24gdGFrZW4gYXQgc2V2ZXJhbCB0aW1lcG9pbnRzLicsXG4gIH0sXG4gIHtcbiAgICBpY29uOiAnYXNzZXRzL2ljb25zL3RhYnVsYS1tdXJpcy10aHVtYm5haWwucG5nJyxcbiAgICBsaW5rOiAnL2RhdGFzZXQ/bmFtZT10YWJ1bGFfbXVyaXMvMTBrJnZpej1zcHJpbmcnLFxuICAgIG5hbWU6ICdDWkkgVGFidWxhIG11cmlzJyxcbiAgICBzdW1tYXJ5OiAnQW5hbHlzaXMgb2YgMTBLIG1vdXNlIGNlbGxzIGZyb20gMjAgb3JnYW5zIGFuZCB0aXNzdWVzLicsXG4gIH0sXG4gIHtcbiAgICBpY29uOiAnYXNzZXRzL2ljb25zL2V4YW1wbGVfdGFidWxhcm11cmlzX3NwcmluZy10c25lLWFuYXRvbW9ncmFtLnBuZycsXG4gICAgbGluazogJy9kYXRhc2V0P25hbWU9dGFidWxhX211cmlzLzEwayZ2aXo9c3ByaW5nJnZpej10ZmpzLXRzbmUmdml6PWFuYXRvbW9ncmFtJyxcbiAgICBuYW1lOiAnVGFidWxhIE11cmlzIC0gU1BSSU5HIHZzIHRTTkUgd2l0aCBBbmF0b21vZ3JhbScsXG4gICAgc3VtbWFyeTpcbiAgICAgICdFeGFtcGxlIGNvbXBhcmlzb24gb2YgZGF0YSByZWR1Y3Rpb24gdGVjaG5pcXVlcyBTUFJJTkcgYW5kIHRTTkVcXFxuICAgIChvZiB0b3AgMzAgUENBIGNvbXBvbmVudHMpLCBvbiBSTkFzZXEgcHJvZmlsZXMgZnJvbSAxMDAwMCBjZWxsc1xcXG4gICAgZnJvbSB0aGUgQ1pJIFRhYnVsYSBtdXJpcyBkYXRhc2V0LiBBbHNvIGluY2x1ZGVzIGFuYXRvbW9ncmFtIHZpc3VhbGl6YXRpb24gZm9yIHNlbGVjdGlvbiBvZiB0aXNzdWUgdHlwZXMuJyxcbiAgfSxcbiAge1xuICAgIGljb246ICdhc3NldHMvaWNvbnMvZXhhbXBsZV9IUENfc3ByaW5nLXRzbmUtYW5hdG9tb2dyYW0ucG5nJyxcbiAgICBsaW5rOiAnL2RhdGFzZXQ/bmFtZT1ocGMvZnVsbCZ2aXo9c3ByaW5nJnZpej10ZmpzLXRzbmUmdml6PWFuYXRvbW9ncmFtJyxcbiAgICBuYW1lOiAnSFBDIC0gU1BSSU5HIHZzIHRTTkUgd2l0aCBBbmF0b21vZ3JhbScsXG4gICAgc3VtbWFyeTogJ0V4YW1wbGUgaW50ZXJhY3Rpb24gYmV0d2VlbiBTUFJJTkcsIHRTTkUgYW5kIEFuYXRvbW9ncmFtIHZpc3VhbGl6YXRpb24gb24gYSBzbWFsbCBkYXRhc2V0LicsXG4gIH0sXG5dO1xuXG5jb25zdCBhbmF0b21vZ3JhbTogSVZpek92ZXJ2aWV3RGF0YSA9IHtcbiAgYXV0aG9yczogWydBbGZvbnNvIE11w7Fvei1Qb21lciBGdWVudGVzJ10sXG4gIGNpdGF0aW9uczogW10sXG4gIGNvbXBhdGliaWxpdHk6IFtdLFxuICBkZXRhaWxlZFN1bW1hcnk6ICcnLFxuICBleGFtcGxlczogW3NwcmluZ0V4YW1wbGVzWzJdXSxcbiAgbGlzdEFzT3JpZ2luYWw6IHRydWUsXG4gIG5hbWU6ICdBbmF0b21vZ3JhbScsXG4gIHJlbGV2YW50RGF0YTogJ3NjUk5BLXNlcScsXG4gIHJlcG86IHsgbGFzdFVwZGF0ZTogJycsIGxpbms6ICdodHRwczovL2dpdGh1Yi5jb20vZWJpLWdlbmUtZXhwcmVzc2lvbi1ncm91cC9hbmF0b21vZ3JhbScsIHZlcnNpb246ICcnIH0sXG4gIHN1bW1hcnk6ICdJbnRlcmFjdGl2ZSBhbmF0b21pY2FsIGRpYWdyYW0uJyxcbn07XG5cbmNvbnN0IHNwcmluZzogSVZpek92ZXJ2aWV3RGF0YSA9IHtcbiAgYXV0aG9yczogWydDYWxlYiBXZWlucmViJywgJ1NhbXVlbCBXb2xvY2snLCAnQWxsb24gS2xlaW4nXSxcbiAgY2l0YXRpb25zOiBbXG4gICAge1xuICAgICAgZnVsbENpdGF0aW9uOlxuICAgICAgICAnV2VpbnJlYiwgQ2FsZWIsIFNhbXVlbCBXb2xvY2ssIGFuZCBBbGxvbiBNLiBLbGVpbi5cXFxuICAgICAgXCJTUFJJTkc6IEEga2luZXRpYyBpbnRlcmZhY2UgZm9yIHZpc3VhbGl6aW5nIGhpZ2ggZGltZW5zaW9uYWwgc2luZ2xlLWNlbGwgZXhwcmVzc2lvbiBkYXRhLlwiXFxcbiAgICAgIEJpb2luZm9ybWF0aWNzIDM0LjcgKDIwMTcpOiAxMjQ2LTEyNDguJyxcbiAgICAgIGxpbms6ICdodHRwczovL3d3dy5uY2JpLm5sbS5uaWguZ292L3B1Ym1lZC8yOTIyODE3MicsXG4gICAgfSxcbiAgXSxcbiAgY29tcGF0aWJpbGl0eTogWydsaXZlIHRTTkUnLCAnVU1BUCcsICdQQ0EnXSxcbiAgZGV0YWlsZWRTdW1tYXJ5OlxuICAgICdTUFJJTkcgaXMgYSB0b29sIGZvciB1bmNvdmVyaW5nIGhpZ2gtZGltZW5zaW9uYWwgc3RydWN0dXJlIGluIHNpbmdsZS1jZWxsIGdlbmUgZXhwcmVzc2lvbiBkYXRhLlxcXG4gICBTUFJJTkcgdGFrZXMgYSAoZ2VuZSBYIGNlbGwpIHRhYmxlIG9mIGV4cHJlc3Npb24gbWVhc3VyZW1lbnRzIGFuZCBvdXRwdXRzIGEgay1uZWFyZXN0LW5laWdoYm9yIGdyYXBoXFxcbiAgIHJlbmRlcmVkIHVzaW5nIGEgZm9yY2UgZGlyZWN0ZWQgbGF5b3V0LlxcXG4gICBVc2VycyBjYW4gb3ZlcmxheSBwcmlvciBpbmZvcm1hdGlvbiwgaW5jbHVkaW5nIGdlbmUgZXhwcmVzc2lvbiB2YWx1ZXMsIGdlbmUtc2V0IHNjb3JlcywgY2VsbCBjbHVzdGVyIGxhYmVscyBhbmQgc2FtcGxlIElEcy5cXFxuICAgVXNlcnMgY2FuIGFsc28gdXBsb2FkIGN1c3RvbSBjb29yZGluYXRlcyB0aGF0IGhhdmUgYmVlbiBnZW5lcmF0ZWQgdXNpbmcgYW4gb3V0c2lkZSBwcm9ncmFtIHN1Y2ggYXMgdFNORS4nLFxuICBleGFtcGxlczogc3ByaW5nRXhhbXBsZXMsXG4gIGxpc3RBc09yaWdpbmFsOiBmYWxzZSxcbiAgbmFtZTogJ1NQUklORycsXG4gIHJlbGV2YW50RGF0YTogJ3NjUk5BLXNlcScsXG4gIHJlcG86IHtcbiAgICBsYXN0VXBkYXRlOiAnMjAxOC4wMy4xMicsXG4gICAgbGluazogJ2h0dHBzOi8vZ2l0aHViLmNvbS9BbGxvbktsZWluTGFiL1NQUklOR19kZXYnLFxuICAgIHZlcnNpb246ICcyLjAnLFxuICB9LFxuICBzdW1tYXJ5OiAnU1BSSU5HIGlzIGEgdG9vbCBmb3IgdW5jb3ZlcmluZyBoaWdoLWRpbWVuc2lvbmFsIHN0cnVjdHVyZSBpbiBzaW5nbGUtY2VsbCBleHByZXNzaW9uIGRhdGEuJyxcbn07XG5cbmNvbnN0IHRmanNUc25lOiBJVml6T3ZlcnZpZXdEYXRhID0ge1xuICBhdXRob3JzOiBbJ1lhbm5pY2sgQXNzb2diYSddLFxuICBjaXRhdGlvbnM6IFtdLFxuICBjb21wYXRpYmlsaXR5OiBbXSxcbiAgZGV0YWlsZWRTdW1tYXJ5OiAnJyxcbiAgZXhhbXBsZXM6IFtzcHJpbmdFeGFtcGxlc1syXSwgc3ByaW5nRXhhbXBsZXNbM11dLFxuICBsaXN0QXNPcmlnaW5hbDogdHJ1ZSxcbiAgbmFtZTogJ3RmanMtdHNuZScsXG4gIHJlbGV2YW50RGF0YTogJ3NjUk5BLXNlcScsXG4gIHJlcG86IHsgbGFzdFVwZGF0ZTogJycsIGxpbms6ICdodHRwczovL2dpdGh1Yi5jb20vdGVuc29yZmxvdy90ZmpzLXRzbmUnLCB2ZXJzaW9uOiAnJyB9LFxuICBzdW1tYXJ5OiAnSW1wcm92ZWQgdFNORSBpbXBsZW1lbnRhdGlvbiB0aGF0IHJ1bnMgaW4gdGhlIGJyb3dzZXIuJyxcbn07XG5cbmV4cG9ydCBjb25zdCBWaXpEYXRhOiB7IFtrZXk6IHN0cmluZ106IElWaXpPdmVydmlld0RhdGEgfSA9IHtcbiAgYW5hdG9tb2dyYW0sXG4gIHNwcmluZyxcbiAgJ3RmanMtdHNuZSc6IHRmanNUc25lLFxuICB0ZmpzVHNuZSxcbn07XG5cbmV4cG9ydCBpbnRlcmZhY2UgSVN0b3J5IHtcbiAgYXV0aG9yczogc3RyaW5nW107XG4gIGRlc2NyaXB0aW9uOiBzdHJpbmc7XG4gIGljb246IHN0cmluZztcbiAgbGluazogc3RyaW5nO1xuICB0aXRsZTogc3RyaW5nO1xufVxuXG5leHBvcnQgY29uc3QgU3RvcmllczogSVN0b3J5W10gPSBbXG4gIHtcbiAgICBhdXRob3JzOiBbJ0NhbGViIFdlaW5yZWInLCAnU2FtdWVsIFdvbG9jaycsICdBbGxvbiBLbGVpbiddLFxuICAgIGRlc2NyaXB0aW9uOlxuICAgICAgJ0FuYWx5c2lzIG9mIDMzLDQ3MyBoZW1hdG9wb2lldGljIHByb2dlbml0b3IgY2VsbHMgYXMgdGhleSBkaWZmZXJlbnRpYXRlIG92ZXIgNiBkYXlzLlxcXG4gICAgICAgQmFyY29kZXMgd2VyZSBpbnRyb2R1Y2VkIGF0IGRheSAwIGFuZCBjZWxsIGxpbmVhZ2UgcmVsYXRpb25zaGlwcyB3ZXJlIHRyYWNlZCBieVxcXG4gICAgICAgaWRlbnRpZnlpbmcgcHJvZ2VueSBmcm9tIHRoZWlyIGJhcmNvZGVzIGluIHNjUk5Bc2VxIG9mIGFsaXF1b3RzIG9mIHRoZSBzYW1lIHBvcHVsYXRpb24gdGFrZW4gYXQgc2V2ZXJhbCB0aW1lcG9pbnRzLicsXG4gICAgaWNvbjogJ2Fzc2V0cy9pY29ucy9leGFtcGxlX2hwY19zZjItc3ByaW5nLnBuZycsXG4gICAgbGluazogJy9kYXRhc2V0P25hbWU9aHBjX3NmMi9mdWxsJnZpej1zcHJpbmcnLFxuICAgIHRpdGxlOiAnVHJhamVjdG9yeSBhbmFseXNpcyBvZiBkaWZmZXJlbnRpYXRpbmcgSFBDcycsXG4gIH0sXG4gIHtcbiAgICBhdXRob3JzOiBbJ0RyZXcgRGlhbWFudG91a29zJywgJ05pY2hvbGFzIEdhdXRoaWVyJ10sXG4gICAgZGVzY3JpcHRpb246ICdBbmFseXNpcyBvZiBzaW5nbGUgY2VsbCB0cmFuc2NyaXB0b21pY3Mgb2YgMjAgbW91c2Ugb3JnYW5zXFxcbiAgICBmcm9tIHRoZSB0YWJ1bGEgbXVyaXMgcHJvamVjdC4nLFxuICAgIGljb246ICdhc3NldHMvaWNvbnMvZXhhbXBsZV90YWJ1bGFybXVyaXNfc3ByaW5nLXRzbmUtYW5hdG9tb2dyYW0ucG5nJyxcbiAgICBsaW5rOiAnL2RhdGFzZXQ/bmFtZT10YWJ1bGFfbXVyaXMvMTBrJnZpej1zcHJpbmcmdml6PXRmanMtdHNuZSZ2aXo9YW5hdG9tb2dyYW0nLFxuICAgIHRpdGxlOiAnRGltZW5zaW9uYWxpdHktcmVkdWN0aW9uIGFuYWx5c2lzIG9mIHRhYnVsYSBtdXJpcycsXG4gIH0sXG5dO1xuXG5leHBvcnQgaW50ZXJmYWNlIElEYXRhc2V0SW5mbyB7XG4gIGF1dGhvcnM6IHN0cmluZ1tdO1xuICBsaW5rczoge1xuICAgIGRldGFpbDogc3RyaW5nO1xuICAgIGFuYWx5c2lzOiBzdHJpbmc7XG4gIH07XG4gIG5hbWU6IHN0cmluZztcbiAgc3VtbWFyeTogc3RyaW5nO1xufVxuXG5leHBvcnQgY29uc3QgdXNlckRhdGFzZXRzOiBJRGF0YXNldEluZm9bXSA9IFtcbiAge1xuICAgIGF1dGhvcnM6IFsnQ2FsZWIgV2VpbnJlYicsICdTYW11ZWwgV29sb2NrJywgJ0FsbG9uIGtsZWluJ10sXG4gICAgbGlua3M6IHtcbiAgICAgIGFuYWx5c2lzOiAnJyxcbiAgICAgIGRldGFpbDogJycsXG4gICAgfSxcbiAgICBuYW1lOiAnRGlmZmVyZW50aWF0aW5nIGhlbWF0b3BvaWV0aWMgY2VsbHMnLFxuICAgIHN1bW1hcnk6XG4gICAgICAnSGVtYXRvcG9pZXRpYyBjZWxscyB3ZXJlIHN1YmplY3RlZCB0byBiYXJjb2RpbmcgYW5kXFxcbmFsaXF1b3RzIHdlcmUgc3ViamVjdGVkIHRvIHNjUk5Bc2VxIGFzIHRoZXkgdW5kZXJ3ZW50XFxcbmRpZmZlcmVudGlhdGlvbi4nLFxuICB9LFxuICB7XG4gICAgYXV0aG9yczogWydUaGUgVGFidWxhIE11cmlzIENvbnNvcnRpdW0nXSxcbiAgICBsaW5rczoge1xuICAgICAgYW5hbHlzaXM6ICcnLFxuICAgICAgZGV0YWlsOiAnJyxcbiAgICB9LFxuICAgIG5hbWU6ICdUYWJ1bGEgbXVyaXMgLSBzY1JOQXNlcSBvZiAyMCBtb3VzZSBvcmdhbnMnLFxuICAgIHN1bW1hcnk6XG4gICAgICAnQSBjb21wZW5kaXVtIG9mIHNpbmdsZS1jZWxsIHRyYW5zY3JpcHRvbWljIGRhdGEgZnJvbSB0aGVcXFxuICBtb2RlbCBvcmdhbmlzbSBNdXMgbXVzY3VsdXMgdGhhdCBjb21wcmlzZXMgbW9yZSB0aGFuXFxcbiAgMTAwLDAwMCBjZWxscyBmcm9tIDIwIG9yZ2FucyBhbmQgdGlzc3VlcycsXG4gIH0sXG5dO1xuXG5leHBvcnQgaW50ZXJmYWNlIElEYXRhc2V0TW9kYWxJdGVtIHtcbiAgZGVzY3JpcHRpb246IHN0cmluZztcbiAgZW5hYmxlZDogYm9vbGVhbjtcbiAgZnVsbE5hbWU6IHN0cmluZztcbiAgc2VydmVyTmVlZGVkOiBib29sZWFuO1xufVxuXG5leHBvcnQgY29uc3QgRGF0YXNldERhdGE6IHsgW2tleTogc3RyaW5nXTogSURhdGFzZXRNb2RhbEl0ZW0gfSA9IHtcbiAgJ2hwYy9mdWxsJzoge1xuICAgIGRlc2NyaXB0aW9uOiAnQW5hbHlzaXMgb2YgdGhlIFJOQXNlcSBwcm9sZXMgZnJvbSA0NzkwIGhlbWF0b3BvaWV0aWMgcHJvZ2VuaXRvciBjZWxscycsXG4gICAgZW5hYmxlZDogdHJ1ZSxcbiAgICBmdWxsTmFtZTogJ0hlbWF0b3BvaWV0aWMgcHJvZ2VuaXRvciBjZWxscycsXG4gICAgc2VydmVyTmVlZGVkOiBmYWxzZSxcbiAgfSxcbiAgJ2hwY19zZjIvZnVsbCc6IHtcbiAgICBkZXNjcmlwdGlvbjpcbiAgICAgICdBbmFseXNpcyBvZiAzMyw0NzMgdGhlIHRyYW5zY3JpcHRpb25hbCBwcm9sZSBvZiBoZW1hdG9wb2lldGljXFxcbiAgICBwcm9nZW5pdG9yIGNlbGxzIGFzIHRoZXkgZGllcmVudGlhdGUgb3ZlciA2IGRheXMnLFxuICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgZnVsbE5hbWU6ICdIZW1hdG9wb2lldGljIHByb2dlbml0b3IgY2VsbHMnLFxuICAgIHNlcnZlck5lZWRlZDogZmFsc2UsXG4gIH0sXG4gICd0YWJ1bGFfbXVyaXMvMTBrJzoge1xuICAgIGRlc2NyaXB0aW9uOlxuICAgICAgJ0Egc3Vic2V0IHBmIDEwLDAwMCByYW5kb21seSBzYW1wbGVkIGNlbGxzIHRha2VuIGZyb20gdGhlIGZ1bGxcXFxuICB0YWJ1bGFfbXVyaXMgZGF0YXNldCAoMjAgb3JnYW5zIGFuZCB0aXNzdWVzIGZyb20gTXVzIG11c2N1bHVzKScsXG4gICAgZW5hYmxlZDogdHJ1ZSxcbiAgICBmdWxsTmFtZTogJ1RhYnVsYSBtdXJpcycsXG4gICAgc2VydmVyTmVlZGVkOiBmYWxzZSxcbiAgfSxcbiAgJ3RhYnVsYV9tdXJpcy9mdWxsJzoge1xuICAgIGRlc2NyaXB0aW9uOlxuICAgICAgJ0EgY29tcGVuZGl1bSBvZiBzaW5nbGUtY2VsbCB0cmFuc2NyaXB0b21pYyBkYXRhIGZyb20gdGhlXFxcbiAgbW9kZWwgb3JnYW5pc20gTXVzIG11c2N1bHVzIHRoYXQgY29tcHJpc2VzIG1vcmUgdGhhblxcXG4gIDEwMCwwMDAgY2VsbHMgZnJvbSAyMCBvcmdhbnMgYW5kIHRpc3N1ZXMnLFxuICAgIGVuYWJsZWQ6IGZhbHNlLFxuICAgIGZ1bGxOYW1lOiAnVGFidWxhIG11cmlzJyxcbiAgICBzZXJ2ZXJOZWVkZWQ6IHRydWUsXG4gIH0sXG4gICd0YWJ1bGFfbXVyaXMvbHVuZyc6IHtcbiAgICBkZXNjcmlwdGlvbjogJ0FuYWx5c2lzIG9mIHRoZSBSTkFzZXEgcHJvbGVzIGZyb20gNDc5MCBoZW1hdG9wb2lldGljXFxcbiAgcHJvZ2VuaXRvciBjZWxscycsXG4gICAgZW5hYmxlZDogZmFsc2UsXG4gICAgZnVsbE5hbWU6ICdUYWJ1bGEgbXVyaXMnLFxuICAgIHNlcnZlck5lZWRlZDogdHJ1ZSxcbiAgfSxcbn07XG4iLCJpbXBvcnQgeyBDSEVMTF9DSEFSVF9FVkVOVF9UWVBFLCBDSEVMTF9DSEFSVF9QSUVDRSB9IGZyb20gJ35jaGVsbC12aXp+L2RhdGEnO1xuXG5leHBvcnQgY2xhc3MgQ2hlbGxDaGFydEV2ZW50IHtcbiAgcHVibGljIGNvbnN0cnVjdG9yKFxuICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpuby1yZXNlcnZlZC1rZXl3b3Jkc1xuICAgIHJlYWRvbmx5IHR5cGU6IENIRUxMX0NIQVJUX0VWRU5UX1RZUEUsXG4gICAgcmVhZG9ubHkgY2hhcnRQaWVjZT86IENIRUxMX0NIQVJUX1BJRUNFLFxuICAgIHJlYWRvbmx5IHNlbGVjdGVkUG9pbnRzOiBudW1iZXJbXSA9IFtdLFxuICAgIHJlYWRvbmx5IHBsb3RseUV2ZW50OiBQYXJ0aWFsPFBsb3RseS5QbG90TW91c2VFdmVudD4gfCBQYXJ0aWFsPFBsb3RseS5QbG90U2VsZWN0aW9uRXZlbnQ+ID0ge30sXG4gICkge31cblxuICBwdWJsaWMgaXNBeGlzKCkge1xuICAgIHJldHVybiB0aGlzLmNoYXJ0UGllY2UgPT09IENIRUxMX0NIQVJUX1BJRUNFLkFYSVM7XG4gIH1cbn1cbiIsImV4cG9ydCAqIGZyb20gJy4vQ2hlbGxDaGFydEV2ZW50JztcbiIsImV4cG9ydCAqIGZyb20gJy4vQW1pbm9BY2lkJztcbmV4cG9ydCAqIGZyb20gJy4vQ2hlbGwxRFNlY3Rpb24nO1xuZXhwb3J0ICogZnJvbSAnLi9DaGVsbENvbmZpZyc7XG5leHBvcnQgKiBmcm9tICcuL0NoZWxsRGF0YSc7XG5leHBvcnQgKiBmcm9tICcuL0NoZWxsUERCJztcbmV4cG9ydCAqIGZyb20gJy4vQ291cGxpbmdDb250YWluZXInO1xuZXhwb3J0ICogZnJvbSAnLi9QbG90bHlEYXRhJztcbmV4cG9ydCAqIGZyb20gJy4vUHJvdGVpbic7XG5leHBvcnQgKiBmcm9tICcuL1NwcmluZyc7XG5leHBvcnQgKiBmcm9tICcuL1RpbnRlZENoZWxsMURTZWN0aW9uJztcbmV4cG9ydCAqIGZyb20gJy4vVml6RGF0YSc7XG5cbmV4cG9ydCAqIGZyb20gJy4vZXZlbnQnO1xuIiwiaW1wb3J0IHsgQ29sb3IgfSBmcm9tICdwbG90bHkuanMtZ2wyZC1kaXN0JztcbmltcG9ydCB7IFNlbWFudGljQ09MT1JTIH0gZnJvbSAnc2VtYW50aWMtdWktcmVhY3QnO1xuXG4vKipcbiAqIENsYXNzIHRvIGFsbG93IGEgbWFwcGluZyBiZXR3ZWVuIGEgdHlwZSBhbmQgYSBjb2xvci5cbiAqXG4gKiBAZXhwb3J0XG4gKi9cbmV4cG9ydCBjbGFzcyBDb2xvck1hcHBlcjxUPiB7XG4gIHB1YmxpYyBzdGF0aWMgREVGQVVMVF9DT0xPUlM6IFNlbWFudGljQ09MT1JTW10gPSBbXG4gICAgJ3JlZCcsXG4gICAgJ2dyZWVuJyxcbiAgICAnYmx1ZScsXG4gICAgJ29yYW5nZScsXG4gICAgJ3B1cnBsZScsXG4gICAgJ3RlYWwnLFxuICAgICdwaW5rJyxcbiAgICAneWVsbG93JyxcbiAgICAndmlvbGV0JyxcbiAgICAnb2xpdmUnLFxuICAgICdicm93bicsXG4gIF07XG5cbiAgLyoqXG4gICAqIFVzZWQgdG8gYXNzb2NpYXRlIGtleXMgd2l0aCBhIENvbG9yLlxuICAgKi9cbiAgcHJvdGVjdGVkIGNvbG9yTWFwOiBNYXA8VCwgQ29sb3I+ID0gbmV3IE1hcDxULCBDb2xvcj4oKTtcblxuICBwdWJsaWMgY29uc3RydWN0b3IocmVhZG9ubHkgY29sb3JzOiBDb2xvcltdID0gQ29sb3JNYXBwZXIuREVGQVVMVF9DT0xPUlMpIHt9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgY29sb3IgZm9yIHRoZSBwcm92aWRlZCBrZXkgLSBpZiB0aGUga2V5IGlzbid0IHN0b3JlZCwgaXQgd2lsbCBiZSBhZGRlZCB1c2luZyB0aGUgc2V0IG9mIGNvbG9ycyBmb3IgdGhpcyBtYXBwZXIuXG4gICAqL1xuICBwdWJsaWMgZ2V0Q29sb3JGb3Ioa2V5OiBUKTogQ29sb3Ige1xuICAgIGlmICghdGhpcy5jb2xvck1hcC5oYXMoa2V5KSkge1xuICAgICAgdGhpcy5hZGRDb2xvclRvTWFwcGVyKGtleSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuY29sb3JNYXAuZ2V0KGtleSkgYXMgQ29sb3I7XG4gIH1cblxuICAvKipcbiAgICogTWV0aG9kIHRvIGFsbG93IGEgdXNlciB0byBqdXN0IGFkZCBhbiBlbnRyeSB0byB0aGUgY29sb3JNYXBwZXIuXG4gICAqXG4gICAqIEBwYXJhbSBrZXkgS2V5IHRvIHN0b3JlLlxuICAgKiBAcGFyYW0gW2NvbG9yXSBBbGxvd3MgYSBjb2xvciB0byBiZSBleHBsaWNpdGx5IHNldCBmb3IgdGhpcyBrZXkuXG4gICAqIEBwYXJhbSBbYWRkVG9Db2xvcnNdIEZsYWcgdG8gYWxsb3cvZGlzYWxsb3cgY29sb3IgdG8gYmUgYWRkZWQgdG8gc2V0IG9mIGNvbG9ycyB1c2VkIGJ5IHRoaXMgQ29sb3JNYXBwZXIuXG4gICAqL1xuICBwdWJsaWMgYWRkRW50cnkoa2V5OiBULCBjb2xvcj86IENvbG9yLCBhZGRUb0NvbG9yczogYm9vbGVhbiA9IHRydWUpIHtcbiAgICBpZiAoIXRoaXMuY29sb3JNYXAuaGFzKGtleSkpIHtcbiAgICAgIHRoaXMuYWRkQ29sb3JUb01hcHBlcihrZXksIGNvbG9yLCBhZGRUb0NvbG9ycyk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIGVudHJ5IGZvciB0aGUgaW50ZXJuYWwgQ29sb3JNYXBwZXIgTWFwLlxuICAgKiBAcGFyYW0ga2V5IEtleSB0byBhZGRcbiAgICogQHBhcmFtIFtjb2xvcl0gRXhwbGljaXQgY29sb3IgdG8gdXNlIGlmIHByb3ZpZGVkLlxuICAgKiBAcGFyYW0gW2FkZFRvQ29sb3JzXSBGbGFnIHRvIGFsbG93L2Rpc2FsbG93IGNvbG9yIHRvIGJlIGFkZGVkIHRvIHNldCBvZiBjb2xvcnMgdXNlZCBieSB0aGlzIENvbG9yTWFwcGVyLlxuICAgKi9cbiAgcHJvdGVjdGVkIGFkZENvbG9yVG9NYXBwZXIoa2V5OiBULCBjb2xvcj86IENvbG9yLCBhZGRUb0NvbG9ycz86IGJvb2xlYW4pIHtcbiAgICB0aGlzLmNvbG9yTWFwLnNldChrZXksIGNvbG9yID8gY29sb3IgOiB0aGlzLmNvbG9yc1t0aGlzLmNvbG9yTWFwLnNpemUgJSB0aGlzLmNvbG9ycy5sZW5ndGhdKTtcbiAgICBpZiAoY29sb3IgJiYgYWRkVG9Db2xvcnMgJiYgIXRoaXMuY29sb3JzLmluY2x1ZGVzKGNvbG9yKSkge1xuICAgICAgdGhpcy5jb2xvcnMucHVzaChjb2xvcik7XG4gICAgfVxuICB9XG59XG4iLCJjb25zdCBnZW5lcmF0ZURlZmF1bHRIZWFkZXJJbmRpY2VzID0gKGl0ZW1zOiBzdHJpbmdbXSk6IHsgW2tleTogc3RyaW5nXTogbnVtYmVyIH0gPT4gKHtcbiAgQV9pOiBpdGVtcy5sZW5ndGggLSAyLFxuICBBX2o6IGl0ZW1zLmxlbmd0aCAtIDEsXG4gIGNuOiAyLFxuICBkaXN0OiAzLFxuICBpOiAwLFxuICBqOiAxLFxufSk7XG5cbi8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpleHBvcnQtbmFtZVxuZXhwb3J0IGNvbnN0IGdldENvdXBsaW5nSGVhZGVySW5kaWNlcyA9IChpdGVtczogc3RyaW5nW10sIGFyZUhlYWRlcnNQcmVzZW50OiBib29sZWFuKSA9PiB7XG4gIGlmICghYXJlSGVhZGVyc1ByZXNlbnQpIHtcbiAgICByZXR1cm4gZ2VuZXJhdGVEZWZhdWx0SGVhZGVySW5kaWNlcyhpdGVtcyk7XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgcmVzdWx0OiB7IFtrZXk6IHN0cmluZ106IG51bWJlciB9ID0ge307XG4gICAgaXRlbXMuZmlsdGVyKGl0ZW0gPT4gaXRlbS5sZW5ndGggPj0gMSkubWFwKGhlYWRlciA9PiB7XG4gICAgICAvLyBUcmltIHRvIHJlbW92ZSB3aGl0ZXNwYWNlLCBuZXdsaW5lcywgY2FycmlhZ2UgcmV0dXJucywgZXRjLlxuICAgICAgcmVzdWx0W2hlYWRlci50cmltKCldID0gaXRlbXMuaW5kZXhPZihoZWFkZXIpO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxufTtcbiIsImltcG9ydCAqIGFzIE5HTCBmcm9tICduZ2wnO1xuXG5pbXBvcnQge1xuICBDaGVsbFBEQixcbiAgQ291cGxpbmdDb250YWluZXIsXG4gIElDb250YWN0TWFwRGF0YSxcbiAgSVNlY29uZGFyeVN0cnVjdHVyZURhdGEsXG4gIElTcHJpbmdDYXRlZ29yaWNhbENvbG9yRGF0YSxcbiAgSVNwcmluZ0NhdGVnb3JpY2FsQ29sb3JEYXRhSW5wdXQsXG4gIElTcHJpbmdHcmFwaERhdGEsXG4gIElTcHJpbmdOb2RlLFxuICBTRUNPTkRBUllfU1RSVUNUVVJFX0NPREVTLFxuICBWSVpfVFlQRSxcbn0gZnJvbSAnfmNoZWxsLXZpen4vZGF0YSc7XG5pbXBvcnQge1xuICBmZXRjaENTVkZpbGUsXG4gIGZldGNoSlNPTkZpbGUsXG4gIGdlbmVyYXRlUmVzaWR1ZU1hcHBpbmcsXG4gIGdldENvdXBsaW5nSGVhZGVySW5kaWNlcyxcbiAgSVJlc2lkdWVNYXBwaW5nLFxuICByZWFkRmlsZUFzVGV4dCxcbn0gZnJvbSAnfmNoZWxsLXZpen4vaGVscGVyJztcblxuZXhwb3J0IGNvbnN0IGZldGNoQXBwcm9wcmlhdGVEYXRhID0gYXN5bmMgKHZpejogVklaX1RZUEUsIGRhdGFEaXI6IHN0cmluZykgPT4ge1xuICBzd2l0Y2ggKHZpeikge1xuICAgIGNhc2UgVklaX1RZUEVbJ1QtU05FJ106XG4gICAgY2FzZSBWSVpfVFlQRVsnVC1TTkUtRlJBTUUnXTpcbiAgICAgIHJldHVybiBmZXRjaFRTbmVDb29yZGluYXRlRGF0YShkYXRhRGlyKTtcbiAgICBjYXNlIFZJWl9UWVBFWydURU5TT1ItVC1TTkUnXTpcbiAgICAgIHJldHVybiBmZXRjaFRlbnNvclRTbmVDb29yZGluYXRlRGF0YShkYXRhRGlyKTtcbiAgICBjYXNlIFZJWl9UWVBFLlNQUklORzpcbiAgICAgIHJldHVybiBmZXRjaFNwcmluZ0RhdGEoZGF0YURpcik7XG4gICAgY2FzZSBWSVpfVFlQRS5OR0w6XG4gICAgICByZXR1cm4gZmV0Y2hOR0xEYXRhRnJvbURpcmVjdG9yeShkYXRhRGlyKTtcbiAgICBjYXNlIFZJWl9UWVBFLkNPTlRBQ1RfTUFQOlxuICAgIGNhc2UgVklaX1RZUEUuSU5GT19QQU5FTDpcbiAgICAgIHJldHVybiBmZXRjaENvbnRhY3RNYXBEYXRhKGRhdGFEaXIpO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoeyBlcnJvcjogYEN1cnJlbnRseSBubyBhcHByb3ByaWF0ZSBkYXRhIGdldHRlciBmb3IgJHt2aXp9YCB9KTtcbiAgfVxufTtcblxuZXhwb3J0IGNvbnN0IGZldGNoQXBwcm9wcmlhdGVEYXRhRnJvbUZpbGUgPSBhc3luYyAodml6OiBWSVpfVFlQRSwgZmlsZTogRmlsZSkgPT4ge1xuICBzd2l0Y2ggKHZpeikge1xuICAgIGNhc2UgVklaX1RZUEUuTkdMOlxuICAgICAgcmV0dXJuIGZldGNoTkdMRGF0YUZyb21GaWxlKGZpbGUpO1xuICAgIGNhc2UgVklaX1RZUEUuQ09OVEFDVF9NQVA6XG4gICAgICByZXR1cm4geyBjb3VwbGluZ1Njb3JlczogZ2V0Q291cGxpbmdTY29yZXNEYXRhKGF3YWl0IHJlYWRGaWxlQXNUZXh0KGZpbGUpKSB9O1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoeyBlcnJvcjogYEN1cnJlbnRseSBubyBhcHByb3ByaWF0ZSBkYXRhIGdldHRlciBmb3IgJHt2aXp9IGZpbGVzYCB9KTtcbiAgfVxufTtcblxuZXhwb3J0IGNvbnN0IGZldGNoU3ByaW5nRGF0YSA9IGFzeW5jIChkYXRhRGlyOiBzdHJpbmcpOiBQcm9taXNlPElTcHJpbmdHcmFwaERhdGE+ID0+IHtcbiAgY29uc3QgY2F0Q29sb3JEYXRhID0gYXdhaXQgZmV0Y2hDYXRlZ29yaWNhbENvbG9yRGF0YShgJHtkYXRhRGlyfS9jYXRlZ29yaWNhbF9jb2xvcmluZ19kYXRhLmpzb25gKTtcblxuICBjb25zdCBub2RlcyA9IG5ldyBBcnJheTxJU3ByaW5nTm9kZT4oKTtcbiAgY29uc3QgY2F0ZWdvcmllcyA9IE9iamVjdC5rZXlzKGNhdENvbG9yRGF0YSk7XG5cbiAgY2F0Q29sb3JEYXRhW2NhdGVnb3JpZXNbMF1dLmxhYmVsX2xpc3QuZm9yRWFjaCgobGFiZWwsIGluZGV4KSA9PiB7XG4gICAgbm9kZXMucHVzaCh7XG4gICAgICBsYWJlbEZvckNhdGVnb3J5OiBjYXRlZ29yaWVzLnJlZHVjZShcbiAgICAgICAgKHByZXYsIGNhdGVnb3J5KSA9PiAoeyAuLi5wcmV2LCBbY2F0ZWdvcnldOiBjYXRDb2xvckRhdGFbY2F0ZWdvcnldLmxhYmVsX2xpc3RbaW5kZXhdIH0pLFxuICAgICAgICB7fSxcbiAgICAgICksXG4gICAgICBudW1iZXI6IGluZGV4LFxuICAgIH0pO1xuICB9KTtcblxuICByZXR1cm4geyBub2RlcyB9O1xufTtcblxuY29uc3QgZmV0Y2hDYXRlZ29yaWNhbENvbG9yRGF0YSA9IGFzeW5jIChmaWxlOiBzdHJpbmcpOiBQcm9taXNlPHsgW2tleTogc3RyaW5nXTogSVNwcmluZ0NhdGVnb3JpY2FsQ29sb3JEYXRhIH0+ID0+IHtcbiAgY29uc3QgaW5wdXQgPSAoYXdhaXQgZmV0Y2hKU09ORmlsZShmaWxlKSkgYXMgSVNwcmluZ0NhdGVnb3JpY2FsQ29sb3JEYXRhSW5wdXQ7XG4gIGNvbnN0IHJlc3VsdDogeyBba2V5OiBzdHJpbmddOiBJU3ByaW5nQ2F0ZWdvcmljYWxDb2xvckRhdGEgfSA9IHt9O1xuICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyhpbnB1dCkpIHtcbiAgICBjb25zdCBjb2xvckRhdGEgPSBpbnB1dFtrZXldO1xuICAgIGlmICghY29sb3JEYXRhLmxhYmVsX2NvbG9ycyB8fCAhY29sb3JEYXRhLmxhYmVsX2xpc3QpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlVuYWJsZSB0byBwYXJzZSBjb2xvciBkYXRhIC0gZG9lcyBpdCBoYXZlIGtleXMgbmFtZWQgJ2xhYmVsX2NvbG9ycycgYW5kICdsYWJlbF9saXN0J1wiKTtcbiAgICB9XG4gICAgY29uc3Qgb3V0cHV0OiBJU3ByaW5nQ2F0ZWdvcmljYWxDb2xvckRhdGEgPSB7XG4gICAgICBsYWJlbF9jb2xvcnM6IHt9LFxuICAgICAgbGFiZWxfbGlzdDogY29sb3JEYXRhLmxhYmVsX2xpc3QsXG4gICAgfTtcblxuICAgIGNvbnN0IHsgbGFiZWxfY29sb3JzIH0gPSBpbnB1dFtPYmplY3Qua2V5cyhpbnB1dClbMF1dO1xuXG4gICAgLy8gVGhlIGlucHV0IGZpbGUgbWlnaHQgc3BlY2lmeSBoZXggdmFsdWVzIGFzIGVpdGhlciAweHJyZ2diYiBvciAjcnJnZ2JiLCBzbyB3ZSBuZWVkIHRvIGNvbnZlcnQgdGhlIGlucHV0IHRvIGEgY29uc2lzdGVudCBvdXRwdXQgZm9ybWF0LlxuICAgIGZvciAoY29uc3QgbGFiZWxDb2xvcktleSBvZiBPYmplY3Qua2V5cyhsYWJlbF9jb2xvcnMpKSB7XG4gICAgICBjb25zdCBoZXggPSBsYWJlbF9jb2xvcnNbbGFiZWxDb2xvcktleV07XG4gICAgICBpZiAodHlwZW9mIGhleCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgb3V0cHV0LmxhYmVsX2NvbG9yc1tsYWJlbENvbG9yS2V5XSA9IGhleDtcbiAgICAgIH0gZWxzZSBpZiAoaGV4LmNoYXJBdCgwKSA9PT0gJyMnKSB7XG4gICAgICAgIG91dHB1dC5sYWJlbF9jb2xvcnNbbGFiZWxDb2xvcktleV0gPSBOdW1iZXIucGFyc2VJbnQoYDB4JHtoZXguc2xpY2UoMSl9YCwgMTYpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb3V0cHV0LmxhYmVsX2NvbG9yc1tsYWJlbENvbG9yS2V5XSA9IE51bWJlci5wYXJzZUludChoZXgsIDE2KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXN1bHRba2V5XSA9IG91dHB1dDtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5leHBvcnQgY29uc3QgZmV0Y2hTcHJpbmdDb29yZGluYXRlRGF0YSA9IGFzeW5jIChmaWxlOiBzdHJpbmcpID0+IHtcbiAgY29uc3QgY29vcmRpbmF0ZVRleHQ6IHN0cmluZyA9IGF3YWl0IGZldGNoQ1NWRmlsZShmaWxlKTtcblxuICBjb25zdCBjb29yZGluYXRlczogbnVtYmVyW11bXSA9IFtdO1xuICBjb25zdCByb3dzID0gY29vcmRpbmF0ZVRleHQgPyBjb29yZGluYXRlVGV4dC5zcGxpdCgnXFxuJykgOiBbXTtcbiAgcm93cy5mb3JFYWNoKChlbnRyeSwgaW5kZXgsIGFycmF5KSA9PiB7XG4gICAgY29uc3QgaXRlbXMgPSBlbnRyeS5zcGxpdCgnLCcpO1xuICAgIGlmIChpdGVtcy5sZW5ndGggPj0gMykge1xuICAgICAgY29uc3QgeHggPSBwYXJzZUZsb2F0KGl0ZW1zWzFdLnRyaW0oKSk7XG4gICAgICBjb25zdCB5eSA9IHBhcnNlRmxvYXQoaXRlbXNbMl0udHJpbSgpKTtcbiAgICAgIGNvbnN0IG5uID0gcGFyc2VJbnQoaXRlbXNbMF0udHJpbSgpLCAxMCk7XG4gICAgICBjb29yZGluYXRlc1tubl0gPSBbeHgsIHl5XTtcbiAgICB9IGVsc2UgaWYgKGVudHJ5LmxvY2FsZUNvbXBhcmUoJycpICE9PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuYWJsZSB0byBwYXJzZSBjb29yZGluYXRlIGRhdGEgLSBSb3cgJHtpbmRleH0gZG9lcyBub3QgaGF2ZSBhdCBsZWFzdCAzIGNvbHVtbnMhYCk7XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gY29vcmRpbmF0ZXM7XG59O1xuXG5leHBvcnQgY29uc3QgZmV0Y2hUU25lQ29vcmRpbmF0ZURhdGEgPSBhc3luYyAoZGF0YURpcjogc3RyaW5nKSA9PiB7XG4gIGNvbnN0IGNvb3JkVGV4dDogc3RyaW5nID0gYXdhaXQgZmV0Y2hDU1ZGaWxlKGAke2RhdGFEaXJ9L3RzbmVfb3V0cHV0LmNzdmApO1xuICBjb25zdCByZXN1bHQ6IG51bWJlcltdW10gPSBbXTtcbiAgY29vcmRUZXh0LnNwbGl0KCdcXG4nKS5mb3JFYWNoKGVudHJ5ID0+IHtcbiAgICBpZiAoZW50cnkubGVuZ3RoID4gMCkge1xuICAgICAgY29uc3QgaXRlbXMgPSBlbnRyeS5zcGxpdCgnLCcpO1xuICAgICAgY29uc3QgY29vcmRpbmF0ZXMgPSBbcGFyc2VGbG9hdChpdGVtc1swXSksIHBhcnNlRmxvYXQoaXRlbXNbMV0pXTtcbiAgICAgIHJlc3VsdC5wdXNoKGNvb3JkaW5hdGVzKTtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5leHBvcnQgY29uc3QgZmV0Y2hUZW5zb3JUU25lQ29vcmRpbmF0ZURhdGFGcm9tRmlsZSA9IGFzeW5jIChmaWxlTG9jYXRpb246IHN0cmluZykgPT4ge1xuICBjb25zdCBjb29yZFRleHQ6IHN0cmluZyA9IGF3YWl0IGZldGNoQ1NWRmlsZShmaWxlTG9jYXRpb24pO1xuICBjb25zdCBtYXRyaXggPSBuZXcgQXJyYXk8bnVtYmVyW10+KCk7XG4gIGZvciAoY29uc3Qgcm93IG9mIGNvb3JkVGV4dC5zcGxpdCgnXFxuJykpIHtcbiAgICBpZiAocm93Lmxlbmd0aCA+PSAxKSB7XG4gICAgICBtYXRyaXgucHVzaChyb3cuc3BsaXQoJywnKS5tYXAocGFyc2VGbG9hdCkpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBtYXRyaXg7XG59O1xuXG5leHBvcnQgY29uc3QgZmV0Y2hUZW5zb3JUU25lQ29vcmRpbmF0ZURhdGEgPSBhc3luYyAoZGF0YURpcjogc3RyaW5nKSA9PiB7XG4gIHJldHVybiBmZXRjaFRlbnNvclRTbmVDb29yZGluYXRlRGF0YUZyb21GaWxlKGAke2RhdGFEaXJ9L3RzbmVfbWF0cml4LmNzdmApO1xufTtcblxuZXhwb3J0IGNvbnN0IGZldGNoR3JhcGhEYXRhID0gYXN5bmMgKGZpbGU6IHN0cmluZykgPT4ge1xuICBjb25zdCBkYXRhID0gKGF3YWl0IGZldGNoSlNPTkZpbGUoZmlsZSkpIGFzIElTcHJpbmdHcmFwaERhdGE7XG4gIGlmICghZGF0YS5ub2RlcyB8fCAhZGF0YS5saW5rcykge1xuICAgIHRocm93IG5ldyBFcnJvcihcIlVuYWJsZSB0byBwYXJzZSBncmFwaCBkYXRhIC0gZG9lcyBpdCBoYXZlIGtleXMgbmFtZWQgJ25vZGVzJyBhbmQgJ2xpbmtzJ1wiKTtcbiAgfVxuXG4gIHJldHVybiBkYXRhO1xufTtcblxuZXhwb3J0IGNvbnN0IGZldGNoTkdMRGF0YUZyb21EaXJlY3RvcnkgPSBhc3luYyAoZGlyOiBzdHJpbmcpID0+IHtcbiAgaWYgKGRpci5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoJ0VtcHR5IHBhdGguJyk7XG4gIH1cbiAgY29uc3QgZmlsZSA9IGAke2Rpcn0vcHJvdGVpbi5wZGJgO1xuXG4gIHJldHVybiBmZXRjaE5HTERhdGFGcm9tRmlsZShmaWxlKTtcbn07XG5cbmV4cG9ydCBjb25zdCBmZXRjaE5HTERhdGFGcm9tRmlsZSA9IGFzeW5jIChmaWxlOiBzdHJpbmcgfCBGaWxlIHwgQmxvYiwgcGFyYW1zOiBQYXJ0aWFsPE5HTC5JTG9hZGVyUGFyYW1ldGVycz4gPSB7fSkgPT5cbiAgKGF3YWl0IE5HTC5hdXRvTG9hZChmaWxlLCBwYXJhbXMpKSBhcyBOR0wuU3RydWN0dXJlO1xuXG5leHBvcnQgY29uc3QgZmV0Y2hDb250YWN0TWFwRGF0YSA9IGFzeW5jIChkaXI6IHN0cmluZyk6IFByb21pc2U8SUNvbnRhY3RNYXBEYXRhPiA9PiB7XG4gIGlmIChkaXIubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIFByb21pc2UucmVqZWN0KCdFbXB0eSBwYXRoLicpO1xuICB9XG4gIGNvbnN0IGNvbnRhY3RNYXBGaWxlcyA9IFsnY291cGxpbmdfc2NvcmVzLmNzdicsICdyZXNpZHVlX21hcHBpbmcuY3N2J107XG4gIGNvbnN0IHByb21pc2VSZXN1bHRzID0gYXdhaXQgUHJvbWlzZS5hbGwoY29udGFjdE1hcEZpbGVzLm1hcChhc3luYyBmaWxlID0+IGZldGNoQ1NWRmlsZShgJHtkaXJ9LyR7ZmlsZX1gKSkpO1xuICBjb25zdCBwZGJEYXRhID0gYXdhaXQgQ2hlbGxQREIuY3JlYXRlUERCKGAke2Rpcn0vcHJvdGVpbi5wZGJgKTtcblxuICByZXR1cm4ge1xuICAgIGNvdXBsaW5nU2NvcmVzOiBnZXRDb3VwbGluZ1Njb3Jlc0RhdGEocHJvbWlzZVJlc3VsdHNbMF0sIGdlbmVyYXRlUmVzaWR1ZU1hcHBpbmcocHJvbWlzZVJlc3VsdHNbMV0pKSxcbiAgICBwZGJEYXRhLFxuICAgIHNlY29uZGFyeVN0cnVjdHVyZXM6IFtdLFxuICB9O1xufTtcblxuLyoqXG4gKiBQYXJzZXMgYSBjb3VwbGluZ19zY29yZXMuY3N2IGZpbGUgdG8gZ2VuZXJhdGUgdGhlIGFwcHJvcHJpYXRlIGRhdGEgc3RydWN0dXJlLlxuICpcbiAqICFJbXBvcnRhbnQhXG4gKiBDdXJyZW50bHkgMTIgZmllbGRzIGFyZSBhc3N1bWVkIHRvIGJlIHBhcnQgb2YgYSBzaW5nbGUgY291cGxpbmcgc2NvcmUuXG4gKiBBcyBzdWNoLCBhbnkgcm93cyB3aXRoIGxlc3Mgd2lsbCBiZSBpZ25vcmVkLlxuICpcbiAqIEBwYXJhbSBsaW5lIFRoZSBjc3YgZmlsZSBhcyBhIHNpbmdsZSBzdHJpbmcuXG4gKiBAcGFyYW0gcmVzaWR1ZU1hcHBpbmcgTWFwcyB0aGUgY291cGxpbmdfc2NvcmUuY3N2IHJlc2lkdWUgbnVtYmVyIHRvIHRoZSByZXNpZHVlIG51bWJlciBmb3IgdGhlIFBEQi5cbiAqIEByZXR1cm5zIEFycmF5IG9mIENvdXBsaW5nU2NvcmVzIHN1aXRhYmxlIGZvciBjaGVsbC12aXogY29uc3VtcHRpb24uXG4gKi9cbmV4cG9ydCBjb25zdCBnZXRDb3VwbGluZ1Njb3Jlc0RhdGEgPSAobGluZTogc3RyaW5nLCByZXNpZHVlTWFwcGluZzogSVJlc2lkdWVNYXBwaW5nW10gPSBbXSk6IENvdXBsaW5nQ29udGFpbmVyID0+IHtcbiAgY29uc3QgaGVhZGVyUm93ID0gbGluZS5zcGxpdCgnXFxuJylbMF0uc3BsaXQoJywnKTtcbiAgY29uc3QgaXNIZWFkZXJQcmVzZW50ID0gaXNDb3VwbGluZ0hlYWRlclByZXNlbnQoaGVhZGVyUm93KTtcbiAgY29uc3QgaGVhZGVySW5kaWNlcyA9IGdldENvdXBsaW5nSGVhZGVySW5kaWNlcyhoZWFkZXJSb3csIGlzSGVhZGVyUHJlc2VudCk7XG4gIGNvbnN0IGNvdXBsaW5nU2NvcmVzID0gbmV3IENvdXBsaW5nQ29udGFpbmVyKCk7XG4gIGxpbmVcbiAgICAuc3BsaXQoJ1xcbicpXG4gICAgLnNsaWNlKGlzSGVhZGVyUHJlc2VudCA/IDEgOiAwKVxuICAgIC5maWx0ZXIocm93ID0+IHJvdy5zcGxpdCgnLCcpLmxlbmd0aCA+PSAyKVxuICAgIC5tYXAocm93ID0+IHtcbiAgICAgIGNvbnN0IGl0ZW1zID0gcm93LnNwbGl0KCcsJyk7XG4gICAgICBjb25zdCBzY29yZSA9IGdldENvdXBsaW5nU2NvcmVGcm9tQ1NWUm93KGl0ZW1zLCBoZWFkZXJJbmRpY2VzKTtcbiAgICAgIGlmIChyZXNpZHVlTWFwcGluZy5sZW5ndGggPj0gMSkge1xuICAgICAgICBjb25zdCBtYXBwaW5nSW5kZXhJID0gcmVzaWR1ZU1hcHBpbmcuZmluZEluZGV4KG1hcHBpbmcgPT4gbWFwcGluZy5jb3VwbGluZ3NSZXNubyA9PT0gc2NvcmUuaSk7XG4gICAgICAgIGNvbnN0IG1hcHBpbmdJbmRleEogPSByZXNpZHVlTWFwcGluZy5maW5kSW5kZXgobWFwcGluZyA9PiBtYXBwaW5nLmNvdXBsaW5nc1Jlc25vID09PSBzY29yZS5qKTtcbiAgICAgICAgY291cGxpbmdTY29yZXMuYWRkQ291cGxpbmdTY29yZSh7XG4gICAgICAgICAgLi4uc2NvcmUsXG4gICAgICAgICAgQV9pOiByZXNpZHVlTWFwcGluZ1ttYXBwaW5nSW5kZXhJXS5wZGJSZXNDb2RlLFxuICAgICAgICAgIEFfajogcmVzaWR1ZU1hcHBpbmdbbWFwcGluZ0luZGV4Sl0ucGRiUmVzQ29kZSxcbiAgICAgICAgICBpOiByZXNpZHVlTWFwcGluZ1ttYXBwaW5nSW5kZXhJXS5wZGJSZXNubyxcbiAgICAgICAgICBqOiByZXNpZHVlTWFwcGluZ1ttYXBwaW5nSW5kZXhKXS5wZGJSZXNubyxcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb3VwbGluZ1Njb3Jlcy5hZGRDb3VwbGluZ1Njb3JlKHNjb3JlKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICByZXR1cm4gY291cGxpbmdTY29yZXM7XG59O1xuXG5jb25zdCBpc0NvdXBsaW5nSGVhZGVyUHJlc2VudCA9IChoZWFkZXJSb3c6IHN0cmluZ1tdKSA9PlxuICBbJ2NuJywgJ2Rpc3QnLCAnaScsICdqJ10uZmlsdGVyKHJvdyA9PiBoZWFkZXJSb3cuaW5jbHVkZXMocm93KSkubGVuZ3RoID49IDE7XG5cbmNvbnN0IGdldENvdXBsaW5nU2NvcmVGcm9tQ1NWUm93ID0gKHJvdzogc3RyaW5nW10sIGhlYWRlckluZGljZXM6IHsgW2tleTogc3RyaW5nXTogbnVtYmVyIH0pID0+XG4gIE9iamVjdC5lbnRyaWVzKGhlYWRlckluZGljZXMpLnJlZHVjZShcbiAgICAocHJldiwgaGVhZGVyTmFtZSkgPT4ge1xuICAgICAgY29uc3QgY291cGxpbmdLZXkgPSBoZWFkZXJOYW1lWzBdO1xuICAgICAgY29uc3QgY291cGxpbmdLZXlJbmRleCA9IGhlYWRlck5hbWVbMV07XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIC4uLnByZXYsXG4gICAgICAgIFtjb3VwbGluZ0tleV06IGlzTmFOKE51bWJlcihyb3dbY291cGxpbmdLZXlJbmRleF0pKSA/IHJvd1tjb3VwbGluZ0tleUluZGV4XSA6IE51bWJlcihyb3dbY291cGxpbmdLZXlJbmRleF0pLFxuICAgICAgfTtcbiAgICB9LFxuICAgIHsgaTogLTEsIGo6IC0xIH0sXG4gICk7XG5cbmV4cG9ydCBjb25zdCBhdWdtZW50Q291cGxpbmdTY29yZXNXaXRoUmVzaWR1ZU1hcHBpbmcgPSAoXG4gIGNvdXBsaW5nU2NvcmVzOiBDb3VwbGluZ0NvbnRhaW5lcixcbiAgcmVzaWR1ZU1hcHBpbmc6IElSZXNpZHVlTWFwcGluZ1tdID0gW10sXG4pOiBDb3VwbGluZ0NvbnRhaW5lciA9PiB7XG4gIGNvbnN0IHJlc3VsdCA9IG5ldyBDb3VwbGluZ0NvbnRhaW5lcigpO1xuICBmb3IgKGNvbnN0IHNjb3JlIG9mIGNvdXBsaW5nU2NvcmVzKSB7XG4gICAgY29uc3QgbWFwcGVkSW5kZXhJID0gcmVzaWR1ZU1hcHBpbmcuZmluZEluZGV4KG1hcHBpbmcgPT4gbWFwcGluZy5jb3VwbGluZ3NSZXNubyA9PT0gc2NvcmUuaSk7XG4gICAgY29uc3QgbWFwcGVkSW5kZXhKID0gcmVzaWR1ZU1hcHBpbmcuZmluZEluZGV4KG1hcHBpbmcgPT4gbWFwcGluZy5jb3VwbGluZ3NSZXNubyA9PT0gc2NvcmUuaik7XG5cbiAgICByZXN1bHQuYWRkQ291cGxpbmdTY29yZSh7XG4gICAgICBBX2k6IHJlc2lkdWVNYXBwaW5nW21hcHBlZEluZGV4SV0ucGRiUmVzQ29kZSxcbiAgICAgIEFfajogcmVzaWR1ZU1hcHBpbmdbbWFwcGVkSW5kZXhKXS5wZGJSZXNDb2RlLFxuICAgICAgY246IHNjb3JlLmNuLFxuICAgICAgZGlzdDogc2NvcmUuZGlzdCxcbiAgICAgIGk6IHJlc2lkdWVNYXBwaW5nW21hcHBlZEluZGV4SV0ucGRiUmVzbm8sXG4gICAgICBqOiByZXNpZHVlTWFwcGluZ1ttYXBwZWRJbmRleEpdLnBkYlJlc25vLFxuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8qKlxuICogUGFyc2VzIGEgZGlzdGFuY2VfbWFwLmNzdiBmaWxlIHRvIGdlbmVyYXRlIHRoZSBhcHByb3ByaWF0ZSBzZWNvbmRhcnkgc3RydWN0dXJlIG1hcHBpbmcuXG4gKlxuICogIUltcG9ydGFudCFcbiAqIFRoZSBmaXJzdCBsaW5lIGluIHRoZSBjc3Ygd2lsbCBiZSBpZ25vcmVkIGFzIGl0IGlzIGFzc3VtZWQgdG8gYmUgYSBjc3YgaGVhZGVyLlxuICpcbiAqICFJbXBvcnRhbnQhXG4gKiBDdXJyZW50bHkgMyBmaWVsZHMgYXJlIGFzc3VtZWQgdG8gYmUgcGFydCBvZiBhIHNpbmdsZSBlbnRyeSwgd2l0aCB0aGUgc2Vjb25kIGFuZCB0aGlyZCBhY3R1YWxseSBiZWluZyByZWxldmFudC5cbiAqIEFzIHN1Y2gsIGFueSBvdGhlciByb3dzIHdpbGwgYmUgaWdub3JlZC5cbiAqXG4gKiBAcGFyYW0gbGluZSBUaGUgY3N2IGZpbGUgYXMgYSBzaW5nbGUgc3RyaW5nLlxuICogQHJldHVybnMgQXJyYXkgb2YgU2Vjb25kYXJ5U3RydWN0dXJlIG1hcHBpbmdzIHN1aXRhYmxlIGZvciBjaGVsbC12aXogY29uc3VtcHRpb24uXG4gKi9cbmV4cG9ydCBjb25zdCBnZXRTZWNvbmRhcnlTdHJ1Y3R1cmVEYXRhID0gKGxpbmU6IHN0cmluZyk6IElTZWNvbmRhcnlTdHJ1Y3R1cmVEYXRhW10gPT4ge1xuICByZXR1cm4gbGluZVxuICAgIC5zcGxpdCgnXFxuJylcbiAgICAuc2xpY2UoMSlcbiAgICAuZmlsdGVyKHJvdyA9PiByb3cuc3BsaXQoJywnKS5sZW5ndGggPj0gMylcbiAgICAubWFwKHJvdyA9PiB7XG4gICAgICBjb25zdCBpdGVtcyA9IHJvdy5zcGxpdCgnLCcpO1xuXG4gICAgICByZXR1cm4ge1xuICAgICAgICByZXNubzogcGFyc2VGbG9hdChpdGVtc1sxXSksXG4gICAgICAgIHN0cnVjdElkOiBpdGVtc1syXSBhcyBrZXlvZiB0eXBlb2YgU0VDT05EQVJZX1NUUlVDVFVSRV9DT0RFUyxcbiAgICAgIH07XG4gICAgfSk7XG59O1xuXG4vKlxuVE9ETyBDdXJyZW50bHkgbm90IGJlaW5nIHVzZWQgYnkgU3ByaW5nLiBSZW1vdmU/IFVzZSBpbiBmdXR1cmUgU3ByaW5nIHdvcms/XG5leHBvcnQgY29uc3QgZmV0Y2hDb2xvckRhdGEgPSBhc3luYyAoZmlsZTogc3RyaW5nKSA9PiB7XG4gIGNvbnN0IGNvbG9yVGV4dDogc3RyaW5nID0gYXdhaXQgZmV0Y2hDU1ZGaWxlKGZpbGUpO1xuICBjb25zdCBkaWN0OiB7IFtrOiBzdHJpbmddOiBhbnkgfSA9IHt9O1xuICBjb2xvclRleHQuc3BsaXQoJ1xcbicpLmZvckVhY2goKGVudHJ5LCBpbmRleCwgYXJyYXkpID0+IHtcbiAgICBpZiAoZW50cnkubGVuZ3RoID4gMCkge1xuICAgICAgY29uc3QgaXRlbXMgPSBlbnRyeS5zcGxpdCgnLCcpO1xuICAgICAgY29uc3QgZ2VuZSA9IGl0ZW1zWzBdO1xuICAgICAgY29uc3QgZXhwQXJyYXk6IGFueVtdID0gW107XG4gICAgICBpdGVtcy5mb3JFYWNoKChlLCBpLCBhKSA9PiB7XG4gICAgICAgIGlmIChpID4gMCkge1xuICAgICAgICAgIGV4cEFycmF5LnB1c2gocGFyc2VGbG9hdChlKSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgZGljdFtnZW5lXSA9IGV4cEFycmF5O1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBkaWN0O1xufTtcbiovXG4iLCJleHBvcnQgY29uc3QgZmV0Y2hDU1ZGaWxlID0gYXN5bmMgKGZpbGVuYW1lOiBzdHJpbmcpID0+IHtcbiAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChmaWxlbmFtZSk7XG4gIGlmIChyZXNwb25zZS5vaykge1xuICAgIHJldHVybiByZXNwb25zZS50ZXh0KCk7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGdlbkVycm9yTXNnKCdDU1YnLCByZXNwb25zZSkpO1xuICB9XG59O1xuXG5leHBvcnQgY29uc3QgZmV0Y2hKU09ORmlsZSA9IGFzeW5jIChmaWxlbmFtZTogc3RyaW5nKSA9PiB7XG4gIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goZmlsZW5hbWUpO1xuICBpZiAocmVzcG9uc2Uub2spIHtcbiAgICByZXR1cm4gcmVzcG9uc2UuanNvbigpO1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcihnZW5FcnJvck1zZygnSlNPTicsIHJlc3BvbnNlKSk7XG4gIH1cbn07XG5cbmNvbnN0IGdlbkVycm9yTXNnID0gKGZpbGVUeXBlOiBzdHJpbmcsIHJlc3BvbnNlOiBSZXNwb25zZSkgPT5cbiAgYENoZWxsLXZpeiBlcnJvciBmZXRjaGluZyAke2ZpbGVUeXBlfSBGaWxlIVxcblN0YXR1czogJHtyZXNwb25zZS5zdGF0dXN9XFxuTWVzc2FnZTogJHtyZXNwb25zZS5zdGF0dXNUZXh0fVxcbmA7XG5cbi8vIGh0dHBzOi8vYmxvZy5zaG92b25oYXNhbi5jb20vdXNpbmctcHJvbWlzZXMtd2l0aC1maWxlcmVhZGVyL1xuZXhwb3J0IGNvbnN0IHJlYWRGaWxlQXNUZXh0ID0gYXN5bmMgKGlucHV0RmlsZTogRmlsZSkgPT4ge1xuICBjb25zdCB0ZW1wb3JhcnlGaWxlUmVhZGVyID0gbmV3IEZpbGVSZWFkZXIoKTtcblxuICByZXR1cm4gbmV3IFByb21pc2U8c3RyaW5nPigocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgdGVtcG9yYXJ5RmlsZVJlYWRlci5vbmVycm9yID0gKCkgPT4ge1xuICAgICAgdGVtcG9yYXJ5RmlsZVJlYWRlci5hYm9ydCgpO1xuICAgICAgcmVqZWN0KCdQcm9ibGVtIHBhcnNpbmcgaW5wdXQgZmlsZS4nKTtcbiAgICB9O1xuXG4gICAgdGVtcG9yYXJ5RmlsZVJlYWRlci5vbmxvYWQgPSAoKSA9PiB7XG4gICAgICByZXNvbHZlKHRlbXBvcmFyeUZpbGVSZWFkZXIucmVzdWx0IGFzIHN0cmluZyk7XG4gICAgfTtcbiAgICB0ZW1wb3JhcnlGaWxlUmVhZGVyLnJlYWRBc1RleHQoaW5wdXRGaWxlKTtcbiAgfSk7XG59O1xuIiwiaW1wb3J0ICogYXMgTkdMIGZyb20gJ25nbCc7XG5cbmltcG9ydCB7IFJFU0lEVUVfVFlQRSwgU0VDT05EQVJZX1NUUlVDVFVSRV9TRUNUSU9OIH0gZnJvbSAnfmNoZWxsLXZpen4vZGF0YSc7XG5cbmV4cG9ydCBjb25zdCBkZWZhdWx0UmVwUGFyYW1zOiBQYXJ0aWFsPE5HTC5JU3RydWN0dXJlUmVwcmVzZW50YXRpb25QYXJhbXM+ID0ge1xuICBjb2xvcjogJ3JlZCcsXG4gIGxhYmVsQmFja2dyb3VuZDogdHJ1ZSxcbiAgbGFiZWxCYWNrZ3JvdW5kQ29sb3I6ICdsaWdodGdyZXknLFxuICBsYWJlbEJhY2tncm91bmRNYXJnaW46IDAuNzUsXG4gIGxhYmVsQm9yZGVyOiB0cnVlLFxuICBsYWJlbEJvcmRlckNvbG9yOiAnd2hpdGUnLFxuICBsYWJlbEJvcmRlcldpZHRoOiAwLjMsXG4gIGxhYmVsQ29sb3I6ICdibGFjaycsXG4gIGxhYmVsU2l6ZTogNSxcbiAgbGFiZWxVbml0OiAnYW5nc3Ryb20nLFxuICBsYWJlbFpPZmZzZXQ6IDM1LFxufTtcblxuLyoqXG4gKiBEcmF3cyBhIGxpbmUgYmV0d2VlbiB0d28gcmVzaWR1ZXMgaW4gTkdMLlxuICpcbiAqIEBwYXJhbSBzdHJ1Y3R1cmVDb21wb25lbnQgVGhlIE5HTCBTdHJ1Y3R1cmUgZm9yIHdoaWNoIHRoZXNlIHJlc2lkdWVzIGJlbG9uZyB0by5cbiAqIEBwYXJhbSBzZWxlY3Rpb24gVGhlIFtOR0wgU2VsZWN0aW9uXShodHRwOi8vbmdsdmlld2VyLm9yZy9uZ2wvYXBpL21hbnVhbC9zZWxlY3Rpb24tbGFuZ3VhZ2UuaHRtbCkgZGVmaW5pbmcgdGhlIHJlc2lkdWVzLlxuICovXG5leHBvcnQgY29uc3QgY3JlYXRlRGlzdGFuY2VSZXByZXNlbnRhdGlvbiA9IChcbiAgc3RydWN0dXJlQ29tcG9uZW50OiBOR0wuU3RydWN0dXJlQ29tcG9uZW50LFxuICBzZWxlY3Rpb246IHN0cmluZyB8IG51bWJlcltdLFxuICBwYXJhbXM6IFBhcnRpYWw8TkdMLklTdHJ1Y3R1cmVSZXByZXNlbnRhdGlvblBhcmFtcz4gPSB7fSxcbikgPT5cbiAgc3RydWN0dXJlQ29tcG9uZW50LmFkZFJlcHJlc2VudGF0aW9uKCdkaXN0YW5jZScsIHtcbiAgICAuLi5kZWZhdWx0UmVwUGFyYW1zLFxuICAgIC4uLnBhcmFtcyxcbiAgICBhdG9tUGFpcjogQXJyYXkuaXNBcnJheShzZWxlY3Rpb24pID8gW3NlbGVjdGlvbl0gOiBbc2VsZWN0aW9uLnNwbGl0KCcsJyldLFxuICB9KTtcblxuLyoqXG4gKiBNYXJrcyBhIHNldCBvZiByZXNpZHVlcyB3aXRoIGEgYmFsbCtzdGljayByZXByZXNlbnRhdGlvbiBpbiBOR0wuXG4gKlxuICogQHBhcmFtIHN0cnVjdHVyZUNvbXBvbmVudCBUaGUgTkdMIFN0cnVjdHVyZSBmb3Igd2hpY2ggdGhlc2UgcmVzaWR1ZXMgYmVsb25nIHRvLlxuICogQHBhcmFtIHJlc2lkdWVzIFRoZSByZXNpZHVlcyB0byBtYXJrLlxuICovXG5leHBvcnQgY29uc3QgY3JlYXRlQmFsbFN0aWNrUmVwcmVzZW50YXRpb24gPSAoc3RydWN0dXJlQ29tcG9uZW50OiBOR0wuU3RydWN0dXJlQ29tcG9uZW50LCByZXNpZHVlczogUkVTSURVRV9UWVBFW10pID0+XG4gIHN0cnVjdHVyZUNvbXBvbmVudC5hZGRSZXByZXNlbnRhdGlvbignYmFsbCtzdGljaycsIHtcbiAgICBzZWxlOiByZXNpZHVlcy5qb2luKCcsICcpLFxuICB9KTtcblxuLyoqXG4gKiBIaWdobGlnaHRzIGEgc2Vjb25kYXJ5IHN0cnVjdHVyZSBpbiBOR0wuXG4gKlxuICogQHBhcmFtIHN0cnVjdHVyZUNvbXBvbmVudCBUaGUgTkdMIFN0cnVjdHVyZSBmb3Igd2hpY2ggdGhlc2UgcmVzaWR1ZXMgYmVsb25nIHRvLlxuICogQHBhcmFtIHNlY3Rpb24gVGhlIHNlY29uZGFyeSBzdHJ1Y3R1cmUgc2VjdGlvbiB0byBoaWdobGlnaHQuXG4gKiBAcGFyYW0gW3JhZGl1c1NjYWxlPTVdIEhvdyBsYXJnZSB0byBtYWtlIHRoZSByaWJib24gaGlnaGxpZ2h0LlxuICogQHBhcmFtIFtjb2xvcj0ncGluayddIFRoZSBjb2xvciBvZiB0aGUgcmliYm9uIGhpZ2hsaWdodC5cbiAqL1xuZXhwb3J0IGNvbnN0IGNyZWF0ZVNlY1N0cnVjdFJlcHJlc2VudGF0aW9uID0gKFxuICBzdHJ1Y3R1cmVDb21wb25lbnQ6IE5HTC5TdHJ1Y3R1cmVDb21wb25lbnQsXG4gIHNlY3Rpb246IFNFQ09OREFSWV9TVFJVQ1RVUkVfU0VDVElPTixcbiAgcmFkaXVzU2NhbGU6IG51bWJlciA9IDIsXG4gIGNvbG9yOiBzdHJpbmcgPSAnI2ZlYjgzZicsXG4pID0+IHtcbiAgY29uc3QgcmVwID0gc3RydWN0dXJlQ29tcG9uZW50LmFkZFJlcHJlc2VudGF0aW9uKCdjYXJ0b29uJywge1xuICAgIGNvbG9yLFxuICAgIHJhZGl1c1NjYWxlLFxuICAgIHNlbGU6IGAke3NlY3Rpb24uc3RhcnR9LSR7c2VjdGlvbi5lbmR9YCxcbiAgfSk7XG4gIHJlcC5zZXRQYXJhbWV0ZXJzKHsgd2lyZWZyYW1lOiB0cnVlIH0pO1xuXG4gIHJldHVybiByZXA7XG59O1xuIiwiaW1wb3J0IHsgSUNvbnRhY3RNYXBDaGFydERhdGEgfSBmcm9tICd+Y2hlbGwtdml6fi9jb21wb25lbnQnO1xuaW1wb3J0IHsgSVBsb3RseURhdGEsIFBMT1RMWV9DSEFSVF9UWVBFIH0gZnJvbSAnfmNoZWxsLXZpen4vZGF0YSc7XG5cbi8qKlxuICogR2VuZXJhdGUgZGF0YSBpbiB0aGUgZXhwZWN0ZWQgZm9ybWF0IGZvciBhIFdlYkdMIFNjYXR0ZXIgcGxvdC5cbiAqXG4gKiBAcGFyYW0gZW50cnkgQSB1bml0IG9mIFBsb3RseSBkYXRhIGNvbnRhaW5pbmcgcG9pbnRzLCBjb2xvciwgbmFtZSwgYW5kIGFueSBleHRyYXMuXG4gKiBAcGFyYW0gbWlycm9yUG9pbnRzIFNob3VsZCB3ZSBtaXJyb3IgdGhlIHBvaW50cyBvbiB0aGUgeC95IGF4aXM/XG4gKiBAcmV0dXJucyBEYXRhIHN1aXRhYmxlIGZvciBjb25zdW1wdGlvbiBieSBQbG90bHkuXG4gKi9cbmV4cG9ydCBjb25zdCBnZW5lcmF0ZVNjYXR0ZXJHTERhdGEgPSAoXG4gIGVudHJ5OiBJQ29udGFjdE1hcENoYXJ0RGF0YSxcbiAgbWlycm9yUG9pbnRzOiBib29sZWFuID0gZmFsc2UsXG4pOiBQYXJ0aWFsPElQbG90bHlEYXRhPiA9PiAoe1xuICAuLi5nZW5lcmF0ZVNjYXR0ZXJEYXRhKGVudHJ5LCBtaXJyb3JQb2ludHMpLFxuICB0eXBlOiBQTE9UTFlfQ0hBUlRfVFlQRS5zY2F0dGVyZ2wsXG59KTtcblxuLyoqXG4gKiBHZW5lcmF0ZSBkYXRhIGluIHRoZSBleHBlY3RlZCBmb3JtYXQgZm9yIGEgU2NhdHRlciBwbG90LlxuICpcbiAqIEBwYXJhbSBlbnRyeSBBIHVuaXQgb2YgUGxvdGx5IGRhdGEgY29udGFpbmluZyBwb2ludHMsIGNvbG9yLCBuYW1lLCBhbmQgYW55IGV4dHJhcy5cbiAqIEBwYXJhbSBtaXJyb3JQb2ludHMgU2hvdWxkIHdlIG1pcnJvciB0aGUgcG9pbnRzIG9uIHRoZSB4L3kgYXhpcz9cbiAqIEByZXR1cm5zIERhdGEgc3VpdGFibGUgZm9yIGNvbnN1bXB0aW9uIGJ5IFBsb3RseS5cbiAqL1xuZXhwb3J0IGNvbnN0IGdlbmVyYXRlU2NhdHRlckRhdGEgPSAoXG4gIGVudHJ5OiBJQ29udGFjdE1hcENoYXJ0RGF0YSxcbiAgbWlycm9yUG9pbnRzOiBib29sZWFuID0gZmFsc2UsXG4pOiBQYXJ0aWFsPElQbG90bHlEYXRhPiA9PiB7XG4gIGNvbnN0IHsgbWFya2VyLCBwb2ludHMsIGhvdmVyaW5mbywgc3VidGl0bGUsIG5hbWUsIHRleHQgfSA9IGVudHJ5O1xuICBjb25zdCB4VmFsdWVzID0gcG9pbnRzLm1hcChkYXRhID0+IGRhdGEuaSk7XG4gIGNvbnN0IHlWYWx1ZXMgPSBwb2ludHMubWFwKGRhdGEgPT4gZGF0YS5qKTtcbiAgY29uc3QgelZhbHVlcyA9IHBvaW50cy5tYXAoZGF0YSA9PiAoZGF0YS5kaXN0ID8gZGF0YS5kaXN0IDogLTEpKTtcbiAgY29uc3QgdGV4dFZhbHVlcyA9IHRleHQgPyAoQXJyYXkuaXNBcnJheSh0ZXh0KSA/IHRleHQgOiBbdGV4dF0pIDogW107XG5cbiAgcmV0dXJuIHtcbiAgICBob3ZlcmluZm86IGhvdmVyaW5mbyA/IGhvdmVyaW5mbyA6ICd4K3kreicsXG4gICAgbWFya2VyOiB7XG4gICAgICBjb2xvcjogZGVyaXZlUGxvdGx5Q29sb3IobWlycm9yUG9pbnRzLCB6VmFsdWVzLCBlbnRyeSksXG4gICAgICBzaXplOiBlbnRyeS5ub2RlU2l6ZSxcbiAgICAgIC4uLm1hcmtlcixcbiAgICB9LFxuICAgIG1vZGU6ICdtYXJrZXJzJyxcbiAgICBuYW1lOiBgJHtuYW1lfSAke3N1YnRpdGxlfWAsXG4gICAgdGV4dDogbWlycm9yUG9pbnRzXG4gICAgICA/IFtcbiAgICAgICAgICAuLi50ZXh0VmFsdWVzLFxuICAgICAgICAgIC4uLnRleHRWYWx1ZXMubWFwKFxuICAgICAgICAgICAgLy8gR2l2ZW4gYSBjb29yZGluYXRlICcoeCwgeSknLCBjcmVhdGUgJyh5LCB4KScgLSBuZWVkZWQgYmVjYXVzZSB3ZSBoYXZlIGN1c3RvbSBob3ZlciBsYWJlbHMuXG4gICAgICAgICAgICBjb29yZCA9PlxuICAgICAgICAgICAgICBgKCR7Y29vcmRcbiAgICAgICAgICAgICAgICAuc3Vic3RyKDEsIGNvb3JkLmxlbmd0aCAtIDIpXG4gICAgICAgICAgICAgICAgLnNwbGl0KCcsICcpXG4gICAgICAgICAgICAgICAgLnJldmVyc2UoKVxuICAgICAgICAgICAgICAgIC5qb2luKCcsICcpfSlgLFxuICAgICAgICAgICksXG4gICAgICAgIF1cbiAgICAgIDogdGV4dFZhbHVlcyxcbiAgICB0eXBlOiBQTE9UTFlfQ0hBUlRfVFlQRS5zY2F0dGVyLFxuICAgIHg6IG1pcnJvclBvaW50cyA/IFsuLi54VmFsdWVzLCAuLi55VmFsdWVzXSA6IHhWYWx1ZXMsXG4gICAgeTogbWlycm9yUG9pbnRzID8gWy4uLnlWYWx1ZXMsIC4uLnhWYWx1ZXNdIDogeVZhbHVlcyxcbiAgICB6OiBtaXJyb3JQb2ludHMgPyBbLi4uelZhbHVlcywgLi4uelZhbHVlc10gOiB6VmFsdWVzLFxuICB9O1xufTtcblxuY29uc3QgZGVyaXZlUGxvdGx5Q29sb3IgPSAobWlycm9yUG9pbnRzOiBib29sZWFuLCB6VmFsdWVzOiBudW1iZXJbXSwgZW50cnk6IElDb250YWN0TWFwQ2hhcnREYXRhKSA9PiB7XG4gIGNvbnN0IHRvdGFsQ29sb3JzID0gbWlycm9yUG9pbnRzID8gelZhbHVlcy5sZW5ndGggKiAyIDogelZhbHVlcy5sZW5ndGg7XG4gIGNvbnN0IHJlc3VsdCA9IG5ldyBBcnJheTxQbG90bHkuQ29sb3I+KHRvdGFsQ29sb3JzKTtcblxuICBpZiAoZW50cnkubWFya2VyICYmIHR5cGVvZiBlbnRyeS5tYXJrZXIuY29sb3IgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHJlc3VsdC5maWxsKGVudHJ5Lm1hcmtlci5jb2xvcik7XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgelN0cmluZ3MgPSB6VmFsdWVzLm1hcCh2YWwgPT4gdmFsLnRvU3RyaW5nKCkpO1xuXG4gICAgcmV0dXJuIG1pcnJvclBvaW50cyA/IFsuLi56U3RyaW5ncywgLi4uelN0cmluZ3NdIDogelN0cmluZ3M7XG4gIH1cbn07XG5cbmV4cG9ydCBjb25zdCBnZW5lcmF0ZUZsb2F0MzJBcnJheUZyb21Db250YWN0cyA9IChhcnJheTogQXJyYXk8eyBpOiBudW1iZXI7IGo6IG51bWJlciB9PikgPT4ge1xuICBjb25zdCByZXN1bHQgPSBuZXcgRmxvYXQzMkFycmF5KGFycmF5Lmxlbmd0aCAqIDIpO1xuICBhcnJheS5mb3JFYWNoKChpdGVtLCBpbmRleCkgPT4ge1xuICAgIHJlc3VsdFtpbmRleCAqIDJdID0gaXRlbS5pO1xuICAgIHJlc3VsdFtpbmRleCAqIDIgKyAxXSA9IGl0ZW0uajtcbiAgfSk7XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8qKlxuICogR2VuZXJhdGUgZGF0YSBpbiB0aGUgZXhwZWN0ZWQgZm9ybWF0IGZvciBhIFBsb3RseSBQb2ludENsb3VkLlxuICpcbiAqIEBwYXJhbSBlbnRyeSBBIHVuaXQgb2YgUGxvdGx5IGRhdGEgY29udGFpbmluZyBwb2ludHMsIGNvbG9yLCBhbmQgYW55IGV4dHJhcy5cbiAqIEBwYXJhbSBtaXJyb3JQb2ludHMgU2hvdWxkIHdlIG1pcnJvciB0aGUgcG9pbnRzIG9uIHRoZSB4L3kgYXhpcz9cbiAqIEByZXR1cm5zIERhdGEgc3VpdGFibGUgZm9yIGNvbnN1bXB0aW9uIGJ5IFBsb3RseS5cbiAqL1xuZXhwb3J0IGNvbnN0IGdlbmVyYXRlUG9pbnRDbG91ZERhdGEgPSAoXG4gIGVudHJ5OiBJQ29udGFjdE1hcENoYXJ0RGF0YSxcbiAgbWlycm9yUG9pbnRzOiBib29sZWFuID0gZmFsc2UsXG4pOiBQYXJ0aWFsPElQbG90bHlEYXRhPiA9PiB7XG4gIGNvbnN0IHsgcG9pbnRzIH0gPSBlbnRyeTtcbiAgY29uc3QgY29vcmRzID0gZ2VuZXJhdGVGbG9hdDMyQXJyYXlGcm9tQ29udGFjdHMocG9pbnRzKTtcblxuICByZXR1cm4ge1xuICAgIG1hcmtlcjoge1xuICAgICAgLi4uZW50cnkubWFya2VyLFxuICAgICAgc2l6ZW1heDogZW50cnkubm9kZVNpemUgKiAyLFxuICAgICAgc2l6ZW1pbjogZW50cnkubm9kZVNpemUsXG4gICAgfSxcbiAgICBtb2RlOiAnbWFya2VycycsXG4gICAgdHlwZTogUExPVExZX0NIQVJUX1RZUEUucG9pbnRjbG91ZCxcbiAgICB4eTogbWlycm9yUG9pbnRzXG4gICAgICA/IG5ldyBGbG9hdDMyQXJyYXkoW1xuICAgICAgICAgIC4uLkFycmF5LmZyb20oY29vcmRzKSxcbiAgICAgICAgICAuLi5BcnJheS5mcm9tKGNvb3JkcylcbiAgICAgICAgICAgIC5zbGljZSgpXG4gICAgICAgICAgICAucmV2ZXJzZSgpLFxuICAgICAgICBdKVxuICAgICAgOiBjb29yZHMsXG4gIH07XG59O1xuIiwiaW1wb3J0IHsgQU1JTk9fQUNJRF9TSU5HTEVfTEVUVEVSX0NPREUgfSBmcm9tICd+Y2hlbGwtdml6fi9kYXRhJztcblxuY29uc3QgVU5JX1BST1RfUkVTTk9fSEVBREVSID0gJ3VwX2luZGV4JztcbmNvbnN0IFVOSV9QUk9UX1JFU05BTUVfSEVBREVSID0gJ3VwX3Jlc2lkdWUnO1xuY29uc3QgUERCX1JFU05PX0hFQURFUiA9ICdwZGJfaW5kZXgnO1xuY29uc3QgUERCX1JFU05BTUVfSEVBREVSID0gJ3BkYl9yZXNpZHVlJztcblxuY29uc3QgRVZfU0VSVkVSX0NPVVBMSU5HX0hFQURFUiA9ICdpZCc7XG5jb25zdCBFVl9TRVJWRVJfU1RSVUNUVVJFX0hFQURFUiA9ICdjb29yZF9pZCc7XG5jb25zdCBFVl9TRVJWRVJfU1RSVUNUVVJFX0NPREVfSEVBREVSID0gJ29uZV9sZXR0ZXJfY29kZSc7XG5cbmNvbnN0IEVWRk9MRF9FWFBFQ1RFRF9IRUFERVJTID0gW1VOSV9QUk9UX1JFU05PX0hFQURFUiwgVU5JX1BST1RfUkVTTkFNRV9IRUFERVIsIFBEQl9SRVNOT19IRUFERVIsIFBEQl9SRVNOQU1FX0hFQURFUl07XG5jb25zdCBFVlNFUlZFUl9FWFBFQ1RFRF9IRUFERVJTID0gW1xuICBFVl9TRVJWRVJfQ09VUExJTkdfSEVBREVSLFxuICBFVl9TRVJWRVJfU1RSVUNUVVJFX0hFQURFUixcbiAgRVZfU0VSVkVSX1NUUlVDVFVSRV9DT0RFX0hFQURFUixcbl07XG5cbmV4cG9ydCBpbnRlcmZhY2UgSVJlc2lkdWVNYXBwaW5nIHtcbiAgLyoqIE5hbWUgb2YgdGhlIHJlc2lkdWUgaW4gdGhlIFBEQiBmaWxlLiAqL1xuICBwZGJSZXNDb2RlOiBBTUlOT19BQ0lEX1NJTkdMRV9MRVRURVJfQ09ERTtcblxuICAvKiogTnVtYmVyIG9mIHRoZSByZXNpZHVlIGluIHRoZSBQREIgZmlsZS4gKi9cbiAgcGRiUmVzbm86IG51bWJlcjtcblxuICAvKiogTnVtYmVyIG9mIHRoZSByZXNpZHVlIGZyb20gQ291cGxpbmdTY29yZXMgZmlsZS4gKi9cbiAgY291cGxpbmdzUmVzbm86IG51bWJlcjtcblxuICAvKiogU2luZ2xlIGxldHRlciBjb2RlIG9mIHRoZSByZXNpZHVlIGZyb20gQ291cGxpbmdTY29yZXMgZmlsZS4gKi9cbiAgY291cGxpbmdzUmVzQ29kZTogQU1JTk9fQUNJRF9TSU5HTEVfTEVUVEVSX0NPREU7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lcyB0aGUgbWFwcGluZyBvZiByZXNpZHVlcyBmcm9tIGEgVW5pUHJvdCBmaWxlIHRvIGEgUERCLCBnaXZlbiBhIGluZGV4dGFibGVwbHVzIGZpbGUuXG4gKlxuICogQGRlc2NyaXB0aW9uIFRoaXMgZmlsZSBpcywgc2VtYW50aWNhbGx5LCBhIGNzdiB3aXRoIDQgaGVhZGVyczpcbiAqXG4gKiB1cF9pbmRleCAtIFVuaVByb3QgcmVzaWR1ZSBudW1iZXIuXG4gKlxuICogdXBfcmVzaWR1ZSAtIFVuaVByb3QgcmVzaWR1ZSBuYW1lLlxuICpcbiAqIHBkYl9pbmRleCAtIFBEQiByZXNpZHVlIG51bWJlci5cbiAqXG4gKiBwZGJfcmVzaWR1ZSAtIFBEQiByZXNpZHVlIG5hbWUuXG4gKlxuICogQHBhcmFtIHRleHQgVGhlIGNvbnRlbnRzIG9mIGEgaW5kZXh0YWJsZXBsdXMgZmlsZS5cbiAqIEByZXR1cm5zIEFycmF5IG9mIGFsbCByZXNpZHVlIG1hcHBpbmdzLlxuICovXG5leHBvcnQgY29uc3QgZ2VuZXJhdGVSZXNpZHVlTWFwcGluZyA9ICh0ZXh0OiBzdHJpbmcpOiBJUmVzaWR1ZU1hcHBpbmdbXSA9PiB7XG4gIGNvbnN0IHRhYk9yQ29tbWFSZWdleDogUmVnRXhwID0gL1xcdHwsLztcbiAgY29uc3QgaGVhZGVycyA9IHRleHQuc3BsaXQoJ1xcbicpWzBdLnNwbGl0KHRhYk9yQ29tbWFSZWdleCk7XG4gIGNvbnN0IGlzRXZTZXJ2ZXIgPSBpc0V2U2VydmVySm9iKGhlYWRlcnMpO1xuICBjb25zdCBoZWFkZXJNYXA6IHtcbiAgICBba2V5OiBzdHJpbmddOiBudW1iZXI7XG4gIH0gPSBnZXRSZXNpZHVlTWFwcGluZ0hlYWRlcnMoaGVhZGVycywgaXNFdlNlcnZlcik7XG5cbiAgY29uc3QgY291cGxpbmdzUmVzbm9JbmRleCA9IGlzRXZTZXJ2ZXIgPyBoZWFkZXJNYXBbRVZfU0VSVkVSX0NPVVBMSU5HX0hFQURFUl0gOiBoZWFkZXJNYXBbVU5JX1BST1RfUkVTTk9fSEVBREVSXTtcbiAgY29uc3Qgc3RydWN0dXJlUmVzbm9JbmRleCA9IGlzRXZTZXJ2ZXIgPyBoZWFkZXJNYXBbRVZfU0VSVkVSX1NUUlVDVFVSRV9IRUFERVJdIDogaGVhZGVyTWFwW1BEQl9SRVNOT19IRUFERVJdO1xuICBjb25zdCBzdHJ1Y3R1cmVSZXNDb2RlSW5kZXggPSBpc0V2U2VydmVyID8gaGVhZGVyTWFwW0VWX1NFUlZFUl9TVFJVQ1RVUkVfQ09ERV9IRUFERVJdIDogaGVhZGVyTWFwW1BEQl9SRVNOQU1FX0hFQURFUl07XG5cbiAgcmV0dXJuIHRleHRcbiAgICAuc3BsaXQoJ1xcbicpXG4gICAgLnNsaWNlKDEpXG4gICAgLnJlZHVjZSgocmVzdWx0OiBJUmVzaWR1ZU1hcHBpbmdbXSwgbGluZTogc3RyaW5nKSA9PiB7XG4gICAgICBjb25zdCBzcGxpdExpbmUgPSBsaW5lLnNwbGl0KHRhYk9yQ29tbWFSZWdleCk7XG4gICAgICBpZiAoc3BsaXRMaW5lLmxlbmd0aCA+PSBFVkZPTERfRVhQRUNURURfSEVBREVSUy5sZW5ndGgpIHtcbiAgICAgICAgcmVzdWx0LnB1c2goe1xuICAgICAgICAgIGNvdXBsaW5nc1Jlc0NvZGU6IGlzRXZTZXJ2ZXJcbiAgICAgICAgICAgID8gKHNwbGl0TGluZVtzdHJ1Y3R1cmVSZXNDb2RlSW5kZXhdIGFzIEFNSU5PX0FDSURfU0lOR0xFX0xFVFRFUl9DT0RFKVxuICAgICAgICAgICAgOiAoc3BsaXRMaW5lW2hlYWRlck1hcFtVTklfUFJPVF9SRVNOQU1FX0hFQURFUl1dIGFzIEFNSU5PX0FDSURfU0lOR0xFX0xFVFRFUl9DT0RFKSxcbiAgICAgICAgICBjb3VwbGluZ3NSZXNubzogcGFyc2VJbnQoc3BsaXRMaW5lW2NvdXBsaW5nc1Jlc25vSW5kZXhdLCAxMCksXG4gICAgICAgICAgcGRiUmVzQ29kZTogc3BsaXRMaW5lW3N0cnVjdHVyZVJlc0NvZGVJbmRleF0gYXMgQU1JTk9fQUNJRF9TSU5HTEVfTEVUVEVSX0NPREUsXG4gICAgICAgICAgcGRiUmVzbm86IHBhcnNlSW50KHNwbGl0TGluZVtzdHJ1Y3R1cmVSZXNub0luZGV4XSwgMTApLFxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LCBuZXcgQXJyYXk8SVJlc2lkdWVNYXBwaW5nPigpKTtcbn07XG5cbmNvbnN0IGdldFJlc2lkdWVNYXBwaW5nSGVhZGVycyA9IChoZWFkZXJzOiBzdHJpbmdbXSwgaXNFdlNlcnZlcjogYm9vbGVhbikgPT4ge1xuICBjb25zdCBoZWFkZXJNYXA6IHtcbiAgICBba2V5OiBzdHJpbmddOiBudW1iZXI7XG4gIH0gPSB7fTtcblxuICBjb25zdCBleHBlY3RlZEhlYWRlcnMgPSBpc0V2U2VydmVyID8gRVZTRVJWRVJfRVhQRUNURURfSEVBREVSUyA6IEVWRk9MRF9FWFBFQ1RFRF9IRUFERVJTO1xuICBpZiAoaGVhZGVycy5sZW5ndGggPj0gRVZGT0xEX0VYUEVDVEVEX0hFQURFUlMubGVuZ3RoKSB7XG4gICAgZXhwZWN0ZWRIZWFkZXJzLm1hcChoZWFkZXIgPT4ge1xuICAgICAgaWYgKCFoZWFkZXJzLmluY2x1ZGVzKGhlYWRlcikpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBNaXNzaW5nIGVycm9yICR7aGVhZGVyfSBpbiByZXNpZHVlIG1hcHBpbmcgZmlsZSFgKTtcbiAgICAgIH1cbiAgICAgIGhlYWRlck1hcFtoZWFkZXJdID0gaGVhZGVycy5pbmRleE9mKGhlYWRlcik7XG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gaGVhZGVyTWFwO1xufTtcblxuY29uc3QgaXNFdlNlcnZlckpvYiA9IChoZWFkZXJzOiBzdHJpbmdbXSkgPT4ge1xuICBmb3IgKGNvbnN0IGhlYWRlciBvZiBFVlNFUlZFUl9FWFBFQ1RFRF9IRUFERVJTKSB7XG4gICAgaWYgKCFoZWFkZXJzLmluY2x1ZGVzKGhlYWRlcikpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn07XG4iLCIvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6ZXhwb3J0LW5hbWVcbmV4cG9ydCBjb25zdCBjYXBpdGFsaXplRmlyc3RMZXR0ZXIgPSAodGV4dDogc3RyaW5nKSA9PlxuICBgJHt0ZXh0LnN1YnN0cigwLCAxKS50b0xvY2FsZVVwcGVyQ2FzZSgpfSR7dGV4dC5zdWJzdHIoMSkudG9Mb2NhbGVMb3dlckNhc2UoKX1gO1xuIiwiZXhwb3J0ICogZnJvbSAnLi9Db2xvck1hcHBlcic7XG5leHBvcnQgKiBmcm9tICcuL0NvdXBsaW5nTWFwcGVyJztcbmV4cG9ydCAqIGZyb20gJy4vRGF0YUhlbHBlcic7XG5leHBvcnQgKiBmcm9tICcuL0ZldGNoSGVscGVyJztcbmV4cG9ydCAqIGZyb20gJy4vTkdMSGVscGVyJztcbmV4cG9ydCAqIGZyb20gJy4vUGxvdGx5SGVscGVyJztcbmV4cG9ydCAqIGZyb20gJy4vUmVzaWR1ZU1hcHBlcic7XG5leHBvcnQgKiBmcm9tICcuL1N0cmluZ0hlbHBlcic7XG4iLCJpbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XG5cbi8qKlxuICogQ29udGV4dENvbnN1bWVyQ29tcG9zZXIgaXMgbWVhbnQgdG8gc3RyZWFtbGluZSBjb25uZWN0aW5nIHZhcmlvdXMgY29udGV4dCBjb25zdW1lcnMuXG4gKiBIZWF2aWx5IGJhc2VkIG9mZiBvZiBbcmVhY3QtY29tcG9zZXJdKGh0dHBzOi8vZ2l0aHViLmNvbS9qYW1lc3BsZWFzZS9yZWFjdC1jb21wb3NlcikuXG4gKlxuICogSG93ZXZlciwgdGhpcyBvbmx5IGFjY2VwdHMgYW4gYXJyYXkgb2YgY29udGV4dCB0eXBlcyBpbnN0ZWFkLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIElDb21wb3NlclByb3BzIHtcbiAgY29tcG9uZW50czogQXJyYXk8UmVhY3QuQ29tcG9uZW50VHlwZTxhbnk+PjtcbiAgY2hpbGRyZW4oYXJnczogYW55W10pOiBKU1guRWxlbWVudDtcbn1cblxuY2xhc3MgQ29udGV4dENvbnN1bWVyQ29tcG9zZXIgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQ8SUNvbXBvc2VyUHJvcHMsIGFueT4ge1xuICBwdWJsaWMgcmVuZGVyKCkge1xuICAgIGNvbnN0IHsgY2hpbGRyZW4sIGNvbXBvbmVudHMgfSA9IHRoaXMucHJvcHM7XG5cbiAgICByZXR1cm4gcmVuZGVyUmVjdXJzaXZlKGNoaWxkcmVuLCBjb21wb25lbnRzKTtcbiAgfVxufVxuXG4vKipcbiAqIFJlY3Vyc2l2ZWx5IGJ1aWxkIHVwIGVsZW1lbnRzIGZyb20gcHJvcHMuY29tcG9uZW50cyBhbmQgYWNjdW11bGF0ZSBgcmVzdWx0c2AgYWxvbmcgdGhlIHdheS5cbiAqL1xuY29uc3QgcmVuZGVyUmVjdXJzaXZlID0gKFxuICByZW5kZXI6IChhcmdzOiBhbnkpID0+IFJlYWN0LlJlYWN0RWxlbWVudDxhbnk+LFxuICByZW1haW5pbmc6IEFycmF5PFJlYWN0LkNvbXBvbmVudFR5cGU8YW55Pj4sXG4gIHJlc3VsdHM6IEFycmF5PFJlYWN0LlJlYWN0RWxlbWVudDxhbnk+PiA9IFtdLFxuKTogUmVhY3QuUmVhY3RFbGVtZW50PGFueT4gPT4ge1xuICAvLyBPbmNlIGNvbXBvbmVudHMgaXMgZXhoYXVzdGVkLCB3ZSBjYW4gcmVuZGVyIG91dCB0aGUgcmVzdWx0cyBhcnJheS5cbiAgaWYgKCFyZW1haW5pbmdbMF0pIHtcbiAgICByZXR1cm4gcmVuZGVyKHJlc3VsdHMpO1xuICB9XG5cbiAgLy8gQ29udGludWUgcmVjdXJzaW9uIGZvciByZW1haW5pbmcgaXRlbXMuXG4gIC8vIHJlc3VsdHMuY29uY2F0KFt2YWx1ZV0pIGVuc3VyZXMgWy4uLnJlc3VsdHMsIHZhbHVlXSBpbnN0ZWFkIG9mIFsuLi5yZXN1bHRzLCAuLi52YWx1ZV1cbiAgZnVuY3Rpb24gbmV4dFJlbmRlcih2YWx1ZTogUmVhY3QuUmVhY3RFbGVtZW50PGFueT4pIHtcbiAgICByZXR1cm4gcmVuZGVyUmVjdXJzaXZlKHJlbmRlciwgcmVtYWluaW5nLnNsaWNlKDEpLCByZXN1bHRzLmNvbmNhdChbdmFsdWVdKSk7XG4gIH1cblxuICBjb25zdCBJdGVtID0gcmVtYWluaW5nWzBdO1xuXG4gIC8vIFdoZW4gaXQgaXMgYW4gZWxlbWVudCwgZW5oYW5jZSB0aGUgZWxlbWVudCdzIHByb3BzIHdpdGggdGhlIHJlbmRlciBwcm9wLlxuICByZXR1cm4gUmVhY3QuY2xvbmVFbGVtZW50KDxJdGVtPntuZXh0UmVuZGVyfTwvSXRlbT4sIHsgZGlzcGxheU5hbWU6IEl0ZW0uZGlzcGxheU5hbWUgfSk7XG59O1xuXG5leHBvcnQgeyBDb250ZXh0Q29uc3VtZXJDb21wb3NlciB9O1xuIiwiZXhwb3J0ICogZnJvbSAnLi9Db250ZXh0Q29uc3VtZXJDb21wb3Nlcic7XG4iLCJleHBvcnQgKiBmcm9tICcuL2NvbXBvbmVudCc7XG5leHBvcnQgKiBmcm9tICcuL2NvbnRhaW5lcic7XG5leHBvcnQgKiBmcm9tICcuL2NvbnRleHQnO1xuZXhwb3J0ICogZnJvbSAnLi9kYXRhJztcbmV4cG9ydCAqIGZyb20gJy4vaGVscGVyJztcbmV4cG9ydCAqIGZyb20gJy4vaG9jJztcbmV4cG9ydCAqIGZyb20gJy4vcGFnZSc7XG5cbmV4cG9ydCAqIGZyb20gJy4vQ2hlbGxWaXpBcHAnO1xuIiwiaW1wb3J0IHsgZnJvbUpTLCBMaXN0IH0gZnJvbSAnaW1tdXRhYmxlJztcbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IFJvdXRlQ29tcG9uZW50UHJvcHMgfSBmcm9tICdyZWFjdC1yb3V0ZXInO1xuaW1wb3J0IHsgR3JpZCwgTWVzc2FnZSB9IGZyb20gJ3NlbWFudGljLXVpLXJlYWN0JztcblxuaW1wb3J0IHsgQW5hdG9tb2dyYW1Db250YWluZXIsIFNwcmluZ0NvbnRhaW5lciwgVGVuc29yVENvbnRhaW5lciB9IGZyb20gJ35jaGVsbC12aXp+L2NvbnRhaW5lcic7XG5pbXBvcnQgeyBWaXpEYXRhIH0gZnJvbSAnfmNoZWxsLXZpen4vZGF0YSc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgSURhdGFzZXRQYWdlUHJvcHMgZXh0ZW5kcyBQYXJ0aWFsPFJvdXRlQ29tcG9uZW50UHJvcHM+IHt9XG5cbmV4cG9ydCBpbnRlcmZhY2UgSURhdGFzZXRQYWdlU3RhdGUge1xuICB2aXN1YWxpemF0aW9uczogTGlzdDxzdHJpbmc+O1xuICBkYXRhc2V0TG9jYXRpb246IHN0cmluZztcbn1cblxuZXhwb3J0IGNsYXNzIERhdGFzZXRQYWdlIGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50PElEYXRhc2V0UGFnZVByb3BzLCBJRGF0YXNldFBhZ2VTdGF0ZT4ge1xuICBjb25zdHJ1Y3Rvcihwcm9wczogSURhdGFzZXRQYWdlUHJvcHMpIHtcbiAgICBzdXBlcihwcm9wcyk7XG4gICAgdGhpcy5zdGF0ZSA9IHtcbiAgICAgIGRhdGFzZXRMb2NhdGlvbjogJycsXG4gICAgICB2aXN1YWxpemF0aW9uczogTGlzdDxzdHJpbmc+KCksXG4gICAgfTtcbiAgfVxuXG4gIHB1YmxpYyBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICBpZiAodGhpcy5wcm9wcy5sb2NhdGlvbikge1xuICAgICAgdGhpcy5zZXR1cFNlYXJjaFBhcmFtZXRlcnModGhpcy5wcm9wcy5sb2NhdGlvbi5zZWFyY2gpO1xuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyBjb21wb25lbnREaWRVcGRhdGUocHJldlByb3BzOiBJRGF0YXNldFBhZ2VQcm9wcykge1xuICAgIGlmICh0aGlzLnByb3BzLmxvY2F0aW9uICYmIHRoaXMucHJvcHMubG9jYXRpb24gIT09IHByZXZQcm9wcy5sb2NhdGlvbikge1xuICAgICAgdGhpcy5zZXR1cFNlYXJjaFBhcmFtZXRlcnModGhpcy5wcm9wcy5sb2NhdGlvbi5zZWFyY2gpO1xuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyByZW5kZXIoKSB7XG4gICAgY29uc3QgeyB2aXN1YWxpemF0aW9ucywgZGF0YXNldExvY2F0aW9uIH0gPSB0aGlzLnN0YXRlO1xuXG4gICAgcmV0dXJuIChcbiAgICAgIDxkaXYgc3R5bGU9e3sgcGFkZGluZzogJzIwcHgnIH19PlxuICAgICAgICA8R3JpZCBjZW50ZXJlZD17dHJ1ZX0gc3RhY2thYmxlPXt0cnVlfSBzdHJldGNoZWQ9e2ZhbHNlfSBwYWRkZWQ9e3RydWV9IGNvbHVtbnM9ezJ9PlxuICAgICAgICAgIHtkYXRhc2V0TG9jYXRpb24ubGVuZ3RoID49IDEgJiZcbiAgICAgICAgICAgIHZpc3VhbGl6YXRpb25zLm1hcCgodmlzdWFsaXphdGlvbiwgaW5kZXgpID0+IChcbiAgICAgICAgICAgICAgPEdyaWQuQ29sdW1uIGtleT17YGRhdGFzZXQtdmlzdWFsaXphdGlvbi0ke2luZGV4fWB9IHN0eWxlPXt7IHdpZHRoOiAnYXV0bycgfX0+XG4gICAgICAgICAgICAgICAge3RoaXMucmVuZGVyVmlzdWFsaXphdGlvbih2aXN1YWxpemF0aW9uLCBkYXRhc2V0TG9jYXRpb24pfVxuICAgICAgICAgICAgICA8L0dyaWQuQ29sdW1uPlxuICAgICAgICAgICAgKSl9XG4gICAgICAgIDwvR3JpZD5cbiAgICAgIDwvZGl2PlxuICAgICk7XG4gIH1cblxuICBwcm90ZWN0ZWQgc2V0dXBTZWFyY2hQYXJhbWV0ZXJzKHF1ZXJ5OiBzdHJpbmcpIHtcbiAgICBjb25zdCBwYXJhbXMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKHF1ZXJ5KTtcbiAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bm8tYmFja2JvbmUtZ2V0LXNldC1vdXRzaWRlLW1vZGVsXG4gICAgY29uc3QgZGF0YXNldExvY2F0aW9uID0gcGFyYW1zLmdldCgnbmFtZScpO1xuICAgIGNvbnN0IHZpc3VhbGl6YXRpb25zID0gZnJvbUpTKHBhcmFtcy5nZXRBbGwoJ3ZpeicpKSBhcyBMaXN0PHN0cmluZz47XG5cbiAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgIGRhdGFzZXRMb2NhdGlvbjogZGF0YXNldExvY2F0aW9uID8gZGF0YXNldExvY2F0aW9uIDogJycsXG4gICAgICB2aXN1YWxpemF0aW9ucyxcbiAgICB9KTtcbiAgfVxuXG4gIHByb3RlY3RlZCByZW5kZXJWaXN1YWxpemF0aW9uKHZpejogc3RyaW5nIHwgdW5kZWZpbmVkLCBkYXRhc2V0TG9jYXRpb246IHN0cmluZykge1xuICAgIGNvbnN0IGlzRnVsbFBhZ2UgPSB0aGlzLnN0YXRlLnZpc3VhbGl6YXRpb25zLnNpemUgPT09IDE7XG4gICAgc3dpdGNoICh2aXopIHtcbiAgICAgIGNhc2UgVml6RGF0YS5zcHJpbmcubmFtZS50b0xvY2FsZUxvd2VyQ2FzZSgpOlxuICAgICAgICByZXR1cm4gPFNwcmluZ0NvbnRhaW5lciBkYXRhc2V0TG9jYXRpb249e2RhdGFzZXRMb2NhdGlvbn0gaXNGdWxsUGFnZT17aXNGdWxsUGFnZX0gLz47XG4gICAgICBjYXNlIFZpekRhdGEudGZqc1RzbmUubmFtZS50b0xvY2FsZUxvd2VyQ2FzZSgpOlxuICAgICAgICByZXR1cm4gPFRlbnNvclRDb250YWluZXIgZGF0YXNldExvY2F0aW9uPXtkYXRhc2V0TG9jYXRpb259IGlzRnVsbFBhZ2U9e2lzRnVsbFBhZ2V9IC8+O1xuICAgICAgY2FzZSBWaXpEYXRhLmFuYXRvbW9ncmFtLm5hbWUudG9Mb2NhbGVMb3dlckNhc2UoKTpcbiAgICAgICAgcmV0dXJuIDxBbmF0b21vZ3JhbUNvbnRhaW5lciBzcGVjaWVzPXtkYXRhc2V0TG9jYXRpb24uaW5jbHVkZXMoJ2hwYycpID8gJ2hvbW9fc2FwaWVucycgOiAnbXVzX211c2N1bHVzJ30gLz47XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gPE1lc3NhZ2UgZXJyb3I9e3RydWV9PntgQ3VycmVudGx5IHVuc3VwcG9ydGVkIHZpc3VhbGl6YXRpb24gJyR7dml6fSdgfTwvTWVzc2FnZT47XG4gICAgfVxuICB9XG59XG4iLCJpbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBSb3V0ZUNvbXBvbmVudFByb3BzIH0gZnJvbSAncmVhY3Qtcm91dGVyJztcbmltcG9ydCB7IExpbmsgfSBmcm9tICdyZWFjdC1yb3V0ZXItZG9tJztcbmltcG9ydCB7IEJ1dHRvbiwgQ29udGFpbmVyLCBEaXZpZGVyLCBHcmlkLCBIZWFkZXIsIFNlZ21lbnQgfSBmcm9tICdzZW1hbnRpYy11aS1yZWFjdCc7XG5cbmltcG9ydCB7IElEYXRhc2V0SW5mbywgSVN0b3J5LCBJVml6U3VtbWFyeURhdGEsIFN0b3JpZXMsIHVzZXJEYXRhc2V0cywgVml6RGF0YSB9IGZyb20gJ35jaGVsbC12aXp+L2RhdGEnO1xuXG5leHBvcnQgaW50ZXJmYWNlIElMYW5kaW5nUGFnZVByb3BzIGV4dGVuZHMgUGFydGlhbDxSb3V0ZUNvbXBvbmVudFByb3BzPiB7fVxuXG5leHBvcnQgY2xhc3MgTGFuZGluZ1BhZ2UgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQ8SUxhbmRpbmdQYWdlUHJvcHMsIGFueT4ge1xuICBjb25zdHJ1Y3Rvcihwcm9wczogSUxhbmRpbmdQYWdlUHJvcHMpIHtcbiAgICBzdXBlcihwcm9wcyk7XG4gIH1cblxuICBwdWJsaWMgcmVuZGVyKCkge1xuICAgIHJldHVybiAoXG4gICAgICA8Q29udGFpbmVyIGZsdWlkPXtmYWxzZX0+XG4gICAgICAgIDxTZWdtZW50IGJhc2ljPXt0cnVlfSBwYWRkZWQ9eyd2ZXJ5J30+XG4gICAgICAgICAgPEdyaWQgY2VudGVyZWQ9e3RydWV9IHBhZGRlZD17dHJ1ZX0gcmVsYXhlZD17dHJ1ZX0+XG4gICAgICAgICAgICB7dGhpcy5yZW5kZXJGZWF0dXJlZFN0b3JpZXMoKX1cbiAgICAgICAgICAgIHt0aGlzLnJlbmRlckZlYXR1cmVkVmlzdWFsaXphdGlvbnMoKX1cbiAgICAgICAgICAgIHt0aGlzLnJlbmRlckZlYXR1cmVkRGF0YXNldHMoKX1cbiAgICAgICAgICA8L0dyaWQ+XG4gICAgICAgIDwvU2VnbWVudD5cbiAgICAgIDwvQ29udGFpbmVyPlxuICAgICk7XG4gIH1cblxuICBwcm90ZWN0ZWQgcmVuZGVyU2luZ2xlVmlzdWFsaXphdGlvbih2aXo6IElWaXpTdW1tYXJ5RGF0YSkge1xuICAgIHJldHVybiAoXG4gICAgICA8R3JpZC5Sb3cgY29sdW1ucz17M30+XG4gICAgICAgIDxHcmlkLkNvbHVtbiB3aWR0aD17Mn0+XG4gICAgICAgICAgPGltZ1xuICAgICAgICAgICAgc3JjPXtgYXNzZXRzL2ljb25zLyR7dml6Lm5hbWUudG9Mb2NhbGVMb3dlckNhc2UoKX0tdGh1bWJuYWlsLnBuZ2B9XG4gICAgICAgICAgICBzdHlsZT17eyBoZWlnaHQ6ICc5MHB4Jywgd2lkdGg6ICc5MHB4JyB9fVxuICAgICAgICAgICAgYWx0PXtgdml6ICR7dml6Lm5hbWV9IGljb25gfVxuICAgICAgICAgIC8+XG4gICAgICAgIDwvR3JpZC5Db2x1bW4+XG4gICAgICAgIDxHcmlkLkNvbHVtbiB0ZXh0QWxpZ249eydsZWZ0J30gd2lkdGg9ezh9PlxuICAgICAgICAgIDxIZWFkZXI+e3Zpei5uYW1lfTwvSGVhZGVyPlxuICAgICAgICAgIHt2aXouc3VtbWFyeX1cbiAgICAgICAgICA8cD5cbiAgICAgICAgICAgIDxzcGFuIHN0eWxlPXt7IGZvbnRXZWlnaHQ6ICdib2xkJyB9fT57dml6Lmxpc3RBc09yaWdpbmFsID8gJ09yaWdpbmFsIGF1dGhvcnMnIDogJ0F1dGhvcnMnfTogPC9zcGFuPlxuICAgICAgICAgICAge3Zpei5hdXRob3JzLmxlbmd0aCA9PT0gMiA/IGAke3Zpei5hdXRob3JzWzBdfSBhbmQgJHt2aXouYXV0aG9yc1sxXX1gIDogdml6LmF1dGhvcnMuam9pbignLCAnKX1cbiAgICAgICAgICA8L3A+XG4gICAgICAgICAgPGJyIC8+XG4gICAgICAgIDwvR3JpZC5Db2x1bW4+XG4gICAgICAgIDxHcmlkLkNvbHVtbiB3aWR0aD17Mn0+XG4gICAgICAgICAgPEdyaWQuUm93PlxuICAgICAgICAgICAgPEJ1dHRvbiBiYXNpYz17dHJ1ZX0+XG4gICAgICAgICAgICAgIDxMaW5rIHRvPXt7IHBhdGhuYW1lOiAnL3Zpc3VhbGl6YXRpb25zLycsIHNlYXJjaDogYD9uYW1lPSR7dml6Lm5hbWUudG9Mb2NhbGVMb3dlckNhc2UoKX1gIH19PlxuICAgICAgICAgICAgICAgIGRldGFpbHNcbiAgICAgICAgICAgICAgPC9MaW5rPlxuICAgICAgICAgICAgPC9CdXR0b24+XG4gICAgICAgICAgPC9HcmlkLlJvdz5cbiAgICAgICAgICA8R3JpZC5Sb3c+XG4gICAgICAgICAgICA8QnV0dG9uIGJhc2ljPXt0cnVlfT5cbiAgICAgICAgICAgICAgPExpbmsgdG89e3sgcGF0aG5hbWU6ICcvZGF0YXNldCcsIHNlYXJjaDogYD92aXo9JHt2aXoubmFtZS50b0xvY2FsZUxvd2VyQ2FzZSgpfWAgfX0+bGF1bmNoPC9MaW5rPlxuICAgICAgICAgICAgPC9CdXR0b24+XG4gICAgICAgICAgPC9HcmlkLlJvdz5cbiAgICAgICAgPC9HcmlkLkNvbHVtbj5cbiAgICAgIDwvR3JpZC5Sb3c+XG4gICAgKTtcbiAgfVxuXG4gIHByb3RlY3RlZCByZW5kZXJGZWF0dXJlZERhdGFzZXRzKCkge1xuICAgIHJldHVybiAoXG4gICAgICA8PlxuICAgICAgICA8R3JpZC5Sb3cgY2VudGVyZWQ9e3RydWV9PlxuICAgICAgICAgIDxHcmlkLkNvbHVtbiB3aWR0aD17MTJ9PlxuICAgICAgICAgICAgPEhlYWRlciBmbG9hdGVkPXsnbGVmdCd9PkZlYXR1cmVkIERhdGFzZXRzPC9IZWFkZXI+XG4gICAgICAgICAgICA8RGl2aWRlciBzZWN0aW9uPXt0cnVlfSAvPlxuICAgICAgICAgIDwvR3JpZC5Db2x1bW4+XG4gICAgICAgIDwvR3JpZC5Sb3c+XG4gICAgICAgIDxHcmlkLlJvdyBjb2x1bW5zPXsyfSBkaXZpZGVkPXt0cnVlfT5cbiAgICAgICAgICB7dGhpcy5yZW5kZXJIQ0FEYXRhc2V0cygpfVxuICAgICAgICAgIHt0aGlzLnJlbmRlclVzZXJTaGFyZWREYXRhc2V0cygpfVxuICAgICAgICA8L0dyaWQuUm93PlxuICAgICAgICA8R3JpZC5Sb3cgY2VudGVyZWQ9e2ZhbHNlfT5cbiAgICAgICAgICA8R3JpZC5Db2x1bW4gd2lkdGg9ezEyfT5cbiAgICAgICAgICAgIDxMaW5rIHN0eWxlPXt7IGNvbG9yOiAnYmx1ZScsIGZsb2F0OiAncmlnaHQnIH19IHRvPXsnZGF0YXNldHMnfT5cbiAgICAgICAgICAgICAgbW9yZSBkYXRhc2V0cy4uLlxuICAgICAgICAgICAgPC9MaW5rPlxuICAgICAgICAgIDwvR3JpZC5Db2x1bW4+XG4gICAgICAgIDwvR3JpZC5Sb3c+XG4gICAgICA8Lz5cbiAgICApO1xuICB9XG5cbiAgcHJvdGVjdGVkIHJlbmRlckZlYXR1cmVkU3RvcmllcygpIHtcbiAgICByZXR1cm4gKFxuICAgICAgPD5cbiAgICAgICAgPEdyaWQuUm93IGNlbnRlcmVkPXtmYWxzZX0+XG4gICAgICAgICAgPEdyaWQuQ29sdW1uIHdpZHRoPXsxMn0+XG4gICAgICAgICAgICA8SGVhZGVyIGZsb2F0ZWQ9eydsZWZ0J30+RmVhdHVyZWQgU3RvcmllczwvSGVhZGVyPlxuICAgICAgICAgICAgPERpdmlkZXIgc2VjdGlvbj17dHJ1ZX0gLz5cbiAgICAgICAgICA8L0dyaWQuQ29sdW1uPlxuICAgICAgICA8L0dyaWQuUm93PlxuICAgICAgICB7dGhpcy5yZW5kZXJTaW5nbGVGZWF0dXJlZFN0b3J5KFN0b3JpZXNbMF0pfVxuICAgICAgICB7dGhpcy5yZW5kZXJTaW5nbGVGZWF0dXJlZFN0b3J5KFN0b3JpZXNbMV0pfVxuICAgICAgICA8R3JpZC5Sb3cgY2VudGVyZWQ9e2ZhbHNlfT5cbiAgICAgICAgICA8R3JpZC5Db2x1bW4gd2lkdGg9ezEyfT5cbiAgICAgICAgICAgIDxMaW5rIHN0eWxlPXt7IGNvbG9yOiAnYmx1ZScsIGZsb2F0OiAncmlnaHQnIH19IHRvPXsnc3Rvcmllcyd9PlxuICAgICAgICAgICAgICBtb3JlIHN0b3JpZXMuLi5cbiAgICAgICAgICAgIDwvTGluaz5cbiAgICAgICAgICA8L0dyaWQuQ29sdW1uPlxuICAgICAgICA8L0dyaWQuUm93PlxuICAgICAgPC8+XG4gICAgKTtcbiAgfVxuXG4gIHByb3RlY3RlZCByZW5kZXJGZWF0dXJlZFZpc3VhbGl6YXRpb25zKCkge1xuICAgIHJldHVybiAoXG4gICAgICA8PlxuICAgICAgICA8R3JpZC5Sb3cgY2VudGVyZWQ9e2ZhbHNlfT5cbiAgICAgICAgICA8R3JpZC5Db2x1bW4gd2lkdGg9ezEyfT5cbiAgICAgICAgICAgIDxIZWFkZXIgZmxvYXRlZD17J2xlZnQnfT5GZWF0dXJlZCBWaXN1YWxpemF0aW9uczwvSGVhZGVyPlxuICAgICAgICAgICAgPERpdmlkZXIgc2VjdGlvbj17dHJ1ZX0gLz5cbiAgICAgICAgICA8L0dyaWQuQ29sdW1uPlxuICAgICAgICA8L0dyaWQuUm93PlxuICAgICAgICB7dGhpcy5yZW5kZXJTaW5nbGVWaXN1YWxpemF0aW9uKFZpekRhdGEuc3ByaW5nKX1cbiAgICAgICAge3RoaXMucmVuZGVyU2luZ2xlVmlzdWFsaXphdGlvbihWaXpEYXRhLnRmanNUc25lKX1cbiAgICAgICAgPEdyaWQuUm93IGNlbnRlcmVkPXtmYWxzZX0+XG4gICAgICAgICAgPEdyaWQuQ29sdW1uIHdpZHRoPXsxMn0+XG4gICAgICAgICAgICA8TGluayBzdHlsZT17eyBjb2xvcjogJ2JsdWUnLCBmbG9hdDogJ3JpZ2h0JyB9fSB0bz17J3Zpc3VhbGl6YXRpb25zJ30+XG4gICAgICAgICAgICAgIG1vcmUgdmlzdWFsaXphdGlvbnMuLi5cbiAgICAgICAgICAgIDwvTGluaz5cbiAgICAgICAgICA8L0dyaWQuQ29sdW1uPlxuICAgICAgICA8L0dyaWQuUm93PlxuICAgICAgPC8+XG4gICAgKTtcbiAgfVxuXG4gIHByb3RlY3RlZCByZW5kZXJTaW5nbGVGZWF0dXJlZFN0b3J5KHN0b3J5OiBJU3RvcnkpIHtcbiAgICByZXR1cm4gKFxuICAgICAgPEdyaWQuUm93IGNvbHVtbnM9ezN9PlxuICAgICAgICA8R3JpZC5Db2x1bW4gd2lkdGg9ezJ9PlxuICAgICAgICAgIDxpbWcgc3JjPXtzdG9yeS5pY29ufSBzdHlsZT17eyBoZWlnaHQ6ICc5MHB4Jywgd2lkdGg6ICc5MHB4JyB9fSBhbHQ9e2BzdG9yeSAke3N0b3J5LnRpdGxlfSBpY29uYH0gLz5cbiAgICAgICAgPC9HcmlkLkNvbHVtbj5cbiAgICAgICAgPEdyaWQuQ29sdW1uIHRleHRBbGlnbj17J2xlZnQnfSB3aWR0aD17OH0+XG4gICAgICAgICAgPEhlYWRlcj57c3RvcnkudGl0bGV9PC9IZWFkZXI+XG4gICAgICAgICAgPHA+XG4gICAgICAgICAgICA8c3BhbiBzdHlsZT17eyBmb250V2VpZ2h0OiAnYm9sZCcgfX0+RGVzY3JpcHRpb246IDwvc3Bhbj5cbiAgICAgICAgICAgIHtzdG9yeS5kZXNjcmlwdGlvbn1cbiAgICAgICAgICA8L3A+XG4gICAgICAgICAgPHA+XG4gICAgICAgICAgICA8c3BhbiBzdHlsZT17eyBmb250V2VpZ2h0OiAnYm9sZCcgfX0+QW5hbHlzaXMgYXV0aG9yczogPC9zcGFuPlxuICAgICAgICAgICAge3N0b3J5LmF1dGhvcnMubGVuZ3RoID09PSAyID8gYCR7c3RvcnkuYXV0aG9yc1swXX0gYW5kICR7c3RvcnkuYXV0aG9yc1sxXX1gIDogc3RvcnkuYXV0aG9ycy5qb2luKCcsICcpfVxuICAgICAgICAgIDwvcD5cbiAgICAgICAgICA8YnIgLz5cbiAgICAgICAgPC9HcmlkLkNvbHVtbj5cbiAgICAgICAgPEdyaWQuQ29sdW1uIHdpZHRoPXsyfT5cbiAgICAgICAgICA8QnV0dG9uIGJhc2ljPXt0cnVlfT5cbiAgICAgICAgICAgIDxMaW5rIHRvPXtzdG9yeS5saW5rfT5sYXVuY2g8L0xpbms+XG4gICAgICAgICAgPC9CdXR0b24+XG4gICAgICAgIDwvR3JpZC5Db2x1bW4+XG4gICAgICA8L0dyaWQuUm93PlxuICAgICk7XG4gIH1cblxuICBwcm90ZWN0ZWQgcmVuZGVySENBRGF0YXNldHMoKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIDxHcmlkLkNvbHVtbiB3aWR0aD17M30+XG4gICAgICAgIDxHcmlkLlJvdz5cbiAgICAgICAgICA8aW1nXG4gICAgICAgICAgICBzcmM9eydhc3NldHMvaWNvbnMvaGNhLWxvZ28ucG5nJ31cbiAgICAgICAgICAgIHN0eWxlPXt7IHdpZHRoOiAnMTUwcHgnLCBoZWlnaHQ6ICcyNTBweCcgfX1cbiAgICAgICAgICAgIGFsdD17J2h1bWFuIGNlbGwgYXRsYXMgbG9nbyd9XG4gICAgICAgICAgLz5cbiAgICAgICAgICA8R3JpZC5Sb3c+XG4gICAgICAgICAgICA8YSBocmVmPXsnaHR0cHM6Ly9wcmV2aWV3LmRhdGEuaHVtYW5jZWxsYXRsYXMub3JnLyd9PlNlYXJjaCBIQ0EgZGF0YXNldHMgLi4uPC9hPlxuICAgICAgICAgIDwvR3JpZC5Sb3c+XG4gICAgICAgIDwvR3JpZC5Sb3c+XG4gICAgICA8L0dyaWQuQ29sdW1uPlxuICAgICk7XG4gIH1cblxuICBwcm90ZWN0ZWQgcmVuZGVyU2luZ2xlVXNlclNoYXJlZERhdGFzZXRzKGRhdGFzZXQ6IElEYXRhc2V0SW5mbykge1xuICAgIHJldHVybiAoXG4gICAgICA8R3JpZC5Sb3cgY29sdW1ucz17Mn0+XG4gICAgICAgIDxHcmlkLkNvbHVtbiBmbG9hdGVkPXsnbGVmdCd9PlxuICAgICAgICAgIDxIZWFkZXI+e2RhdGFzZXQubmFtZX08L0hlYWRlcj5cbiAgICAgICAgICA8cD5cbiAgICAgICAgICAgIHtkYXRhc2V0LnN1bW1hcnl9XG4gICAgICAgICAgICA8YnIgLz5cbiAgICAgICAgICAgIDxzcGFuIHN0eWxlPXt7IGZvbnRXZWlnaHQ6ICdib2xkJyB9fT5BdXRob3JzOiA8L3NwYW4+XG4gICAgICAgICAgICB7ZGF0YXNldC5hdXRob3JzLmpvaW4oJywgJyl9XG4gICAgICAgICAgPC9wPlxuICAgICAgICA8L0dyaWQuQ29sdW1uPlxuICAgICAgICA8R3JpZC5Db2x1bW4gZmxvYXRlZD17J3JpZ2h0J30+XG4gICAgICAgICAgPEJ1dHRvbiBiYXNpYz17dHJ1ZX0gZmxvYXRlZD17J3JpZ2h0J30+XG4gICAgICAgICAgICA8TGluayB0bz17ZGF0YXNldC5saW5rcy5kZXRhaWx9PmRldGFpbHM8L0xpbms+XG4gICAgICAgICAgPC9CdXR0b24+XG4gICAgICAgICAgPEJ1dHRvbiBiYXNpYz17dHJ1ZX0gZmxvYXRlZD17J3JpZ2h0J30+XG4gICAgICAgICAgICA8TGluayB0bz17ZGF0YXNldC5saW5rcy5hbmFseXNpc30+YW5hbHl6ZTwvTGluaz5cbiAgICAgICAgICA8L0J1dHRvbj5cbiAgICAgICAgPC9HcmlkLkNvbHVtbj5cbiAgICAgIDwvR3JpZC5Sb3c+XG4gICAgKTtcbiAgfVxuXG4gIHByb3RlY3RlZCByZW5kZXJVc2VyU2hhcmVkRGF0YXNldHMoKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIDxHcmlkLkNvbHVtbiBzdHJldGNoZWQ9e3RydWV9IHRleHRBbGlnbj17J2xlZnQnfSB3aWR0aD17OH0+XG4gICAgICAgIDxHcmlkLlJvdyB0ZXh0QWxpZ249eydjZW50ZXInfT5cbiAgICAgICAgICA8SGVhZGVyIGFzPXsnaDInfSB0ZXh0QWxpZ249eydjZW50ZXInfT5cbiAgICAgICAgICAgIFVzZXIgc2hhcmVkXG4gICAgICAgICAgPC9IZWFkZXI+XG4gICAgICAgIDwvR3JpZC5Sb3c+XG4gICAgICAgIDxiciAvPlxuICAgICAgICA8R3JpZC5Sb3c+e3RoaXMucmVuZGVyU2luZ2xlVXNlclNoYXJlZERhdGFzZXRzKHVzZXJEYXRhc2V0c1swXSl9PC9HcmlkLlJvdz5cbiAgICAgICAgPEdyaWQuUm93Pnt0aGlzLnJlbmRlclNpbmdsZVVzZXJTaGFyZWREYXRhc2V0cyh1c2VyRGF0YXNldHNbMV0pfTwvR3JpZC5Sb3c+XG4gICAgICA8L0dyaWQuQ29sdW1uPlxuICAgICk7XG4gIH1cbn1cbiIsImltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IFJvdXRlQ29tcG9uZW50UHJvcHMgfSBmcm9tICdyZWFjdC1yb3V0ZXInO1xuaW1wb3J0IHsgTGluayB9IGZyb20gJ3JlYWN0LXJvdXRlci1kb20nO1xuaW1wb3J0IHsgQnV0dG9uLCBHcmlkLCBIZWFkZXIgfSBmcm9tICdzZW1hbnRpYy11aS1yZWFjdCc7XG5cbmltcG9ydCB7IElTdG9yeSwgU3RvcmllcyB9IGZyb20gJ35jaGVsbC12aXp+L2RhdGEnO1xuXG5leHBvcnQgaW50ZXJmYWNlIElTdG9yaWVzUGFnZVByb3BzIGV4dGVuZHMgUGFydGlhbDxSb3V0ZUNvbXBvbmVudFByb3BzPiB7fVxuXG5leHBvcnQgY2xhc3MgU3Rvcmllc1BhZ2UgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQ8SVN0b3JpZXNQYWdlUHJvcHMsIGFueT4ge1xuICBjb25zdHJ1Y3Rvcihwcm9wczogSVN0b3JpZXNQYWdlUHJvcHMpIHtcbiAgICBzdXBlcihwcm9wcyk7XG4gIH1cblxuICBwdWJsaWMgcmVuZGVyKCkge1xuICAgIHJldHVybiAoXG4gICAgICA8R3JpZCBjZW50ZXJlZD17dHJ1ZX0gZGl2aWRlZD17J3ZlcnRpY2FsbHknfSBwYWRkZWQ9e3RydWV9IHJlbGF4ZWQ9e2ZhbHNlfT5cbiAgICAgICAge1N0b3JpZXMubWFwKChzdG9yeSwgaW5kZXgpID0+IChcbiAgICAgICAgICA8UmVhY3QuRnJhZ21lbnQga2V5PXtgc3RvcnktJHtpbmRleH1gfT57dGhpcy5yZW5kZXJTaW5nbGVGZWF0dXJlZFN0b3J5KHN0b3J5KX08L1JlYWN0LkZyYWdtZW50PlxuICAgICAgICApKX1cbiAgICAgIDwvR3JpZD5cbiAgICApO1xuICB9XG5cbiAgcHJvdGVjdGVkIHJlbmRlclNpbmdsZUZlYXR1cmVkU3Rvcnkoc3Rvcnk6IElTdG9yeSkge1xuICAgIHJldHVybiAoXG4gICAgICA8R3JpZC5Sb3cgY29sdW1ucz17M30+XG4gICAgICAgIDxHcmlkLkNvbHVtbj5cbiAgICAgICAgICA8aW1nIHNyYz17c3RvcnkuaWNvbn0gc3R5bGU9e3sgaGVpZ2h0OiAnOTBweCcsIHdpZHRoOiAnOTBweCcgfX0gYWx0PXtgc3RvcnkgJHtzdG9yeS50aXRsZX0gaWNvbmB9IC8+XG4gICAgICAgIDwvR3JpZC5Db2x1bW4+XG4gICAgICAgIDxHcmlkLkNvbHVtbiB0ZXh0QWxpZ249eydsZWZ0J30+XG4gICAgICAgICAgPEhlYWRlcj57c3RvcnkudGl0bGV9PC9IZWFkZXI+XG4gICAgICAgICAgPHA+XG4gICAgICAgICAgICA8c3BhbiBzdHlsZT17eyBmb250V2VpZ2h0OiAnYm9sZCcgfX0+RGVzY3JpcHRpb246IDwvc3Bhbj5cbiAgICAgICAgICAgIHtzdG9yeS5kZXNjcmlwdGlvbn1cbiAgICAgICAgICA8L3A+XG4gICAgICAgICAgPHA+XG4gICAgICAgICAgICA8c3BhbiBzdHlsZT17eyBmb250V2VpZ2h0OiAnYm9sZCcgfX0+QW5hbHlzaXMgYXV0aG9yczogPC9zcGFuPlxuICAgICAgICAgICAge3N0b3J5LmF1dGhvcnMubGVuZ3RoID09PSAyID8gYCR7c3RvcnkuYXV0aG9yc1swXX0gYW5kICR7c3RvcnkuYXV0aG9yc1sxXX1gIDogc3RvcnkuYXV0aG9ycy5qb2luKCcsICcpfVxuICAgICAgICAgIDwvcD5cbiAgICAgICAgICA8YnIgLz5cbiAgICAgICAgPC9HcmlkLkNvbHVtbj5cbiAgICAgICAgPEdyaWQuQ29sdW1uPlxuICAgICAgICAgIDxCdXR0b24gYmFzaWM9e3RydWV9PlxuICAgICAgICAgICAgPExpbmsgdG89e3N0b3J5Lmxpbmt9PmxhdW5jaDwvTGluaz5cbiAgICAgICAgICA8L0J1dHRvbj5cbiAgICAgICAgPC9HcmlkLkNvbHVtbj5cbiAgICAgIDwvR3JpZC5Sb3c+XG4gICAgKTtcbiAgfVxufVxuIiwiaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgUm91dGVDb21wb25lbnRQcm9wcyB9IGZyb20gJ3JlYWN0LXJvdXRlcic7XG5pbXBvcnQgeyBMaW5rIH0gZnJvbSAncmVhY3Qtcm91dGVyLWRvbSc7XG5pbXBvcnQgeyBCdXR0b24sIEdyaWQsIEhlYWRlciwgTGlzdCB9IGZyb20gJ3NlbWFudGljLXVpLXJlYWN0JztcblxuaW1wb3J0IHsgSVZpelN1bW1hcnlEYXRhLCBWaXpEYXRhIH0gZnJvbSAnfmNoZWxsLXZpen4vZGF0YSc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgSVZpc3VhbGl6YXRpb25zUGFnZVByb3BzIGV4dGVuZHMgUGFydGlhbDxSb3V0ZUNvbXBvbmVudFByb3BzPiB7fVxuXG5leHBvcnQgY2xhc3MgVmlzdWFsaXphdGlvbnNQYWdlIGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50PElWaXN1YWxpemF0aW9uc1BhZ2VQcm9wcywgYW55PiB7XG4gIGNvbnN0cnVjdG9yKHByb3BzOiBJVmlzdWFsaXphdGlvbnNQYWdlUHJvcHMpIHtcbiAgICBzdXBlcihwcm9wcyk7XG4gIH1cblxuICBwdWJsaWMgcmVuZGVyKCkge1xuICAgIHJldHVybiAoXG4gICAgICA8TGlzdCBkaXZpZGVkPXt0cnVlfT5cbiAgICAgICAgPExpc3QuSXRlbT57dGhpcy5yZW5kZXJWaXN1YWxpemF0aW9uSXRlbShWaXpEYXRhLnNwcmluZyl9PC9MaXN0Lkl0ZW0+XG4gICAgICAgIDxMaXN0Lkl0ZW0+e3RoaXMucmVuZGVyVmlzdWFsaXphdGlvbkl0ZW0oVml6RGF0YS50ZmpzVHNuZSl9PC9MaXN0Lkl0ZW0+XG4gICAgICAgIDxMaXN0Lkl0ZW0+e3RoaXMucmVuZGVyVmlzdWFsaXphdGlvbkl0ZW0oVml6RGF0YS5hbmF0b21vZ3JhbSl9PC9MaXN0Lkl0ZW0+XG4gICAgICA8L0xpc3Q+XG4gICAgKTtcbiAgfVxuXG4gIHByb3RlY3RlZCByZW5kZXJWaXN1YWxpemF0aW9uSXRlbSh2aXo6IElWaXpTdW1tYXJ5RGF0YSkge1xuICAgIHJldHVybiAoXG4gICAgICA8R3JpZCBjZW50ZXJlZD17dHJ1ZX0gY29sdW1ucz17M30gcGFkZGVkPXt0cnVlfSByZWxheGVkPXt0cnVlfT5cbiAgICAgICAgPEdyaWQuQ29sdW1uPlxuICAgICAgICAgIDxpbWdcbiAgICAgICAgICAgIHNyYz17YGFzc2V0cy9pY29ucy8ke3Zpei5uYW1lLnRvTG9jYWxlTG93ZXJDYXNlKCl9LXRodW1ibmFpbC5wbmdgfVxuICAgICAgICAgICAgYWx0PXtgaWNvbiBmb3IgJHt2aXoubmFtZX1gfVxuICAgICAgICAgICAgc3R5bGU9e3sgaGVpZ2h0OiAnMTAwcHgnIH19XG4gICAgICAgICAgLz5cbiAgICAgICAgPC9HcmlkLkNvbHVtbj5cbiAgICAgICAgPEdyaWQuQ29sdW1uIHRleHRBbGlnbj17J2xlZnQnfT5cbiAgICAgICAgICA8SGVhZGVyIGFzPXsnaDInfT57dml6Lm5hbWV9PC9IZWFkZXI+XG4gICAgICAgICAgPExpc3Q+XG4gICAgICAgICAgICA8TGlzdC5JdGVtPntgJHt2aXoubGlzdEFzT3JpZ2luYWwgPyAnb3JpZ2luYWw6ICcgOiAnJ30ke3Zpei5hdXRob3JzLmpvaW4oJywgJyl9YH08L0xpc3QuSXRlbT5cbiAgICAgICAgICAgIDxMaXN0Lkl0ZW0+e3Zpei5zdW1tYXJ5fTwvTGlzdC5JdGVtPlxuICAgICAgICAgICAgPExpc3QuSXRlbT57YHJlbGV2YW50IGRhdGE6ICR7dml6LnJlbGV2YW50RGF0YX1gfTwvTGlzdC5JdGVtPlxuICAgICAgICAgIDwvTGlzdD5cbiAgICAgICAgPC9HcmlkLkNvbHVtbj5cbiAgICAgICAgPEdyaWQuQ29sdW1uIHN0cmV0Y2hlZD17dHJ1ZX0+XG4gICAgICAgICAgPEdyaWQuUm93PlxuICAgICAgICAgICAgPEJ1dHRvbiBiYXNpYz17dHJ1ZX0+XG4gICAgICAgICAgICAgIDxMaW5rIHRvPXt7IHBhdGhuYW1lOiAnL3Zpc3VhbGl6YXRpb25zLycsIHNlYXJjaDogYD9uYW1lPSR7dml6Lm5hbWUudG9Mb2NhbGVMb3dlckNhc2UoKX1gIH19PlxuICAgICAgICAgICAgICAgIGRldGFpbHNcbiAgICAgICAgICAgICAgPC9MaW5rPlxuICAgICAgICAgICAgPC9CdXR0b24+XG4gICAgICAgICAgPC9HcmlkLlJvdz5cbiAgICAgICAgICA8R3JpZC5Sb3c+XG4gICAgICAgICAgICA8QnV0dG9uIGJhc2ljPXt0cnVlfT5cbiAgICAgICAgICAgICAgPExpbmsgdG89e3sgcGF0aG5hbWU6ICcvZGF0YXNldCcsIHNlYXJjaDogYD92aXo9JHt2aXoubmFtZS50b0xvY2FsZUxvd2VyQ2FzZSgpfWAgfX0+bGF1bmNoPC9MaW5rPlxuICAgICAgICAgICAgPC9CdXR0b24+XG4gICAgICAgICAgPC9HcmlkLlJvdz5cbiAgICAgICAgPC9HcmlkLkNvbHVtbj5cbiAgICAgIDwvR3JpZD5cbiAgICApO1xuICB9XG59XG4iLCJpbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBSb3V0ZUNvbXBvbmVudFByb3BzIH0gZnJvbSAncmVhY3Qtcm91dGVyJztcbmltcG9ydCB7IEFjY29yZGlvbiwgQnV0dG9uLCBDb250YWluZXIsIERpdmlkZXIsIEdyaWQsIEhlYWRlciwgSWNvbiwgTGlzdCB9IGZyb20gJ3NlbWFudGljLXVpLXJlYWN0JztcblxuaW1wb3J0IHsgTGluayB9IGZyb20gJ3JlYWN0LXJvdXRlci1kb20nO1xuaW1wb3J0IHsgSVZpekV4YW1wbGUsIElWaXpPdmVydmlld0RhdGEsIFZpekRhdGEgfSBmcm9tICd+Y2hlbGwtdml6fi9kYXRhJztcblxuZXhwb3J0IGludGVyZmFjZSBJVml6T3ZlcnZpZXdQYWdlUHJvcHMgZXh0ZW5kcyBQYXJ0aWFsPFJvdXRlQ29tcG9uZW50UHJvcHM+IHt9XG5cbmV4cG9ydCBpbnRlcmZhY2UgSVZpek92ZXJ2aWV3UGFnZVN0YXRlIHtcbiAgY3VycmVudFZpejogSVZpek92ZXJ2aWV3RGF0YSB8IG51bGw7XG59XG5cbmV4cG9ydCBjbGFzcyBWaXpPdmVydmlld1BhZ2UgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQ8SVZpek92ZXJ2aWV3UGFnZVByb3BzLCBJVml6T3ZlcnZpZXdQYWdlU3RhdGU+IHtcbiAgY29uc3RydWN0b3IocHJvcHM6IElWaXpPdmVydmlld1BhZ2VQcm9wcykge1xuICAgIHN1cGVyKHByb3BzKTtcbiAgICB0aGlzLnN0YXRlID0ge1xuICAgICAgY3VycmVudFZpejogbnVsbCxcbiAgICB9O1xuICB9XG5cbiAgcHVibGljIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgIHRoaXMuc2V0dXBDdXJyZW50Vml6KCk7XG4gIH1cblxuICBwdWJsaWMgY29tcG9uZW50RGlkVXBkYXRlKHByZXZQcm9wczogSVZpek92ZXJ2aWV3UGFnZVByb3BzKSB7XG4gICAgaWYgKHRoaXMucHJvcHMubG9jYXRpb24gIT09IHByZXZQcm9wcy5sb2NhdGlvbikge1xuICAgICAgdGhpcy5zZXR1cEN1cnJlbnRWaXooKTtcbiAgICB9XG4gIH1cblxuICBwdWJsaWMgcmVuZGVyKCkge1xuICAgIHJldHVybiAoXG4gICAgICB0aGlzLnN0YXRlLmN1cnJlbnRWaXogJiYgKFxuICAgICAgICA8Q29udGFpbmVyPlxuICAgICAgICAgIHt0aGlzLnJlbmRlck92ZXJ2aWV3KHRoaXMuc3RhdGUuY3VycmVudFZpeil9XG4gICAgICAgICAge3RoaXMucmVuZGVyRXhhbXBsZXModGhpcy5zdGF0ZS5jdXJyZW50Vml6LmV4YW1wbGVzKX1cbiAgICAgICAgPC9Db250YWluZXI+XG4gICAgICApXG4gICAgKTtcbiAgfVxuXG4gIHByb3RlY3RlZCByZW5kZXJPdmVydmlldyh2aXo6IElWaXpPdmVydmlld0RhdGEpIHtcbiAgICByZXR1cm4gKFxuICAgICAgPEdyaWQgY2VudGVyZWQ9e3RydWV9IGNvbHVtbnM9ezJ9PlxuICAgICAgICA8R3JpZC5Db2x1bW4gd2lkdGg9ezJ9PlxuICAgICAgICAgIDxpbWdcbiAgICAgICAgICAgIGFsdD17YGljb24gZm9yICR7dml6Lm5hbWV9YH1cbiAgICAgICAgICAgIHNyYz17YGFzc2V0cy9pY29ucy8ke3Zpei5uYW1lLnRvTG9jYWxlTG93ZXJDYXNlKCl9LWljb24ucG5nYH1cbiAgICAgICAgICAgIHN0eWxlPXt7IGhlaWdodDogJzE1MHB4JywgcGFkZGluZzogJzIwcHgnIH19XG4gICAgICAgICAgLz5cbiAgICAgICAgPC9HcmlkLkNvbHVtbj5cbiAgICAgICAgPEdyaWQuQ29sdW1uIHRleHRBbGlnbj17J2xlZnQnfT5cbiAgICAgICAgICA8SGVhZGVyIGFzPXsnaDEnfT5cbiAgICAgICAgICAgIHt2aXoubmFtZX1cbiAgICAgICAgICAgIDxIZWFkZXIuU3ViaGVhZGVyPnt2aXouYXV0aG9ycy5qb2luKCcsICcpfTwvSGVhZGVyLlN1YmhlYWRlcj5cbiAgICAgICAgICA8L0hlYWRlcj5cbiAgICAgICAgICA8PlxuICAgICAgICAgICAgPHA+e3Zpei5kZXRhaWxlZFN1bW1hcnl9PC9wPlxuICAgICAgICAgICAgPExpc3Q+XG4gICAgICAgICAgICAgIDxMaXN0Lkl0ZW0+YXBwbGljYWJsZSBkYXRhOiB7dml6LnJlbGV2YW50RGF0YX08L0xpc3QuSXRlbT5cbiAgICAgICAgICAgICAgPExpc3QuSXRlbT5jb21wYXRpYmxlIHdpdGg6IHt2aXouY29tcGF0aWJpbGl0eS5qb2luKCcsICcpfTwvTGlzdC5JdGVtPlxuICAgICAgICAgICAgICA8TGlzdC5JdGVtPlxuICAgICAgICAgICAgICAgIGNpdGF0aW9uKHMpOnsnICd9XG4gICAgICAgICAgICAgICAge3Zpei5jaXRhdGlvbnMubWFwKChjaXRhdGlvbiwgaW5kZXgpID0+IChcbiAgICAgICAgICAgICAgICAgIDxSZWFjdC5GcmFnbWVudCBrZXk9e2Ake3Zpei5uYW1lLnRvTG9jYWxlTG93ZXJDYXNlKCl9LWNpdGF0aW9uLSR7aW5kZXh9YH0+XG4gICAgICAgICAgICAgICAgICAgIHtjaXRhdGlvbi5mdWxsQ2l0YXRpb259ICh7PGEgaHJlZj17Y2l0YXRpb24ubGlua30+bGluazwvYT59KVxuICAgICAgICAgICAgICAgICAgPC9SZWFjdC5GcmFnbWVudD5cbiAgICAgICAgICAgICAgICApKX1cbiAgICAgICAgICAgICAgPC9MaXN0Lkl0ZW0+XG4gICAgICAgICAgICAgIDxMaXN0Lkl0ZW0+XG4gICAgICAgICAgICAgICAgdmVyc2lvbjoge3Zpei5yZXBvLnZlcnNpb259IChsYXN0IHVwZGF0ZWQge3Zpei5yZXBvLmxhc3RVcGRhdGV9KSxcbiAgICAgICAgICAgICAgICB7PGEgaHJlZj17dml6LnJlcG8ubGlua30+IGdpdGh1YiBsaW5rPC9hPn1cbiAgICAgICAgICAgICAgPC9MaXN0Lkl0ZW0+XG4gICAgICAgICAgICAgIDxMaXN0Lkl0ZW0+XG4gICAgICAgICAgICAgICAgPEdyaWQuQ29sdW1uIGZsb2F0ZWQ9eydyaWdodCd9PlxuICAgICAgICAgICAgICAgICAgPEJ1dHRvbiBiYXNpYz17dHJ1ZX0gaWNvbj17dHJ1ZX0gbGFiZWxQb3NpdGlvbj17J3JpZ2h0J30+XG4gICAgICAgICAgICAgICAgICAgIDxMaW5rIHRvPXt7IHBhdGhuYW1lOiAnL2RhdGFzZXQnLCBzZWFyY2g6IGA/dml6PSR7dml6Lm5hbWUudG9Mb2NhbGVMb3dlckNhc2UoKX1gIH19PlxuICAgICAgICAgICAgICAgICAgICAgIHtgbGF1bmNoICR7dml6Lm5hbWV9YH1cbiAgICAgICAgICAgICAgICAgICAgPC9MaW5rPlxuICAgICAgICAgICAgICAgICAgICB7LyogUG93ZXIgR2FwICovfVxuICAgICAgICAgICAgICAgICAgICA8SWNvbiBuYW1lPXsnZXh0ZXJuYWwgYWx0ZXJuYXRlJ30gLz5cbiAgICAgICAgICAgICAgICAgIDwvQnV0dG9uPlxuICAgICAgICAgICAgICAgIDwvR3JpZC5Db2x1bW4+XG4gICAgICAgICAgICAgIDwvTGlzdC5JdGVtPlxuICAgICAgICAgICAgPC9MaXN0PlxuICAgICAgICAgIDwvPlxuICAgICAgICA8L0dyaWQuQ29sdW1uPlxuICAgICAgPC9HcmlkPlxuICAgICk7XG4gIH1cblxuICBwcm90ZWN0ZWQgcmVuZGVyRXhhbXBsZXMoZXhhbXBsZXM6IElWaXpFeGFtcGxlW10pIHtcbiAgICBjb25zdCBwYW5lbHMgPSBbXG4gICAgICB7XG4gICAgICAgIGNvbnRlbnQ6IHtcbiAgICAgICAgICBjb250ZW50OiAoXG4gICAgICAgICAgICA8PlxuICAgICAgICAgICAgICA8RGl2aWRlciAvPlxuICAgICAgICAgICAgICA8R3JpZCBjZW50ZXJlZD17dHJ1ZX0gY29sdW1ucz17MX0gY29udGFpbmVyPXt0cnVlfSBkaXZpZGVkPXsndmVydGljYWxseSd9IHN0eWxlPXt7IHBhZGRpbmc6ICcxMHB4IDAnIH19PlxuICAgICAgICAgICAgICAgIHtleGFtcGxlcy5tYXAoKGV4YW1wbGUsIGluZGV4KSA9PiAoXG4gICAgICAgICAgICAgICAgICA8R3JpZC5Sb3cgY29sdW1ucz17Mn0ga2V5PXtgdml6LWV4YW1wbGUtJHtpbmRleH1gfT5cbiAgICAgICAgICAgICAgICAgICAge3RoaXMucmVuZGVyRXhhbXBsZUVudHJ5KGV4YW1wbGUpfVxuICAgICAgICAgICAgICAgICAgPC9HcmlkLlJvdz5cbiAgICAgICAgICAgICAgICApKX1cbiAgICAgICAgICAgICAgPC9HcmlkPlxuICAgICAgICAgICAgPC8+XG4gICAgICAgICAgKSxcbiAgICAgICAgfSxcbiAgICAgICAga2V5OiAnZXhhbXBsZXMnLFxuICAgICAgICB0aXRsZTogJ2V4YW1wbGUgc3RvcmllcycsXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBjb250ZW50OiAnY29taW5nIHNvb24hJyxcbiAgICAgICAga2V5OiAnbGVhcm4nLFxuICAgICAgICB0aXRsZTogJ2xlYXJuJyxcbiAgICAgIH0sXG4gICAgXTtcblxuICAgIHJldHVybiA8QWNjb3JkaW9uIHBhbmVscz17cGFuZWxzfSBkZWZhdWx0QWN0aXZlSW5kZXg9ezB9IC8+O1xuICB9XG5cbiAgcHJvdGVjdGVkIHJlbmRlckV4YW1wbGVFbnRyeShleGFtcGxlOiBJVml6RXhhbXBsZSkge1xuICAgIHJldHVybiAoXG4gICAgICA8PlxuICAgICAgICA8R3JpZC5Db2x1bW4gd2lkdGg9ezJ9PlxuICAgICAgICAgIDxpbWcgc3JjPXtleGFtcGxlLmljb259IGFsdD17YCR7ZXhhbXBsZS5uYW1lfSBpY29uYH0gc3R5bGU9e3sgaGVpZ2h0OiAnNzVweCcsIHdpZHRoOiAnNzVweCcgfX0gLz5cbiAgICAgICAgPC9HcmlkLkNvbHVtbj5cbiAgICAgICAgPEdyaWQuQ29sdW1uIHRleHRBbGlnbj17J2xlZnQnfSB3aWR0aD17OH0+XG4gICAgICAgICAgPEhlYWRlcj57ZXhhbXBsZS5uYW1lfTwvSGVhZGVyPlxuICAgICAgICAgIDxwPntleGFtcGxlLnN1bW1hcnl9PC9wPlxuICAgICAgICA8L0dyaWQuQ29sdW1uPlxuICAgICAgICA8R3JpZC5Db2x1bW4gZmxvYXRlZD17J3JpZ2h0J30+XG4gICAgICAgICAgPEJ1dHRvbiBiYXNpYz17dHJ1ZX0gaWNvbj17dHJ1ZX0gbGFiZWxQb3NpdGlvbj17J3JpZ2h0J30+XG4gICAgICAgICAgICA8TGluayB0bz17ZXhhbXBsZS5saW5rfT57J2xhdW5jaCBleGFtcGxlJ308L0xpbms+XG4gICAgICAgICAgICB7LyogUG93ZXIgR2FwICovfVxuICAgICAgICAgICAgPEljb24gbmFtZT17J2V4dGVybmFsIGFsdGVybmF0ZSd9IC8+XG4gICAgICAgICAgPC9CdXR0b24+XG4gICAgICAgIDwvR3JpZC5Db2x1bW4+XG4gICAgICA8Lz5cbiAgICApO1xuICB9XG5cbiAgcHJvdGVjdGVkIHNldHVwQ3VycmVudFZpeigpIHtcbiAgICBjb25zdCBwYXJhbXMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKHRoaXMucHJvcHMubG9jYXRpb24gPyB0aGlzLnByb3BzLmxvY2F0aW9uLnNlYXJjaCA6ICcnKTtcbiAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bm8tYmFja2JvbmUtZ2V0LXNldC1vdXRzaWRlLW1vZGVsXG4gICAgY29uc3Qgdml6TmFtZSA9IHBhcmFtcy5nZXQoJ25hbWUnKTtcblxuICAgIGlmICh2aXpOYW1lID09PSBWaXpEYXRhLnNwcmluZy5uYW1lLnRvTG9jYWxlTG93ZXJDYXNlKCkpIHtcbiAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICBjdXJyZW50Vml6OiBWaXpEYXRhLnNwcmluZyxcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAodml6TmFtZSA9PT0gVml6RGF0YS50ZmpzVHNuZS5uYW1lLnRvTG9jYWxlTG93ZXJDYXNlKCkpIHtcbiAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICBjdXJyZW50Vml6OiBWaXpEYXRhLnRmanNUc25lLFxuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmICh2aXpOYW1lID09PSBWaXpEYXRhLmFuYXRvbW9ncmFtLm5hbWUudG9Mb2NhbGVMb3dlckNhc2UoKSkge1xuICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgIGN1cnJlbnRWaXo6IFZpekRhdGEuYW5hdG9tb2dyYW0sXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbn1cbiIsImV4cG9ydCAqIGZyb20gJy4vVmlzdWFsaXphdGlvbnNQYWdlJztcbmV4cG9ydCAqIGZyb20gJy4vRGF0YXNldFBhZ2UnO1xuZXhwb3J0ICogZnJvbSAnLi9MYW5kaW5nUGFnZSc7XG5leHBvcnQgKiBmcm9tICcuL1N0b3JpZXNQYWdlJztcbmV4cG9ydCAqIGZyb20gJy4vVml6T3ZlcnZpZXdQYWdlJztcbiIsIi8qIChpZ25vcmVkKSAqLyIsIi8qIChpZ25vcmVkKSAqLyIsIi8qIChpZ25vcmVkKSAqLyIsIi8qIChpZ25vcmVkKSAqLyJdLCJzb3VyY2VSb290IjoiIn0=